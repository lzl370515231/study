# 集合

Java 的集合类主要由两个接口派生而出：Collection 和Map。

## Collection

![](.\png\java-Collection框架图.png)

### API方法

| 方法                              | 方法原型                                         | 方法描述                                                     |
| --------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| add(E e)                          | public boolean add(E e)                          | 确保此Collection包含指定的元素（可选操作）                   |
| addAll(Collection<? extends E> c) | public boolean addAll(Collection<? extends E> e) | 将指定 collection 中的所有元素都添加到此Collection中（可选操作） |
| clear()                           | public void clear()                              | 移除此 collection 中的所有元素（可选操作）                   |
| contains(Object o)                | public boolean contains(Object o)                | 如果此 collection 包含指定元的元素，则返回 true              |
| containsAll(Collection<?> c)      | public boolean containsAll(Collection<?> c)      | 如果此 collection 包含指定 collection 中的所有元素，则返回 true。 |
| equals(Object o)                  | public boolean equals(Object o)                  | 比较此 collection 与指定对象是否相等                         |
| hashCode()                        | public int hashCode()                            | 返回此 collection 的哈希码值                                 |
| isEmpty()                         | public boolean isEmpty()                         | 如果此 collection 的元素上不包含元素，则返回 true            |
| iterator()                        | public Iterator<E> iterator()                    | 返回在此 collection 的元素上进行迭代的迭代器                 |
| remove(Object o)                  | public boolean remove(Object o)                  | 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作） |
| removeAll(Collection<?> c)        | public boolean removeAll(Collection<?> c)        | 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作） |
| retainAll(Collection<?> c)        | public boolean retainAll(Collection<?> c)        | 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作） |
| size()                            | public int size()                                | 返回此 collection 中的元素数                                 |
| toArray()                         | Object[] toArray()                               | 返回包含此 collection 中所有元素的数组                       |
| toArray(T[] a)                    | public <T> T[] toArray(T[] a)                    | 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同 |

### Iterator接口定义方法

| 方法      | 方法原型                 | 方法描述                         |
| --------- | ------------------------ | -------------------------------- |
| hasNext() | public boolean hasNext() | 如果仍有元素可以迭代，则返回true |
| next()    | public E next()          | 返回迭代的下一个元素             |

#### 说明

当使用Iterator对集合元素进行迭代时，Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。

```java
public class IteratorExample{
    public static void main(String[] args){
        List<String> list = Arrays.asList("Java","Python","C++");
        Iterator<String> iterator = list.iterator();
        while(iterator.hasNext()){
            String next = iterator.next();	//集合元素的值传递给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址
            next = "修改后的";
            System.out.println(next);
        }
        System.out.println(list);
    }
}
```

输出结果：

```shell
修改后的
修改后的
修改后的
[java语言, C语言, C++语言]
```

### Set集合

Set集合就是 Collection，只是行为略有不同（Set不允许包含重复元素）。

**Set集合不允许包含相同的元素**，如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add() 方法返回 false，且新元素不会被加入。

#### HashSet

HashSet按Hash算法来存储集合中的元素。因此具有很好的存取和查找性能。

##### 特点

1. 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。
2. HashSet不是同步的
3. 集合元素值可以是null

##### 相等

HashSet集合判断两个元素**相等的标准**是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。

###### equal

Object.java

通过判断两个对象的地址是否相等（即，是否是同一个对象）来区分它们是否相等。

```java
public boolean equal(Object obj){
    return (this== obj);
}
```

###### hashCode

hashCode() 的作用是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。**这个哈希码的作用是确定该对象在哈希表中的索引位置**。

hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建某个“类"的散列表时，该类的hashCode() 才有用。更通俗地说就是创建包含该类的HashMap，Hashtable，HashSet集合时，hashCode() 才有用。

###### hashCode元素比较后操作

1. 如果有两个元素通过equal()方法比较返回false，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。
2. 如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。
3. 如果两个对象通过equals()方法比较不相等，hashCode()方法比较相等，HashSet将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。
4. 如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回true，HashSet将不予添加。

##### 说明

HashSet是根据元素的hashCode值来快速定位的，如果HashSet中两个以上的元素具有相同的hashCode值，将会导致性能下降。

##### LinkedHashSet

LinkedHashSet是HashSet对的子类，也是根据元素的hashCode值来决定元素的存储位置，**同时使用链表维护元素的次序**，使得元素是以插入的顺序来保存的。当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与HashSet，但在迭代访问Set里的全部元素时有很好的性能。

#### TreeSet

TreeSet是SortedSet接口的实现类，可以确保集合元素处于排序状态。

##### 特点

- 有序（红黑树）
- 线程非安全

##### API 方法

| 方法                              | 方法描述                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| comparator()                      | 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回null |
| first()                           | 返回此set 中当前第一个（最低）元素                           |
| last()                            | 返回此 set 中当前最后一个（最高）元素                        |
| lower(E e)                        | 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null |
| higher(E e)                       | 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null |
| subSet(E fromElement,E toElement) | 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括） |
| headSet(E toElement)              | 返回此 set 的部分视图，其元素小于toElement                   |
| tailSet(E fromElement)            | 返回此 set 的部分视图，其元素大于等于 fromElement            |

##### 排序方式

TreeSet是根据**红黑树**结构找到集合元素的存储位置。

###### Comparable接口

Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法,该方法返回一个整数值，实现了该接口的类的对象就可以比较大小了。

###### 分类

- 自然排序
- 定制排序

###### 自然排序（调用集合元素的compareTo()方法）

TreeSet会**调用集合中元素所属类的compareTo(Object obj)方法来比较元素之间的大小关系**，然后将集合元素按升序排列，即把通过compareTo(Object obj)方法比较后比较大的的往后排。这种方式就是自然排序。

###### 定制排序（比较器传入 TreeSet）

如果要实现定制排序，则需要在创建TreeSet时，调用一个带参构造器，传入Comparator对象。并有该Comparator对象负责集合元素的排序逻辑，集合元素可以不必实现Comparable接口。

```java
public static void main(String[] args){
	Person p1 = new Person();
	p1.age =20;
	Person p2 =new Person();
	p2.age = 30;
	Comparator<Person> comparator = new Comparator<Person>() {

		@Override
		public int compare(Person o1, Person o2) {
			//年龄越小的排在越后面
			if(o1.age<o2.age){
				return 1;
			}else if(o1.age>o2.age){
				return -1;
			}else{
				return 0;
			}
		}
	};
	TreeSet<Person> set = new TreeSet<Person>(comparator);
	set.add(p1);
	set.add(p2);
	System.out.println(set);
}
```



###### 排序注意事项

1. Java的一些常用类已经实现了Comparable接口，并提供了比较大小的标准。除了这些已经实现Comparable接口类之外，如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则就会出现异常。
2. TreeSet中只能添加同一种类型的对象，否则无法比较，会出现异常

##### 特别注意

如果向TreeSet中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但TreeSet不会再次调整它们。而且如果修改后进行元素删除操作可能会不成功，具体比较复杂。**总之，推荐不要修改放入TreeSet集合中元素的关键实例变量。**

#### EnumSet

##### 特点

1. EnumSet集合不允许加入null元素。EnumSet中的所有元素都必须是指定枚举类型的枚举值。
2. EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的类方法来创建EnumSet对象。
3. 非线程安全

##### API方法

EnumSet没有其他额外增加的方法，只是增加了一些创建EnumSet对象的方法。

| 方法                         | 方法原型                                                     | 方法描述                                                     |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| allOf(Class<E> elementType)  | public static <E extends Enum<E>> EnumSet<E>allOf(Class<E> elementType) | 创建一个包含指定元素类型的所有元素的枚举 set                 |
| clone()                      | public EnumSet<E> clone()                                    | 返回 set 的副本                                              |
| complementOf(EnumSet<E> e)   | public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> e) | 创建一个其元素与指定枚举set相同的枚举set，最初包含指定 set中所不包含的此类型的所有元素 |
| copyOf(Collection<E> c)      | public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c) | 创建一个从指定 collection 初始化的枚举 set                   |
| copyOf(EnumSet<E> s)         | public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s) | 创建一个其元素类型与指定枚举 set 相同的枚举 set，最初包含相同的元素（如果有的话） |
| noneOf(Class<E> elementType) | public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) | 创建一个具有指定元素类型的空枚举 set                         |
| of(E e)                      | public static <E extends Enum<E>> EnumSet<E> of(E e)         | 创建一个最初包含指定元素的枚举 set                           |
| of(E first,E... rest)        | public static <E extends Enum<E>> EnumSet<E> of(E first,E... rest) | 创建一个最初包含指定元素的枚举 set                           |
| of(E e1,E e2)                | public static <E extends Enum<E>> EnumSet<E> of(E e1,E e2)   | 创建一个最初包含指定元素的枚举 set                           |
| of(E e1,E e2,E e3)           | public static <E extends Enum<E>> EnumSet<E> of(E e1,E e2,E e3) | 创建一个最初包含指定元素的枚举 set                           |
| of(E e1,E e2,E e3,E e4)      | public static <E extends Enum<E>> EnumSet<E> of(E e1,E e2,E e3,E e4) | 创建一个最初包含指定元素的枚举 set                           |
| of(E e1,E e2,E e3,E e4,E e5) | public static <E extends Enum<E>> EnumSet<E> of(E e1,E e2,E e3,E e4,E e5) | 创建一个最初包含指定元素得到枚举 set                         |
| range(E from,E to)           | public static <E extends Enum<E>> EnumSet<E> range(E from,E to) | 创建一个最初包含由两个指定端点所定义范围内的所有元素的枚举 set |

#### 比较

##### 性能

EnumSet性能>HashSet性能>LinkedHashSet>TreeSet性能

##### 使用场景

- 当需要一个特定排序的集合时，使用TreeSet集合
- 当需要保存枚举类的枚举值时，使用EnumSet集合
- 当经常使用添加、查询操作时，使用HashSet
- 当经常插入排序或使用删除、插入及遍历操作时，使用LinkedHashSet

### List集合

List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。

List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1......

#### API方法

| 方法名                                      | 方法原型                                                   | 方法描述                                                     |
| ------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| add(int index,Object element)               | public void add(int index,Object element)                  | 在列表的指定位置插入指定元素（可选操作）                     |
| addAll(int index,Collection<? extends E> c) | public boolean addAll(int index,Collection<? extends E> c) | 将集合 c中的所有元素都插入到列表中的指定位置 index 处        |
| get(index)                                  | public Object get(index)                                   | 返回列表中指定位置的元素                                     |
| indexOf(Object o)                           | public int indexOf(Object o)                               | 返回此列表中的第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1 |
| lastIndexOf(Object o)                       | public int lastIndedxOf(Object o)                          | 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1 |
| remove(int index)                           | public Object remove(int index)                            | 移除列表中指定位置的元素                                     |
| set(int index,Object element)               | public Object set(int index,Object element)                | 用指定元素替换列表中指定位置的元素                           |
| subList(int fromIndex,int toIndex)          | public List subList(int fromIndex.int toIndex)             | 返回列表中指定的 fromIndex(包括)和toIndex(不包括)之间的所有集合元素组成的子集 |
| toArray()                                   | public Object[] toArray()                                  | 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素） |

#### Java 8 API

| 方法                               | 方法名                                      | 方法描述                                             |
| ---------------------------------- | ------------------------------------------- | ---------------------------------------------------- |
| replaceAll(UnaryOperator operator) | public void replace(UnaryOperator operator) | 根据operator指定的计算规则重新设置List集合的所有元素 |
| sort(Comparator c)                 | public void sort(Comparator c)              | 根据Comparator参数对 List集合的元素排序              |

#### 相等

List判断两个对象相等只要通过equals()方法比较返回true即可

#### ListIterator

与Iterator相比，ListIterator增加了前向迭代的功能，还可以通过add()方法向List集合中添加元素。

##### API方法

| 方法          | 方法原型                     | 方法描述                                                |
| ------------- | ---------------------------- | ------------------------------------------------------- |
| hasPrevious() | public boolean hasPrevious() | 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true |
| previous()    | public Object previous()     | 返回迭代器的前一个元素                                  |
| add(Object o) | public void add(Object o)    | 将指定的元素插入列表（可选操作）                        |

#### Vector

##### 特点

1. 基于数组实现的 List 类。
2. 封装了一个动态的、允许再分配的Object[] 数组。使用 intalCapacity 参数来设置数组长度，当向ArrayList或Vector中添加元素超过了该数组的长度时，它们的initalCapacity会自动增加。
3. 线程安全

##### Stack

Stack是Vector的子类，用户模拟“栈”这种数据结构，“栈”通常是指“后进先出”(LIFO)的容器。

###### API 方法

| 方法             | 方法原型                    | 方法描述                                       |
| ---------------- | --------------------------- | ---------------------------------------------- |
| empty()          | public boolean empty()      | 测试堆栈是否为空                               |
| peek()           | public E peek()             | 查看堆栈顶部的对象，但不从堆栈中移除它         |
| pop()            | public E pop()              | 移除堆栈顶部的对象，并作为此函数的值返回该对象 |
| push(E item)     | public E push(E item)       | 把项压入堆栈顶部                               |
| search(Object o) | public int search(Object o) | 返回对象在堆栈中的位置，以 1 为基数            |

###### 特点

- 线程安全

#### ArrayList

##### 特点

1. 基于数组实现的 List 类。
2. 封装了一个动态的、允许再分配的Object[] 数组。使用 intalCapacity 参数来设置数组长度，当向ArrayList或Vector中添加元素超过了该数组的长度时，它们的initalCapacity会自动增加。
3. 线程不安全

##### 源码

添加元素

```java
public boolean add(E e) {
	ensureCapacityInternal(size + 1);  // 数组的大小增加1
	elementData[size++] = e;
	return true;
}
```

先调用了一个ensureCapacityInternal()方法，顾名思义：该方法用来确保数组中是否还有足够容量。
经过一系列方法（不必关心），最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：

```java
private void grow(int minCapacity){
    //......省略部分内容  主要是为了生成大小合适的newCapacity
	//下面这行就是进行了数组扩容
	elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### API-调整其容量大小

| 方法                            | 方法原型                                    | 方法描述                                                     |
| ------------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| ensureCapacity(int minCapacity) | public void ensureCapacity(int minCapacity) | 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数 |
| trimToSize()                    | public void trimToSize()                    | 将此 ArrayList 实例的容量调整为列表的当前大小                |



##### ArrayList遍历

- 通过迭代器遍历

  ```java
  Integer value = null;
  Iterator iter = list.iterator();
  while(iter.hasNext()){
      value = (Integer) iter.next();
  }
  ```

- 随机访问，通过索引值去遍历

  ```java
  Integer value = null;
  int size = list.size();
  for (int i=0; i<size; i++) {
      value = (Integer)list.get(i);        
  }
  ```

- for循环遍历

  ```java
  Integer value = null;
  for (Integer integ:list) {
      value = integ;
  }
  ```

###### 各遍历方法效率比较

遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低。

##### ArrayList 与 Vector 的区别

1. ArrayList是线程不安全的，Vector是线程安全的。
2. Vector的性能比ArrayList 差

#### LinkedList

##### 特点

1. LinkedList类是List接口的实现类——这意味着它是一个List集合，可以根据索引来随机访问集合中的元素。
2. LinkedList还实现了Deque接口，可以被当作成双端队列来使用
3. LinkedList内部以链表的形式来保存集合中的元素
4. LinkedList 是非线程安全

##### API 方法

| 方法                            | 方法原型                                       | 方法描述                                                     |
| ------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| addFirst(E e)                   | public void addFirst(E e)                      | 将指定元素插入此列表的开头                                   |
| addLast(E e)                    | public void addLast(E e)                       | 将指定元素添加到此列表的结尾                                 |
| getFirst（E e）                 | public E getFirst(E e)                         | 返回此列表的第一个元素                                       |
| getLast(E e)                    | public E getLast(E e)                          | 返回此列表的最后一个元素                                     |
| offerFirst(E e)                 | public boolean offerFirst(E e)                 | 在此列表的开头插入指定的元素                                 |
| offerLast(E e)                  | public boolean offerLast(E e)                  | 在此列表末尾插入指定的元素                                   |
| peekFirst(E e)                  | public E peekFirst(E e)                        | 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null  |
| peekLast(E e)                   | public E peekLast(E e)                         | 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null |
| pollFirst(E e)                  | public E pollFirst(E e)                        | 获取并移除此列表的第一个元素；如果此列表为空，则返回 null    |
| pollLast(E e)                   | public E pollLast(E e)                         | 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null  |
| removeFirst(E e)                | public E removeFirst(E e)                      | 移除并返回此列表的第一个元素                                 |
| removeFirstOccurrence(Objcet o) | public boolean removeFirstOccurrence(Objcet o) | 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时） |
| removeLast(E e)                 | public E removeLast(E e)                       | 移除并返回此列表的最后一个元素                               |
| removeLastOccurrence(Objcet o)  | public boolean removeLastOccurrence(Objcet o)  | 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时） |

##### 源码

###### LinkedList结构

```java
//成员变量：表头，表尾
transient Node<E> first;
transient Node<E> last;
//默认构造函数，表示创建一个空链表
public LinkedList() {
}
```

**Node类**

```java
private static class Node{
    //表示集合元素的值
    E item;
    //指向下个元素
    Node<E> next;
    //指向上个元素
    Node<E> prev;
    ....
}
```

###### 双向链表和索引值的联系

```java
public E get(int index){
    checkElementIndex(index);	//检查索引是否有效
    return node(index).item;
}
```

**node(index)**

```java
Node<E> node(int index) {
	// assert isElementIndex(index);
	if (index < (size >> 1)) {
		Node<E> x = first;
		for (int i = 0; i < index; i++)
			x = x.next;
		return x;
	} else {
		Node<E> x = last;
		for (int i = size - 1; i > index; i--)
			x = x.prev;
		return x;
	}
}
```



##### LinkedList遍历方式

1. 通过迭代器遍历LinkedList
2. 通过快速随机访问遍历LinkedList
3. 通过for循环遍历LinkedList
4. 通过pollFirst()遍历LinkedList
5. 通过pollLast()遍历LinkedList
6. 通过removeFirst()遍历LinkedList
7. 通过removeLast()遍历LinkedList

###### 遍历效率

其中采用逐个遍历的方式，效率比较高。采用随机访问的方式去遍历LinkedList的方式效率最低。

### Queue

![](E:/lzl/study/java/doc/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/png/java-queue-%E7%B1%BB%E5%9B%BE.png)

#### 特点

- 元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素
- 队列不允许随机访问队列中的元素

#### API方法

对于 Queue 而言是在 Collection 的基础上增加了 offer/remove/poll/element/peek 方法，另外重新定义了 add 方法。

| 方法       | 方法原型                  | 方法描述                                                     |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| add(E e)   | public boolean add(E e)   | 将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException |
| element()  | public E element()        | 获取，但是不移除此队列的头                                   |
| offer(E e) | public boolean offer(E e) | 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常 |
| peek()     | public E peek()           | 获取但不移除此队列的头；如果此队列为空，则返回null           |
| poll()     | public E poll()           | 获取并移除此队列的头，如果此队列为空，则返回null             |
| remove()   | public E remove()         | 获取并移除此队列的头                                         |

#### PriorityQueue

##### 特点

- 按队列元素的大小进行重新排序
- PrioityQueue不是线程安全的
- 不允许插入 null 元素

##### 排序方式

- 自然排序

  加入PriorityQueue 的元素必须实现了 Comparator 接口

- 定制排序

  指定 PriorityQueue 的 Comparator 接口

  ```java
  public PriorityQueue(int initialCapacity,Comparator<? super E> comparator) {
      // Note: This restriction of at least one is not actually needed
      // but continues for 1.5 compatibility
  	if (initialCapacity < 1)
  		throw new IllegalArgumentException();
  	this.queue = new Object[initialCapacity];
  	this.comparator = comparator;
  }
  ```

  

##### API方法

| 方法               | 方法原型                                  | 方法描述                                                     |
| ------------------ | ----------------------------------------- | ------------------------------------------------------------ |
| add(E e)           | public boolean add(E e)                   | 将指定的元素插入此优先级队列                                 |
| clear()            | public void clear()                       | 从此优先级队列中移除所有元素                                 |
| comparator()       | public Comparator<? super E> comparator() | 返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然排序进行排序，则返回null |
| contains(Object o) | public boolean contains(Object o)         | 如果此队列包含指定的元素，则返回 true                        |
| iterator()         | public Iterator<E> iterator()             | 返回在此队列中的元素上进行迭代的迭代器                       |
| offer()            | public boolean offer(E e)                 | 将指定的元素插入此优先级队列                                 |
| peek()             | public E peek()                           | 获取但不移除此队列的头；如果此队列为空，则返回null           |
| poll()             | puublic E poll()                          | 获取并移除此队列的头，如果此队列为空，则返回 null            |
| remove(Object o)   | public boolean remove(Object o)           | 从此队列中移除指定元素的单个实例（如果存在）                 |
| size()             | public int size()                         | 返回此 collection 中的元素数                                 |
| toArray()          | public Object[] toArray()                 | 返回一个包含此队列所有元素的数组                             |
| toArray()          | public <T> T[] toArray(T[] a)             | 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型 |

###### 方法时间复杂度

- PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；

- 实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；

- 实现检索方法（peek、element 和 size）的时间复杂度是O(1)。

##### 遍历

若不需要删除元素，则以 peek 的方式遍历每个元素

##### 源码

PriorityQueue 本质也是一个动态数组。

当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用 `grow()`方法增加容量，然后调用`siftUp`将新加入的元素排序插入对应位置。

```java
public boolean offer(E e) {
	if (e == null)
		throw new NullPointerException();
	modCount++;
	int i = size;
	if (i >= queue.length)
		grow(i + 1);
	size = i + 1;
	if (i == 0)
		queue[0] = e;
	else
		siftUp(i, e);
	return true;
}
```

##### 注意

方法 iterator() 中提供的迭代器并不保证以有序的方式遍历 PriorityQueue 中的元素

#### Deque

Deque接口是Queue接口的子接口，它代表一个双端队列。

##### 特点

- Deque 代表一个双端队列。

##### API方法

| 方法名                           | 方法原型                                       | 方法描述                                                     |
| -------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| addFirst(E e)                    | public void addFirst(E e)                      | 将指定元素插入此列表的开头                                   |
| addLast(E e)                     | public void addLast(E e)                       | 将指定元素添加到此列表的结尾                                 |
| getFirst(E e)                    | public E getFirst(E e)                         | 返回此列表的第一个元素                                       |
| getLast(E e)                     | public E getLast(E e)                          | 返回此列表的最后一个元素                                     |
| offerFirst(E e)                  | public boolean offerFirst(E e)                 | 在此列表的开头插入指定的元素                                 |
| offerLast(E e)                   | public boolean offerLast(E e)                  | 在此列表末尾插入指定的元素                                   |
| peekFirst(E e)                   | public E peekFirst(E e)                        | 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null  |
| peekLast(E e)                    | public E peekLast(E e)                         | 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null |
| pollFirst(E e)                   | public E pollFirst(E e)                        | 获取并移除此列表的第一个元素；如果此列表为空，则返回null     |
| pollLast(E e)                    | public E pollLast(E e)                         | 获取并移除此列表的最后一个元素；如果此列表为空，则返回null   |
| removeFirst(E e)                 | public E removeFirst(E e)                      | 移除并返回此列额表的第一个元素                               |
| removeFirstOccurrencee(Object o) | public boolean removeFirstOccurrence(Objcet o) | 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时） |
| removeLast(E e)                  | public E removeLast(E e)                       | 除并返回此列表的最后一个元素                                 |
| removeLastOccurrence(Objcet o)   | public boolean removeLastOccurrence(Objcet o)  | 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时） |

###### 类比Queue 与 Stack

| Queue Method | Equivalent Deque Method |
| ------------ | ----------------------- |
| add(e)       | addLast(e)              |
| offer(e)     | offerLast(e)            |
| remove()     | removeFirst()           |
| poll()       | pollFirst()             |
| element()    | getFirst()              |
| peek()       | peekFirst()             |

**类比 Stack**

| Stack Method | Equivalent Deque Method |
| ------------ | ----------------------- |
| push(e)      | addFirst(e)             |
| pop()        | removeFirst()           |
| peek()       | peekFirst()             |



#### ArrayDeque

##### 特点

- 用数组实现的 Deque
- 支持动态扩容
- 按照元素插入数组中对应位置产生的
- ArrayDeque 不是线程安全的

##### 结构

```java
transient int head;
transient int tail;
```

当向头部插入元素时，head下标减一然后插入元素。而 tail表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向tail表示的位置插入，然后tail再减一。

![](.\png\java-ArrayDeque结构.png)

##### 循环数组

```java
public void addFirst(E e){
    if(e == null){
        throw new NullPointerException()(;)
    }
    elements[head =(head-1) & (elements.length -1)] =e;
    if(head == tail){
        doubleCapacity();
    }
}
```

`head = (head - 1) & (elements.length - 1)`很好的解决了下标越界的问题。这段代码相当于取模，同时解决了head为负值的情况。因为elements.length必需是2的指数倍（代码中有具体操作），elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用。如果head - 1为负数，其实只可能是-1，当为-1时，和elements.length - 1进行与操作，这时结果为elements.length - 1。其他情况则不变，等于它本身。

##### 扩容

`doubieCapacity()`

![](.\png\java-ArrayDeque-扩容.png)

复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。

```java
//doubleCapacity()
private void doubleCapacity() {
	assert head == tail;
    int p = head;
    int n = elements.length;
    int r = n - p; // head右边元素的个数
    int newCapacity = n << 1;//原空间的2倍
    if (newCapacity < 0)
        throw new IllegalStateException("Sorry, deque too big");
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分
    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分
    elements = (E[])a;
    head = 0;
    tail = n;
}
```

##### 说明

当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。

## Map

Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。

![](.\png\Java-Map.png)

### API方法

| 方法名                                 | 方法原型                                           | 方法描述                                                     |
| -------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| clear()                                | public void clear()                                | 从此映射中移除所有映射关系（可选操作）                       |
| containsKey(Object key)                | public boolean containsKey(Object key)             | 如果此映射包含指定键的映射关系，则返回true                   |
| containsValue(Object value)            | public boolean containsValue(Object value)         | 如果此映射将一个或多个键映射到指定值，则返回true             |
| entrySet()                             | public Set<Map.Entry<K,V>> entrySet()              | 返回此映射中包含的映射关系的Set视图                          |
| equals(Object o)                       | public boolean equals(Object o)                    | 比较指定的对象与此映射是否相等                               |
| get(Object key)                        | public V get(Object key)                           | 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回null |
| hashCode()                             | public int hashCode()                              | 返回此映射的哈希码值                                         |
| isEmpty()                              | public boolean isEmpty()                           | 如果此映射未包含键-值映射关系，则返回 true                   |
| keySet()                               | public Set<K> keySet()                             | 返回此映射中包含的键的 Set 视图                              |
| put(K key,V value)                     | public V put(K key,V value)                        | 将指定的值与映射中的指定键关联（可选操作）                   |
| putAll(Map<? extends K,? extends V> m) | public void putAll(Map<? extends K,? extends V> m) | 从指定映射中将所有映射关系复制到此映射中（可选操作）         |
| remove(Object key)                     | public V remove(Object key)                        | 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）   |
| size()                                 | public int size()                                  | 返回此映射中的键-值映射关系数                                |
| values()                               | public Collection<V> values()                      | 返回此映射中包含的值的 Collection 视图                       |

#### Entry

Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法：

| 方法              | 方法原型                        | 方法描述                                 |
| ----------------- | ------------------------------- | ---------------------------------------- |
| equals(Object o)  | public boolean equals(Object o) | 比较指定对象与此项的相等性               |
| getKey()          | public K getKey()               | 返回与此项对应的键                       |
| getValue()        | public V getValue()             | 返回与此项对应的值                       |
| hashCode()        | public int hashCode()           | 返回此映射项的哈希码值                   |
| setValue(V value) | public V setValue(V value)      | 用指定的值替换与此项对应的值（可选操作） |

### HashMap

HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。

#### 特点

- 迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。
- 线程不安全

#### HashMap 与 Hashtable 的区别

1. Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现，所以HashMap比Hashtable的性能好一些；但如果有多个线程访问同一个Map对象时，是盗用Hashtable实现类会更好。
2. Hashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发NullPointerException异常；但是HashMap可以使用null作为key或value。

#### 判断相等

##### key相等

两个key通过equals()方法比较返回true,两个key的hashCode值也相等，则认为两个key是相等的。

##### value相等

只要两个对象通过equals()方法比较返回true即可

##### 注意

- 作key的对象必须实现了hashCode()方法和equals()方法。
- HashMap中key所组成的集合元素不能重复，value所组成的集合元素可以重复。

#### 源码

```java
// 默认构造函数。
HashMap()

// 指定“容量大小”的构造函数
HashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数
HashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数
HashMap(Map<? extends K, ? extends V> map)
```

##### 容量大小

容量大小表示哈希表的初始容量。

##### 加载因子

哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了HashMap的阈值（**threshold：加载因子与当前容量的乘积**）时，则要对该哈希表进行 resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。

#### 结构

HashMap是通过"拉链法"实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor。

**table**是一个Node[]数组类型，而Node实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Node数组中的。

**size**是HashMap的大小，它是HashMap保存的键值对的数量。

**threshold**是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。

**loadFactor**就是加载因子。



哈希表具有较快（常量级）的查询速度，及相对较快的增刪速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我們可以理解为“链表的数组”。

![](.\png\java-HashMap-结构-拉链法.png)

哈希表是由数组+链表組成的，一个长度为16的数组中，每個元素存储的是一个链表的头结点。一般情況是通过hash(key)获得，也就是元素的key的哈希值。如果hash(key)值相等，则都存入该hash值所对应的链表中。它的內部其实是用一個Node数组來实现。

**所以每个数组元素代表一个链表，其中的共同点就是hash(key)相等。**

##### Node类型

```java
static class Node<K,V> implements Map.Entry<K,V>{
    final int hash;
    final K key;
    V value;
    //指向下一个节点
    Node<K,V> next;
    .....
}
```

#### 遍历

1. 遍历 HashMap 的键值对
   1. 根据entrySet()获取HashMap的“键值对”的Set集合
   2. 通过Iterator迭代器遍历“第一步”得到的集合
2. 遍历HashMap的键
   1. 根据keySet()获取HashMap的“键”的Set集合
   2. 通过Iterator迭代器遍历“第一步”得到的集合
3. 遍历HashMap的额值
   1. 根据value()获取HashMap的“值”的集合
   2. 通过Iterator迭代器遍历“第一步”得到的集合

#### 注意

- 如果是加入HashMap的key是个可变对象，在加入到集合后又修改key的成员变量的值，可能导致hashCode()值以及equal()的比较结果发生变化，无法访问到该key。一般情况下不要修改。
- 在设置容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 resize操作次数。如果容量大于最大条目数除以加载因子，则不会发生 rehash 操作。

### LinkedHashMap

#### 特点

- LinkedHashMap使用双向链表来维护key-value对的次序
- LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能
- 因为它以链表来维护内部顺序，所以在迭代访问**Map里的全部元素时有较好的性能**，迭代输出LinkedHashMap的元素时，将会按照添加key-value对的顺序输出

#### 结构

本质上来讲，LinkedHashMap = 散列表 + 循环双向链表

散列表存储数据，跟 HashMap 一模一样。

循环双向链表维护元素的插入顺序。

![](.\png\java-LinkedHashMap-结构.png)



LinkedHashMap 的 Entry

```java
private static class Entry<K,V> extends HashMap.Entry<K,V>{
    //These fields comprise the double linked list used for iteration
    Entry<K,V> before,,after;
    
    Entry(int hash, K key, V value, HashMap.Entry<K,V> next){
		super(hash, key, value, next);
	}
	....
}
```

#### 访问顺序

##### accessOrder

- true	内部元素按照访问顺序排序（最近访问点放到最后）
- false	内部元素按照插入顺序排序

```java
/**
*	@param	initialCapacity	初始容量
*	@param	loadFactor	装载因子
*	@param	accessOrder	如果为 true,则内部元素按照访问顺序排序；如果为false，则内部元素按照插入顺序排序
*/
public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder){
    super(initialCapacity,loadFactor);
    this.accessOrder = accessOrder;
}
```

##### LruCache缓存

最近最少使用算法。

在HashMap 中有三个空实现的函数，源码注释中也写明这三个函数是准备由 LinkedHashMap 来实现的

| 方法                              | 方法原型                                      | 方法描述   |
| --------------------------------- | --------------------------------------------- | ---------- |
| afterNodeAccess(Node<K,V> p)      | public void afterNodeAccess(Node<K,V> p)      | 节点访问后 |
| afterNodeInsertion(boolean evict) | public void afterNodeInsertion(boolean evict) | 节点插入后 |
| afterNodeRemoval(Node<K,V> p)     | public void afterNodeRemoval(Node<K,V> p)     | 节点移除后 |

```java
// Callbacks to allow LinkedHashMap post-actions
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
void afterNodeRemoval(Node<K,V> p) { }
```

如果在调用 `put(K key, V value)` 方法插入元素时覆盖了原有值，则`afterNodeAccess` 方法会被调用，该方法用于将最新访问的键值对移至链表的尾部，其在 LinkedHashMap 的实现如下所示

```java
//当访问了结点 e 时调用
//结点 e 是最新访问的一个结点，此处将结点 e 置为链表的尾结点
void afterNodeAccess(Node<K,V> e) {
    //last 用来指向链表的尾结点
    LinkedHashMap.Entry<K,V> last;
    //只有当上一次访问的结点不是结点 e 时（(last = tail) != e），才需要进行下一步操作
    if (accessOrder && (last = tail) != e) {
        //p 是最新访问的一个结点，b 是结点 p 的上一个结点，a 是结点 p 的下一个结点
        LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        //因为结点 p 将成为尾结点，所以 after 置为null
        p.after = null;
        //如果 b == null ，说明结点 p 是原链表的头结点，则此时将 head 指向下一个结点 a
        //如果 b != null ，则移除结点 b 对结点 p 的引用
        if (b == null)
            head = a;
        else
            b.after = a;
        //如果 a !=null，说明结点 p 不是原链表的尾结点，则移除结点 a 对结点 p 的引用
        //如果 a == null，则说明结点 p 是原链表的尾结点，则让 last 指向结点 b
        if (a != null)
            a.before = b;
        else
            last = b;
        //如果 last == null，说明原链表为空，则此时头结点就是结点 p
        //如果 last != null，则建立 last 和实际尾结点 p 之间的引用
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        //最新一个引用到的结点就是 tail
        tail = p;
        ++modCount;
    }
}
```

此外，当 put 方法调用结束时，`afterNodeInsertion` 方法会被调用，用于判断是否移除最近最少使用的元素，依此可以来构建 LRUcache 缓存

```java
//在插入元素后调用，此方法可用于 LRUcache 算法中移除最近最少使用的元素
void afterNodeInsertion(boolean evict) {
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

//如果在构造函数中参数 accessOrder 传入了 true ，则链表将按照访问顺序来排列
//即最新访问的结点将处于链表的尾部，依此可以来构建 LRUcache 缓存
//此方法就用于决定是否移除最旧的缓存，默认返回 false
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

### SparseArray

#### 使用

##### 创建

```java
SparseArray sparseArray = new SparseArray<>();
SparseArray sparseArray = new SparseArray<>(capacity);
```

`SparseArray`有两个构造方法，一个默认构造方法，一个传入容量。key为 int类型，value为传入的泛型。

##### put()

```java
sparseArray.put(int key,Student value);
```

##### get()

```
sparseArray.get(int key);
sparseArray.get(int key,Student valueIfNotFound);
```

##### remove()

```java
sparseArray.remove(int key);
```

##### index

底层是两条数组，一组存放`key`，一组存放`value`。`index` — `key`在数组中的位置。`SparseArray`提供了一些跟`index`相关的方法：

```java
sparseArray.indexOfKey(int key);
sparseArray.indexOfValue(T value);
sparseArray.keyAt(int index);
sparseArray.valueAt(int index);
sparseArray.setValueAt(int index);
sparseArray.removeAt(int index);
sparseArray.removeAt(int index,int size);
```

#### 实现原理

使用int[]数组存放key，避免了HashMap中基本数据类型需要装箱的步骤，其次不使用额外的结构体（Entry)，单个元素的存储成本下降。

##### 初始化

`SparseArray`没有继承任何其他的数据结构，实现了`Cloneable`接口。

```java
private int[] mKeys;
private Object[] mValues;
private int mSize;
public SparseArray() {this(10);}
public SparseArray(int initialCapacity) {
        if (initialCapacity == 0) {
            mKeys = EmptyArray.INT;
            mValues = EmptyArray.OBJECT;
        } else {
            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);
            mKeys = new int[mValues.length];
        mSize = 0;
```

初始化`SparseArray`只是简单的创建了两个数组。

##### put()

接下来就是往`SparseArray`中存放数据。

```java
public void put(int key, E value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
```

插入的逻辑大体上是这四点：

- 存放 key 的数组是有序的（二分查找的前提条件）
- 如果冲突，新值直接覆盖原值，并且不会返回原值（HashMap会返回原值）
- 如果当前要插入的 key 的索引上的值为DELETE，直接覆盖
- 前几步都失败了，检查是否需要gc()并且在该索引上插入数据

###### 冲突直接覆盖

![](.\png\java-SparseArray-put-冲突覆盖.png)

上面这个图，插入一个`key=3`的元素，因为在`mKeys`中已经存在了这个值，则直接覆盖。

###### 插入索引上为 DELETED

![](.\png\java-SparseArray-put-插入索引上为DELETED.png)

注意`mKeys`中并没有 3 这个值，但是通过二分查找得出来，目前应该插入的索引位置为 2 ，即`key=4`所在的位置，而当前这个位置上对应的`value`标记为`DELETED`了，所以会直接将该位置上的`key`赋值为 3 ，并且将该位置上的`value`赋值为`put()`传入的对象。

###### 索引上有值，但是应该触发 gc()

![](.\png\java-SparseArray-put-索引上有值触发gc.png)

注意这个图跟前面的几个又一个区别，那就是数组已经满容量了，而且 3 应该插入的位置已经有 4 了，而 5 所指向的值为`DELETED`，**这种情况下，会先去回收DELETED,重新调整数组结构，图中的例子则会回收 5 ,然后再重新计算 3 应该插入的位置**



**满容且无法 gc**

![](.\png\java-SparseArray-put-满容且无法gc.png)

这种情况下，就只能对数组进行扩容，然后插入数据。

`put()`还有几个值得我们探索的点，首先就是二分查找的算法，这是一个很普通的二分算法，注意最后一行代码，当找不到这个值的时候`return ~lo`，实际上到这一步的时候，理论上`lo==mid==hi`。所以这个位置是最适合插入数据的地方。但是为了让能让调用者既知道没有查到值，又知道索引位置，做了一个取反操作，返回一个负数。这样调用处可以首先通过正负来判断命中，之后又可以通过取反获取索引位置。

```java
static int binarySearch(int[] array, int size, int value) {
    int lo = 0;
    int hi = size - 1;
    while (lo <= hi) {
        final int mid = (lo + hi) >>> 1;
        final int midVal = array[mid];
        if (midVal < value) {
            lo = mid + 1;
        } else if (midVal > value) {
            hi = mid - 1;
        } else {
            return mid;  
    return ~lo; 
```

第二个点就是，插入数据具体是怎么插入的。

```java
mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
```

```java
public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize <= array.length;
    if (currentSize + 1 <= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
  	newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
```

##### remove()

```java
public void remove(int key) {
    delete(key);
    public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        if (mValues[i] != DELETED) {
            mValues[i] = DELETED;
            mGarbage = true;
            private static final Object DELETED = new Object();
```

事实上，`SparseArray`在进行`remove()`操作的时候分为两个步骤：

- 删除`value` — 在`remove()`中处理
- 删除`key` — 在`gc()`中处理，注意这里不是系统的 GC，只是`SparseArray` 的一个方法

`remove()`中，将这个`key`指向了`DELETED`，这时候`value`失去了引用，如果没有其它的引用，会在下一次系统内存回收的时候被干掉。来看一张图：

![](.\png\java-SparseArray-remove.png)

但是可以看到`key`仍然保存在数组中，并没有马上删除，目的应该是为了保持索引结构，同时不会频繁压缩数组，保证索引查询不会错位，那么`key`什么时候被删除呢？当`SparseArray`的`gc()`被调用时。

##### gc()

```java
private void gc() {
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;
    for (int i = 0; i < n; i++) {
        Object val = values[i];
        if (val != DELETED) {
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            o++;
    mGarbage = false;
    mSize = o;
```

这段代码，直接看可能理解起来也比较困难，主要是理解 `o` 只有在值等于`DELETED`的时候才不会向后移，也就是说，当`i`向后移动一位的时候，`o`还在值为`DELETED`的地方，而这时候因为`i != o`，就会触发第二个判断条件，将`i`位置的元素向前移动到`o`处。来看一张图：

![](.\png\java-SparseArray-gc.png)

如上图所示，在 3 之前，`i`与`o`都是相等的，而到 3 的时候，因为值为`DELETED`，所以只有`i++`，而`o`的值仍然等于 2，**重点来了，到 4 的时候，发现i!=o,则会将 4 向前移动到 3，这时候o++了，但是因为o始终小于i一位（这个例子里面），因此后面的元素均会向前移动一位。**

`gc()`的原理了解了，那么在什么情况下会触发`gc()`呢？上面已经知道在添加元素的时候可能会触发`gc()`，除了添加元素，前文提到过一系列跟`index`有关的方法，事实上在调用这些方法的时候，都会试图去触发`gc()`，这样可以返回给调用者一个精确的索引值。

##### get()

```java
public E get(int key, E valueIfKeyNotFound) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
```

`get()`中的代码就比较简单了，通过二分查找获取到`key`的索引，通过该索引来获取到`value`

#### SparseArray 的系列

- SparseIntArray	---- int:int
- SparseBooleanArray    ----int:boolean
- SparseLongArray   ----int:long 

#### 与Hashmap 的比较

##### 优势

- 避免了基本数据类型的装箱操作
- 不需要额外的结构体，单个元素的存储成本更低
- 数据量小的情况下，随机访问的效率更高

##### 缺点

- 插入操作需要复制数组，增删效率降低
- 数据量巨大时，复制数组成本巨大，`gc()`成本也巨大
- 数据量巨大时，查询效率也会明显下降



### TreeMap

TreeMap是SortedMap接口的实现类。TreeMap 是一个**有序的key-value集合**，它是通过红黑树实现的，每个key-value对即作为红黑树的一个节点。

#### 特点

- 有序的key-value集合

#### 排序方式

##### 自然排序

TreeMap的所有key必须实现Comparable接口，而且所有的key应该是同一个类的对象，否则会抛出ClassCastException异常

##### 定制排序

创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。

#### 判断相等

##### key

TreeMap中判断两个key相等的标准是：两个key通过compareTo()方法返回0，TreeMap即认为这两个key是相等的。

##### value

TreeMap中判断两个value相等的标准是：两个value通过equals()方法比较返回true。

##### 注意

如果使用自定义类作为TreeMap的key，且想让TreeMap良好地工作，则重写该类的equals()方法和compareTo()方法时应保持一致的返回结果：两个key通过equals()方法比较返回true时，它们通过compareTo()方法比较应该返回0。如果两个方法的返回结果不一致，TreeMap与Map接口的规则就会冲突。

#### 原理

红黑树（详见数据结构--红黑树）

#### 遍历方法

- 遍历TreeMap的键值对
  1. 根据entrySet()获取TreeMap的“键值对”的Set集合
  2. 通过Iterator迭代器遍历“第一步”得到的集合
- 遍历TreeMap的键
  1. 根据keySet()获取TreeMap的“键”的Set集合
  2. 通过Iterator迭代器遍历“第一步”得到的集合
- 遍历TreeMap的值
  1. 根据value()获取TreeMap的“值”的集合
  2. 通过Iterator迭代器遍历“第一步”得到的集合

### 使用场景

- 一般的应用场景，尽可能多考虑使用HashMap，因为其为快速查询设计的
- 需要特定的排序时，考虑使用TreeMap
- 仅仅需要插入的顺序时，考虑使用LinkedHashMap

### key-value

Java 世界里实现 key-value 的数据结构：

- Hash

  插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。

- TreeMap

  插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。

- SkipList

  SkipList有着不低于红黑树的效率，但是其原理和实现的复杂度要比红黑树简单多了



### SkipList

Skip List ，称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照key值升序，天然有序。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。

![](E:/lzl/study/java/doc/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/png/java-skipList.png)

#### 特性

1. 由很多层结构组成，level是通过一定的概率随机产生的。
2. 每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法。
3. 最底层(Level 1)的链表包含所有元素。
4. 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。
5. 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

#### 查找

![](E:/lzl/study/java/doc/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/png/java-skipList-insert.png)

#### 删除

![](E:/lzl/study/java/doc/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/png/java-SkipList-delete.png)

