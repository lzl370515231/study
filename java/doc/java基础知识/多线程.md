# JVM内存结构

![](.\png\java内存区域结构.png)

其中Java堆（实例域，静态域和数组元素）和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。

JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。

局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

# Java 内存模型

Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。**JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的**。

Java的多线程之间是通过**共享内存**进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。

![](.\png\java内存模型.png)

## 概念

**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

## 原因

### 多线程缓存一致性

由于CPU和主存之间存在高速缓存，所以在多线程场景下会存在**缓存一致性问题**。

![](.\png\computer_内存架构.png)

在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。

当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。


一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。

### 处理器优化和指令重排

为了使处理器内部的运算单元能够尽量的被充分利用，**处理器**可能会对输入代码进行乱序执行处理。这就是**处理器优化**。

除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的**编译器**也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。

由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。**内存系统会重排序**

![](.\png\java_并发_重排序.png)

对于编译器，JMM 的**编译器重排**序规则会**禁止**特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于**处理器重排序**，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的**内存屏障**（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

### 顺序一致性

和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：

1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。
3. JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。

### 并发编程问题汇总

原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。

#### 原子性（处理器优化）

指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。

#### 可见性（缓存一致性）

指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

#### 有序性（指令重排）

程序执行的顺序按照代码的先后顺序执行。

## 支撑Java内存模型的基础原理

### 指令重排序

#### 重排序原则

##### 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

###### 注意

这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

##### as-if-serial语义

不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

### happens-before

JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。与程序员密切相关的 happens-before规则如下：

- 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。

- 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。

- volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。

- 线程上调用start()方法*happens* *before*这个线程启动后的任何操作。

- join()原则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

- 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

- 程序中断规则：对线程Interrupted() 方法的调用先行于被中断线程的代码检测到中断时间的发生。

- 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。 （finalize() 方法是垃圾回收器回收时会调用的一个方法，方法原型为：）

  ```java
  protected void finalize(){
  	
  }
  ```

#### 注意

两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。

一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。

#### happens-before与JMM的关系如下图所示

![](.\png\happens-before与JMM关系.png)

### 使用内存屏障

内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：

1. 保证特定操作的执行顺序

   插入一条Memory Barrier会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序

2. 影响某些数据（或则是某条指令的执行结果）的内存可见性

   Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个`Write-Barrier`（写入屏障）将刷出所有在Barrier之前写入 cache 的数据。

#### 内存屏障指令分类

|      屏障类型       |          指令示例          | 说明                                                         |
| :-----------------: | :------------------------: | :----------------------------------------------------------- |
|  LoadLoad Barriers  |   Load1; LoadLoad; Load2   | 确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。 |
| StoreStore Barriers | Store1; StoreStore; Store2 | 确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。 |
| LoadStore Barriers  |  Load1; LoadStore; Store2  | 确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。 |
| StoreLoad Barriers  |  Store1; StoreLoad; Load2  | 确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。 |

StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。

## 原型

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的**工作内存**和**主存**之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。

## java内存模型的实现

在Java中提供了一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`、`concurren`包等。

### 原子性

在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。这两个字节码，在Java中对应的关键字就是**`synchronized`**。

### 可见性

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

Java中的**`volatile`**关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。

### 有序性

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。`synchronized`关键字保证同一时刻只允许一条线程操作。

## 缓存一致性（可见性）

### 处理缓存一致性方式

1. 通过在总线加 lock 锁的方式
2. 通过缓存一致性协议

### 缓存一致性协议

缓存一致性协议（Cache Coherence Protocol），解决多个缓存副本之间的数据的一致性问题。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。**（可见性）**

#### MESI的核心的思想

当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

#### 状态

在MESI协议中，每个缓存可能有4个状态，分别是：

**M(Modified)**：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。

**E(Exclusive)**：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。

**S(Shared)**：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。

**I(Invalid)**：这行数据无效。

MESI是一种比较常用的缓存一致性协议，他可以用来解决缓存之间的数据一致性问题。值得注意的是，传统的MESI协议中有两个行为的执行成本比较大。

- 将某个Cache Line标记为Invalid状态
- 当某Cache Line当前状态为Invalid时写入新的数据。

所以CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时。如图：

![](.\png\MESI协议-缓存一致性.png)

当一个CPU进行写入时，首先会给其它CPU发送Invalid消息，然后把当前写入的数据写入到Store Buffer中。然后异步在**某个时刻**真正的写入到Cache中。

当前CPU核如果要读Cache中的数据，需要先扫描Store Buffer之后再读取Cache。

但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache之后才会触发失效操作。

而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后**异步**将其设为Invalid状态。

和Store Buffer不同的是，当前CPU核心使用Cache时并不扫描Invalidate Queue部分，所以可能会**有极短时间的脏读问题**。

所以，为了解决缓存的一致性问题，比较典型的方案是MESI缓存一致性协议。

#### 说明

MESI协议，可以保证缓存的一致性，但是无法保证实时性。

## 示例

### volatile

见 并发编程-关键字-volatile

### 锁

见 并发编程-java锁 内存语义

### final

**对于final域，编译器和处理器要遵守两个重排序规则**：

1. 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

下面通过一些示例代码来分别说明这两个规则：

```java
public class FinalExample{
    int i;		//普通变量
    final int j;
    static FinalExample obj;	//final变量
    
    public FinalExample(){		//构造函数
        i = 1;				//写普通域
        j = 2;				//写final域
    }
    
    public static void writer(){	//写线程A执行
        obj = new FinalExample();
    }
    
    public static void reader(){	//读线程B执行
        FinalExample object = obj;	//读对象引用
        int a = object.i;		//读普通域
        int b = object.j;		//读final域
    }
}
```

这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。下面我们通过这两个线程的交互来说明这两个规则。

#### 写final域的重排序规则

写final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：

- JMM 禁止编译器把 final 域的写重排序到构造函数之外。
- 编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。

writer () 方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：

1. 构造一个 FinalExample 类型的对象；
2. 把这个对象的引用赋值给引用变量 obj。

假设线程 B **读**对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：

![](.\png\java-final-写的重排规则.png)

在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B **错误的读取**了**普通变量 i** 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B **正确的读取**了 **final 变量**初始化之后的值。

写 final 域的重排序规则可以确保：**在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。**以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 1 还没有写入普通域 i）。

#### 读final域的重排序规则

读final 域的重排序规则如下：

在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作(注意，这个规则仅仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障。

初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在**间接依赖关系**。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。

reader()方法包含三个操作：

1. 初次读引用变量obj
2. 初次读引用变量obj指向对象的普通域 j
3. 初次读引用变量obj指向对象的final 域 i

在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。

#### final域是引用类型

```java
public class FinalReferenceExample{
    final int[] intArray;		//final是引用类型
    static FinalReferenceExample obj;
    
    public FinalReferenceExample(){	//构造函数
        intArray = new int[1];		//1
        intArray[0] = 1;			//2
    }
    
    public static void writerOne(){			//写线程 A 执行
        obj = new FinalReferenceExample();	//3
    }
    
    public static void writerTwo(){	//写线程 B 执行
        obj.intArray[0] = 2;		//4
    }
    
    public static void reader(){		//读线程 C 执行
        if(obj != null){		//5
            int temp1 = obj.intArray[0];	//6
        }
    }
}
```

##### 写final域的重排序规则

写final域的重排序规则对编译器和处理器增加了如下约束：

1. 在构造函数内对一个final引用的对象的**成员域**的写入，与随后在构造函数外把这个被**构造对象的引用**赋值给一个引用变量，这两个操作之间不能重排序。

假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。下面是一种可能的线程执行时序：

![](.\png\java-final-引用类型-多线程并发-执行程序.png)

在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。

JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。

如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。

#### final引用不能从构造函数内"逸出"

写 final 域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，**不能让这个被构造对象的引用为其他线程可见**，也就是对象引用不能在构造函数中“逸出”。

```java
public class FinalReferenceEscapeExample{
    final int i;
    static FinalReferenceEscapeExample obj;
    
    public FinalReferenceEscapeExample(){
        i = 1;		//1 写final域
        obj = this;	//2 this 引用在此“逸出”
    }
    
    public static void writer(){
        new FinalReferenceEscapeExample();
    }
    
    public static void reader(){
        if(obj != null){		//3
            int temp = obj.i;	//4
        }
    }
}
```

假设一个线程 A 执行 writer() 方法，另一个线程 B 执行 reader() 方法。**这里的操作 2 使得对象还未完成构造前就为线程 B 可见**。即使这里的操作 2 是构造函数的最后一步，且即使在程序中操作 2 排在操作 1 后面，执行 read() 方法的线程仍然可能无法看到 final 域被初始化后的值，因为这里的操作 1 和操作 2 之间可能被重排序。实际的执行时序可能如下图所示：

![](.\png\java-final引用从构造函数逸出.png)

在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到 final 域正确初始化之后的值。

#### final语义在处理器中的实现

写 final 域的重排序规则会要求译编器在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 障屏。读 final 域的重排序规则要求编译器在读 final 域的操作前面插入一个 LoadLoad 屏障。

由于 x86 处理器不会对写 - 写操作做重排序，所以在 x86 处理器中，写 final 域需要的 StoreStore 障屏会被省略掉。同样，由于 x86 处理器不会对存在间接依赖关系的操作做重排序，所以在 x86 处理器中，读 final 域需要的 LoadLoad 屏障也会被省略掉。也就是说在 x86 处理器中，final 域的读 / 写不会插入任何内存屏障！

#### JSR-133为什么要增强final的语义

在旧的 Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为 0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了 1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变。

为了修补这个漏洞，JSR-133 专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：**只要对象是正确构造**的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。

## 总结

### JMM重排序策略

JMM把happens-before 要求禁止的重排序分为了下面两类：

- 会改变程序执行结果的重排序
- 不会改变程序执行结果的重排序

JMM对这两种不同性质的重排序，采取了不同的策略：

- 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序
- 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求(JMM允许这种重排序)

下面是JMM的设计示意图：

![](.\png\JMM设计示意图.png)

### JMM可见性保证

Java 程序的内存可见性保证按程序类型可以分为下列三类：

1. 单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
2. 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
3. 未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。

下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：

![](.\png\JMM与顺序一致性内存模型中的执行结果异同.png)

只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。

# JAVA 对象模型

关于Java对象自身的存储模型称之为Java对象模型。在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下：

![](.\png\java-对象模型区域分布图.png)

- 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐
- 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个`instanceKlass`，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，这个对象中包含了对象头以及实例数据。

![](.\png\java对象模型.jpeg)

## 总结

JVM内存结构，和Java虚拟机的**运行时区域**有关。 

Java内存模型，和Java的**并发编程**有关。

 Java对象模型，和Java对象在虚拟机中的**表现形式**有关。

# 并发编程

## 线程之间的通信和同步

### 通信

- 共享内存	通过写-读内存中的公共状态来隐式进行通信。（共享对象）
- 消息传递    线程之间通过明确的发送消息来显式进行通信。（典型wait() 和 notify()）

### 同步

用于控制不同线程之间操作发生相对顺序的机制。

- 共享内存	同步是显式进行的
- 消息传递    隐式进行

## Java锁

### 锁的内存语义

- 锁可以让临界区互斥执行，还可以让释放锁的线程向同一个锁的线程发送消息
- 锁的释放要遵循Happens-before原则（`锁规则：解锁必然发生在随后的加锁之前`）
- 锁在Java中的具体表现是 `Synchronized` 和 `Lock`

#### 锁的释放的内存语义

线程A释放锁后，会将共享变更操作刷新到主内存中。

![](.\png\java_lock_release.jpg)

#### 锁的获取的内存语义

线程B获取锁时，JMM会将该线程的本地内存置为无效，被监视器保护的临界区必须从主内存中读取共享变量

![](.\png\java_lock_acquire.jpg)

#### 锁的释放与获取过程

- 锁获取与 volatile 读有相同的内存语义，可见**关键字 volatile**
- 线程A释放一个锁，实质是线程A告知下一个获取到该锁的某个线程其已变更该共享变量
- 线程B获取一个锁，实质是线程B得到了线程A告知其(在释放锁之前)变更共享变量的消息
- 线程A释放锁，随后线程B竞争到该锁，实质是线程A通过主内存向线程B发消息告知其变更了共享变量

#### 锁释放-获取示例代码

```java
class MonitorExample{
    int a = 0;
    
    public synchronized void writer(){//1
        a++;	//2
    }			//3
    
    public synchronized void reader(){//4
        int i = a;		//5
        ...		
    }					//6
}
```

假设线程 A 执行 writer() 方法，随后线程 B 执行 reader() 方法。根据 happens before 规则，这个过程包含的 happens before 关系可以分为两类：

1. 根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。
2. 根据监视器锁规则，3 happens before 4。
3. 根据 happens before 的传递性，2 happens before 5。

上述 happens before 关系的图形化表现形式如下：

![](.\png\java-锁-happens_before图形化表示.png)

在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。

黑色箭头表示程序顺序规则；

橙色箭头表示监视器锁规则；

蓝色箭头表示组合这些规则后提供的 happens before 保证。

### 锁内存语义的实现

借助 ReentrantLock 的源代码，来分析锁内存语义的具体实现机制。

#### 示例代码

```java
class ReentrantLockExample{
    int a  =0;
    
    ReentrantLock lock = new ReentrantLock();
    
    public void writer(){
        lock.lock();	//获取锁
        try{
            a++;
        }finally{
            lock.unlock();	//释放锁
        }
    }
    
    public void reader(){
        lock.lock();	//获取锁
        try{
            int i = a;
            ...
        }finally{
            lock.unlock();	//释放锁
        }
    }
}
```

在 ReentrantLock 中，调用 lock() 方法获取锁；调用 unlock() 方法释放锁。

ReentrantLock 的实现依赖于 java 同步器框架 AbstractQueuedSynchronizer（本文简称之为 AQS）。AQS 使用一个整型的 volatile 变量（命名为 state）来维护同步状态，马上我们会看到，这个 volatile 变量是 ReentrantLock 内存语义实现的关键。 下面是 ReentrantLock 的类图（仅画出与本文相关的部分）：

![](.\png\java-锁-ReentrantLock类图.png)

ReentrantLock 分为公平锁和非公平锁，我们首先分析公平锁。

使用公平锁时，加锁方法 lock() 的方法调用轨迹如下：

1. ReentrantLock：lock()
2. FairSync：lock()
3. AbstractQueuedSynchronizer：acquire(int arg)
4. ReentrantLock：tryAcquire(int acquires)

在第 4 步真正开始加锁，下面是该方法的源代码：

```java
protected final boolean tryAcquire(int acquires){
    final Thread current = Thread.currentThread();
    int c = getState();	//获取锁的开始，首先读volatile变量 state
    if(c == 0){
        if (isFirst(current) &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if(current == getExclusiveOwnerThread()){
        int nextc = c + acquires;
        if (nextc < 0)  
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

从上面源代码中我们可以看出，加锁方法首先读 volatile 变量 state。

##### compareAndSetState

```java
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

该方法以原子操作的方式更新 state 变量，本文把 java 的 compareAndSet() 方法调用简称为 **CAS**。

编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现 volatile 读和 volatile 写的内存语义，编译器不能对 CAS 与 CAS 前面和后面的任意内存操作重排序。



在使用公平锁时，解锁方法unlock() 方法调用轨迹如下：

1. ReentrantLock : unlock()
2. AbstractQueuedSynchronizer : release(int arg)
3. Sync : tryRelease(int releases)

在第 3 步真正开始释放锁，下面是该方法的源代码：

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);           // 释放锁的最后，写 volatile 变量 state
    return free;
}
```

从上面的源代码我们可以看出，在释放锁的最后写 volatile 变量 state。

公平锁在释放锁的最后写 volatile 变量 state；在获取锁时首先读这个 volatile 变量。根据 volatile 的 happens-before 规则，释放锁的线程在写 volatile 变量之前可见的共享变量，在获取锁的线程读取同一个 volatile 变量后将立即变的对获取锁的线程可见。

##### 公平锁与非公平锁的内存语义总结

- 公平锁和非公平锁释放时，最后都要写一个volatile变量 state。
- 公平锁获取时，首先会去读这个volatile变量
- 非公平锁获取时，首先会用CAS更新这个volatile变量，这个操作同时具有volatile读和volatile写的内存语义

### 锁对象、类锁、私有锁

#### 对象锁

使用 synchronized 修饰**非静态**的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。

#### 类锁 

使用 synchronized 修饰**静态**的方法以及 synchronized(**class**) 同步代码块使用的锁是类锁

#### 私有锁

在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）

特殊的instance变量

```java
private byte[] lock = new byte[0];	//特殊的instance变量
public void method(){
    synchronized(lock){
        //TODO 同步代码块
    }
}
```

##### 说明

零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。

#### 特性

- 对象锁具有可重入性
- 当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块
- 当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。
- 每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁
- 类锁和对象锁不会产生竞争。
- 私有锁和对象锁也不会产生竞争。
- 使用私有锁可以减小锁的细粒度，减少由锁产生的开销。

由私有锁实现的等待/通知机制：

```java
Object lock = new Object();
//由等待方线程实现
synchronized(lock){
    while(条件不满足){
        lock.wait();
    }
}

//由通知方线程实现
synchronized(lock){
    //条件发生改变
    lock.notify();
}
```

### 死锁

#### 概念

死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求**同一组锁**的时候。

#### 常见情形

- 线程A永远不释放锁，结果B一直拿不到锁，所以线程B就“死掉”了
- 线程A拥有线程B需要的锁Y，同时线程B拥有线程A需要的锁X，那么这时候线程A/B互相依赖对方释放锁，于是二者都“死掉”了

#### 饥饿死锁

非公平锁中，如果某些线程非常活跃，在高并发情况下这类线程可能总是拿到锁，那么那些活跃度低的线程可能就一直拿不到锁，这样就发生了“饥饿死”。

#### 避免死锁

##### 加锁顺序

如果一个线程（比如线程 3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。

```java
Thread 1:
	lock A 
	lock B

Thread 2:
	wait for A
	lock C (when A locked)

Thread 3:
	wait for A
	wait for B
	wait for C
```

按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。

##### tryLock

高级锁里面总是使用 tryLock 。

##### 加锁时限

在尝试**获取锁的时候加一个超时时间**，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。

##### 死锁检测

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

###### 原理

每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。

### 锁分类（概念）

![](.\png\java_lock.png)

#### 乐观锁 VS 悲观锁

##### 悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

##### 乐观锁

乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

乐观锁在Java中是通过使用无锁编程来实现，最常采用的是**CAS算法**，Java原子类中的递增操作就通过CAS自旋实现的。

jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。

##### CAS算法（比较与交换）

CAS是一种无锁算法，CAS有3个操作数，**内存值V，旧的预期值A，要修改的新值B**。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。

![](.\png\java_lock_悲观和乐观.png)

###### 特性

- 通过调用JNI的代码实现
- 非阻塞算法
- 非独占锁

###### 乐观锁CAS缺点

- ABA问题。

  CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。

  - JDK从1.5开始提供了**AtomicStampedReference**类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。

- 循环时间长开销大。

  CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

- 只能保证一个共享变量的原子操作。

  对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。

  - Java从1.5开始JDK提供了**AtomicReference**类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

###### 使用场景

- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

###### 示例

```java
// ------------------------- 悲观锁的调用方式 -------------------------
// synchronized
public synchronized void testMethod() {
	// 操作同步资源
}
// ReentrantLock
private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
public void modifyPublicResources() {
	lock.lock();
	// 操作同步资源
	lock.unlock();
}

// ------------------------- 乐观锁的调用方式 -------------------------
private AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger
atomicInteger.incrementAndGet(); //执行自增1
```

java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：

```java
public class AtomicInteger extends Number implements java.io.Serializable{
	private static final long serialVersionUID = 6214790243416807050L;
	
	//setup to use Unsafe.compareAndSwapInt for updates
	private static final Unsafe unsafe = Unsafe.getUnsafe();
	private static final long valueOffset;
    
    static{
        try{
            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));
        }catch(Exception e){
            throw new Error(ex);
        }
    }
    private volatile int value;
}
```

unsafe：获取并操作内存的数据

valueOffset：存储value在AtomicInteger中的偏移量

value：存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。

```java
// ------------------------- JDK 8 -------------------------
// AtomicInteger 自增方法
public final int incrementAndGet() {
  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// Unsafe.class
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
      var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
  return var5;
}

// ------------------------- OpenJDK 8 -------------------------
// Unsafe.java
public final int getAndAddInt(Object o, long offset, int delta) {
   int v;
   do {
       v = getIntVolatile(o, offset);
   } while (!compareAndSwapInt(o, offset, v, v + delta));
   return v;
}
```

getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。

###### 总结

乐观锁的使用：通过CAS算法保证数据的同步性或者 CAS算法+版本号来保证数据的同步性。

#### 自旋锁 VS 适应性自旋锁

##### 自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

![](.\png\java_自旋锁.png)

自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

**自旋锁的实现原理同样也是CAS**，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。

```java
public final int getAndAddInt(Object var1,long var2,int var4){
    int var5;
    do{
        var5 =  this.getIntVolatile(var1,var2);
    }while(!this.compareAndSwapInt(var1,var2,var5,var5+var4));
    return var5;
}
```

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

##### 适应性自旋锁

自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

在自旋锁中另有三种常见的锁形式：TicketLock、CLHlock 和MCSlock。

#### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

| 锁状态   | 存储内容                                                | 存储内容 |
| -------- | ------------------------------------------------------- | -------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |

##### 无锁(CAS)

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

##### 偏向锁

偏向锁是指**一段同步代码一直被一个线程所访问**，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁**只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁**，线程不会主动释放偏向锁。偏向锁的撤销，**需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。**如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word**要么**重新偏向于其他线程，**要么**恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

![](.\png\java-偏向锁-撤销流程.png)

偏向锁的获取与撤销

![](.\png\java-偏向锁的获取与释放.png)

###### 关闭偏向锁

偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

##### 轻量级锁

是指当锁是偏向锁的时候，被另外的线程所访问，**偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能**。

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

![](.\png\java-轻量锁膨胀为重量锁.png)

##### 重量锁

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。



综上，偏向锁通过**对比Mark Word**解决加锁问题，避免执行CAS操作。而轻量级锁是通过用**CAS操作和自旋**来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

##### 总结

| 锁       | 优点                                                         | 缺点                                           | 适用场景                             |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程时间存在竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景     |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间<br>同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量<br>同步块执行速度较长     |



#### 公平锁 VS 非公平锁

##### 公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，**线程直接进入队列中排队，队列中的第一个线程才能获得锁**。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

##### 非公平锁

非公平锁是**多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待**。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

通过ReentrantLock的源码来讲解公平锁和非公平锁

```java
public class ReentrantLock implements Lock,java.io.Serializable{
    private static final long serialVersion = 7373984872572414699L;
    private final Sync sync;
    
    abstarct static class Sync extends AbstractQueuedSynchronizer{...}
    
    static final class NonfairSync extends Sync{...}
    
    static final class FairSync extends Sync{...}
    
    public ReentrantLock(){ sync = new  NonfairSync();}
    
    public ReentrantLock(boolean fair){sync = fair ? new FairSync():new NonfairSync();}
}
```

根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。

##### 公平锁代码

```java
protected final boolean tryAcquire(int acquires){
    final Thread current = Thread.currentThread();
    int c = getState();
    if(c == 0){
        if(!hasQueuePrecessors() && compareAndSetState(0,acquires)){
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if(current == getExclusiveOwnerThread()){
        int nextc = c+ acquires;
        if(next < 0){
            throw new Error("Maxium lock count exceeded");
        }
        setState(nextc);
        return true;
    }
    return false;
}
```

##### 非公平锁代码

```java
final boolean nonfairTryAcquire(int acquires){
    final Thread current = Thread.currentThread();
    int c = getState();
    if(c == 0){
        if(compareAndSetState(0,acquires)){
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if(current == getExclusiveOwnerThread()){
        int nextc = c +acquires;
        if(nextc<0){
            throw new Error("Maxium lock count exceeded");
        }
        setState(nextc);
        return true;
    }
    return false;
}
```

##### 同步与非同步的差别

```java
public final boolean hasQueuedPredecessors(){
    //...
    Node t = tail;
    Node h = head;
    Node s;
    return h != t && ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

该方法主要判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。

#### 可重入锁 VS 非可重入锁

##### 可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中**ReentrantLock和synchronized都是可重入锁**，可重入锁的一个优点是可一定程度避免死锁。

```java
public class Widget{
    public synchronized void doSomething(){
        System.out.println("方法1执行....");
        doOthers();
    }
    public synchronized void doOthers(){
        System.out.println("方法2执行...");
    }
}
```

因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。

##### 非可重入锁

NonReentrantLock为非可重入锁。

通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。

首先ReentrantLock和NonReentrantLock都继承父类**AQS**，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

##### 非可重入锁死锁的原因

###### 获取锁

当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

###### 释放锁

释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

##### 可重入锁代码

```java
final boolean nonfairTryAcquire(int acquires){
    final Thread current = Thread.currentThread();
    int c = getState();
    if(c == 0){
        if(compareAndSetState(0,acquires)){
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if(current == getExclusiveOwnerThread()){
        int nextc = c+acquires;
        if(nextc <0){
            throw new Error("Maxium lock count exceeded");
        }
        setState(nextc);
        return true;
    }
    return false;
}
//获取锁时先判断，如果当前线程就是已经占有锁的线程，则status值+1，并返回true。

protected final boolean tryRelease(){
    int c =  getState() - release;
    if(Thread.currentThread() != getExclusiveOwnerThread()){
        throw new IllegalMonitorStateException();
    }
    boolean free = false;
    if(c == 0){
        free = false;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
//释放锁时也是先判断当前线程是否已占有锁的线程，然后再判断status，如果status等于0，才真正的释放锁
```

##### 非可重入锁代码

```java
protected boolean tryAcquire(int acquires){
    if(this.compareAndSetState(0,1)){
        this.owner = Thread.currentThread();
        return true;
    }else {
        return false;
    }
}
//非重入锁是直接尝试获取锁

protected boolean tryRelease(int releases){
    if(Thread.currentThread() != this.owner){
        throw new IllegalMonitorStateException();
    }else{
        this.owner = null;
        this.setState(0);
        return true;
    }
}
//释放锁时直接将status 置为0
```

#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

`ConcurrentHashMap`中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。

当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

#### 独享锁 VS 共享锁

##### 独享锁

独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC（java.utils.current）中Lock的实现类就是互斥锁。

##### 共享锁

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。**ReentrantReadWriteLock**

##### 实现

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

###### ReentrantReadWriteLock的部分源码：

```java
public class ReentrantReadWriteLock implements ReadWriteLock,java.io.Serializable{
    private static final long serialVersionUID = -5992448646407608164L;
    
    private final ReentrantReadWriteLock.ReadLock readerLock;
    
    private final ReentrantWriteLock.WriteLock writeLock;
    
    final Sync sync;
    
    public ReentrantReadWriteLock(this(false));
    
    public ReentrantReadWriteLock(boolean fair){
        sync= fair ? new FairSync() : new NonFairSync();
        readLock = new ReadLock(this);
        writeLock = new WriteLock(this);
    }
    public ReentrantReadWriteLock.WriteLock writeLock(){
        return writeLock;
    }
    public ReentrantReadWriteLock.ReadLock readLock(){
        return readLock;
    }
}
```

###### 读锁

读锁为一个可重入的共享锁，能够被多个线程同时持有，在没有其他写线程访问时，读锁总是获取成功。

###### ReadLock

```java
public static class ReadLock implements Lock,java.io.Serializable{
    private static final long serialVersionUID = -5992648646407699164L;
    private final Sync sync;
    
    protected ReadLock(ReentrantReadWriteLock lock){
        sync = lock.sync;
    }
}
```

###### 读锁的获取

```java
public void lock(){
	sync.acquireShared(1);
}
```

```java
public final void acquireShared(int arg){
	if(tryAcquireShared(arg)<0){
		doAcquireShared(arg);
	}
}
```

###### 读锁的释放

```java
public void unlock(){
	sync.releaseShared(1);
}
```

```java
public final boolean releaseShared(int arg) {
	if (tryReleaseShared(arg)) {
		doReleaseShared();
		return true;
	}
	return false;
}
```

###### 写锁

写锁就是一个支持可重入的排他锁。

###### WriteLock

```java
public static class WriteLock implements Lock,java.io.Serializable{
    private static final long serialVersionUID = -4992448646487698164L;
    private final Sync sync;
    
    protected WriteLock(ReentrantReadWriteLock lock){
        sync = lock.sync;
    }
}
```

###### 写锁的获取

写锁的获取最终会调用tryAcquire(int arg)，该方法在内部类Sync中实现。（见写锁的加锁源码）

###### 写锁的释放

获取了写锁用完了则需要释放，WriteLock提供了unlock()方法释放写锁：

```java
public void unlock(){
    sync.release(1);
}
public final boolean release(int arg){
    if(tryRelease(arg)){
        Node h = head;
        if(h!=null && h.waitStatus !== 0){
            unparkSuccessor(h);
        }
        return true;
    }
    return false;
}
```

可以看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。

在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。

在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图：

![](.\png\java_sync_state_共享锁.png)

###### 读写锁的主要特性

1. 公平性：支持公平性和非公平性
2. 重入性：支持重入。读写锁最多支持 65535 个递归写入锁和 65535 个递归读取锁。
3. 锁降级：遵循**获取写锁、获取读锁再释放写锁**的次序，写锁能够降级成为读锁。（占有写锁的线程可以获取读锁）

###### 写锁的加锁源码

```java
protected final boolean tryAcquire(int acquires){
    Thread current = Thread.currentThread();
    int c = getState();	//获取当前锁的个数
    int w = exclusiveCount(c);	//获取写锁的个数
    if(c != 0){//如果已经有线程持有了锁 (c!=0)
// (Note: if c != 0 and w == 0 then shared count != 0)
		if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败
			return false;
		if (w + exclusiveCount(acquires) > MAX_COUNT)    // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。
			throw new Error("Maximum lock count exceeded");
		// Reentrant acquire
		setState(c + acquires);
		return true;
	}
	if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) 
	// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。
		return false;
	setExclusiveOwnerThread(current); 
    // 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者
	return true;
}
```

- 首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。
- 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。
- 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error
- 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败
- 如果c=0,w=0或者c>0,w>0（重入），则设置当前线程或锁的拥有者，返回成功

只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。

###### 读锁的代码

```java
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;                                   
    // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态
    int r = sharedCount(c);
    if (!readerShouldBlock() &&
        r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```

在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1<<16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。

###### HoldCounter

与线程有关的状态计数器。

### Lock

#### 方法

| 方法              | 方法原型                                                     | 方法描述                                                     | 备注                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| lock              | void lock()                                                  | 获取锁                                                       | 如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。 |
| lockInterruptibly | void lockInterruptibly() throws InterruptedException         | 如果当前线程未被中断，则获取锁。如果锁可用，则获取锁，并立即返回。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况（见下文）之一以前，该线程将一直处于休眠状态 |                                                              |
| newCondition      | Condition newCondition()                                     | 返回绑定到此 `Lock` 实例的新 `Condition` 实例。              |                                                              |
| tryLock           | boolean tryLock()                                            | 仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 `true`。如果锁不可用，则此方法将立即返回值 `false`。 |                                                              |
| tryLock           | boolean tryLock(long time, TimeUnit unit) throws InterruptedException | 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。如果锁可用，则此方法将立即返回值 `true`。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况（见下文）之一前，该线程将一直处于休眠状态 |                                                              |
| unlock            | void unlock()                                                | 释放锁。对应于lock()、tryLock()、tryLock(xx)、lockInterruptibly()等操作，如果成功的话应该对应着一个unlock()，这样可以避免死锁或者资源浪费。 |                                                              |

##### lockInterruptibly

如果当前线程未被中断，则获取锁。

如果锁可用，则获取锁，并立即返回。

如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态：

- 锁由当前线程获得；或者
- 其他某个线程中断当前线程，并且支持对锁获取的中断

如果当前线程：

- 在进入此方法时已经设置了该线程的中断状态
- 在获取锁时被中断，并且支持对锁获取的中断

则将抛出 InterruptedException，并清除当前线程的已中断状态。

##### tryLock

boolean tryLock(long time,TimeUnit unit) throws InterruptedException

如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。

如果锁可用，则此方法将立即返回值 `true`。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：

- 锁由当前线程获得
- 其他某个线程中断当前线程，并且支持对锁获取的中断
- 已超过指定的等待时间

如果获得了锁，则返回 true。

如果当前线程：

- 在进入此方法时已经设置了该线程的中断状态
- 在获取锁时被中断，并且支持对锁获取的中断

则将抛出 InterruptedException，并会清除当前线程的已中断状态

如果超过了指定的等待时间，则将返回值 false。如果 time 小于等于 0，该方法将完全不等待。

##### 总结

Lock的性能比synchronized的要好得多。

### AQS

AbstractQueuedSynchronizer，简称AQS。

AbstractQueuedSynchronizer是CountDownLatch/FutureTask/ReentrantLock/RenntrantReadWriteLock/Semaphore的基础，因此AbstractQueuedSynchronizer是Lock/Executor实现的前提。如下图所示：

![](.\png\java-AQS.png)

#### 基本思想

表现为一个同步器，支持下面两个操作

- 获取锁

  首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。

- 释放锁

  这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。

要支持上面两个操作就必须有下面的条件：

- 原子性操作同步器的状态位
- 阻塞和唤醒线程
- 一个有序得到队列

##### 原子性操作同步器的状态位

使用一个 32 位的整数来描述状态位，依然使用CAS操作来解决这个问题。还有一个 64位版本的同步器（AbstractQueuedLongSynchronizer）。

##### 阻塞和唤醒线程

在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。

```java
LockSupport.park()
LockSupport.park(Object)
LockSupport.parkNanos(Object, long)
LockSupport.parkNanos(long)
LockSupport.parkUntil(Object, long)
LockSupport.parkUntil(long)
LockSupport.unpark(Thread)
```

上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：

- 其他某个线程调用将当前线程作为目标调用 unpark
- 其他某个线程中断当前线程
- 该调用不合逻辑地（即毫无理由地）返回

##### 有序队列

在AQS中采用CHL列表来解决有序的队列的问题。

AQS 里面有三个核心字段：

```java
private volatile int state;
private transient volatile Node head;
private transient volatile Node tail;
```

其中state描述的有多少个线程取得了锁，对于互斥锁来说state<=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。

###### Node节点属性

| 属性       | 原型                   | 描述                              | 备注                                                         |
| ---------- | ---------------------- | --------------------------------- | ------------------------------------------------------------ |
| waitStatus | volatile               | 节点的等待状态                    |                                                              |
| prev       | volatile Node prev     | 节点的前一个节点。                | 节点的waitStatus依赖于前一个节点的状态。                     |
| next       | volatile Node next     | 此节点的后一个节点。              | 后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。   |
| thread     | volatile Thread thread | 节点绑定的线程                    |                                                              |
| nextWaiter | Node nextWaiter        | 下一个等待条件（Condition）的节点 | 下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。 |



### synchronized

#### 基础

Java中的每一个对象都可以作为锁。

#### 使用方式

- 修饰代码块
- 修饰方法
- 修饰一个静态方法
- 修饰一个类

#### 状态

synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁**可以升级但是不可以降级**，目的是为了提高获取锁和释放锁的效率。

#### 特性

java中synchronized关键字是同步锁，同步锁是依赖于对象而存在的，而且每一个对象有且仅有一个同步锁。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。

#### 概念锁

无锁->偏向锁->轻量锁->重量锁

悲观锁

可重入锁

### ReentrantLock

ReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。

#### 特性

- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。
- 可重入：
- 可中断：相对于synchronized，它湿可中断的锁，能够对中断作出响应。
- 超时机制：超时后不能获得锁，因此不会造成死锁。

#### 注

1. ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。
2. ReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。

#### 方法

| 方法                  | 原型                                        | 描述                                                         |
| --------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| ReentrantLock         | ReentrantLock()                             | 创建一个 ReentraantLock 的实例                               |
| ReentrantLock         | ReentrantLock(boolean fair)                 | 创建一个具有给定公平策略的ReentrantLock                      |
| isHeldByCurrentThread | boolean isHeldByCurrentThread()             | 查询当前线程是否保持此锁                                     |
| lockInterruptibly     | void lockInterruptibly()                    | 如果当前线程未被中断，则获取锁                               |
| tryLock               | boolean tryLock()                           | 仅在调用时锁未被另一个线程保持的情况下，才获取该锁           |
| tryLock               | boolean tryLock(long timeout,TimeUnit unit) | 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁 |

#### 示例

##### 基本使用

```java
public class ReentrantLockTest extends Thread{
    public static ReentrantLock lock = new ReentrantLock();
    public static int i=0;
    
    public ReentrantLockTest(String name){
        super.setName(name);
    }
    
    @Override
    public void run(){
        for(int j=0;j<10000000;j++){
            lock.lock();
            try{
                System.out.println(this.getName()+" "+i);
                i++;
            }finally{
                lock.unlock();
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException{
        ReentrantLockTest test1 = new ReentrantLockTest("thread1");
        ReentrantLockTest test2 = new ReentrantLockTest("thread2");
        
        test1.start();
        test2.start();
        test1.join();
        test2.join();
        System.out.println(i);
    }
}
```

##### 可限时

超时不能获得锁，就返回false，不会永久等待构成死锁。

使用 lock.tryLock(long timeout,TimeUnit unit) 来实现可限时锁，参数为时间和单位。

```java
public class TryLockTest extends Thread {

    public static ReentrantLock lock = new ReentrantLock();

    public TryLockTest(String name){
        super(name);
    }

    @Override
    public void run() {
        try {
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                Thread.sleep(6000);
            } else {
                System.out.println(this.getName() + " get lock failed");
            }
        } catch (Exception e) {
        } finally {
            if (lock.isHeldByCurrentThread()) {
                System.out.println("lock.isHeldByCurrentThread: " + this.getName());
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        TryLockTest t1 = new TryLockTest("TryLockTest1");
        TryLockTest t2 = new TryLockTest("TryLockTest2");

        t1.start();
        t2.start();
    }

}
```

两个线程来争夺一把锁，获得锁的线程sleep6秒，每个线程都只尝试5秒去获得锁。
所以必定有一个线程无法获得锁。无法获得后就直接退出了。

##### 可中断

`ReentrantLock`对中断是有响应的.`synchronized`一旦尝试获取锁就会一直等待直到获取到锁。

```java
public class LockInterrupt extends Thread {

    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    int lock;

    public LockInterrupt(int lock, String name) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            if (lock == 1) {
                lock1.lockInterruptibly();
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    // TODO: handle exception
                }
                lock2.lockInterruptibly();
            } else {
                lock2.lockInterruptibly();
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    // TODO: handle exception
                }
                lock1.lockInterruptibly();
            }
        } catch (Exception e) {
            // TODO: handle exception
        } finally {
            if (lock1.isHeldByCurrentThread()) {
                lock1.unlock();
            }
            if (lock2.isHeldByCurrentThread()) {
                lock2.unlock();
            }
            System.out.println(Thread.currentThread().getId() + ":线程退出");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        LockInterrupt t1 = new LockInterrupt(1, "LockInterrupt1");
        LockInterrupt t2 = new LockInterrupt(2, "LockInterrupt2");
        t1.start();
        t2.start();
        Thread.sleep(1000);

        //DeadlockChecker.check();
    }

    static class DeadlockChecker {

        private final static ThreadMXBean mbean = ManagementFactory
            .getThreadMXBean();

        public static void check() {

            Thread tt = new Thread(() -> {
                {
                    // TODO Auto-generated method stub
                    while (true) {
                        long[] deadlockedThreadIds = mbean.findDeadlockedThreads();
                        if (deadlockedThreadIds != null) {
                            ThreadInfo[] threadInfos = mbean.getThreadInfo(deadlockedThreadIds);
                            for (Thread t : Thread.getAllStackTraces().keySet()) {
                                for (int i = 0; i < threadInfos.length; i++) {
                                    if (t.getId() == threadInfos[i].getThreadId()) {
                                        System.out.println(t.getName());
                                        t.interrupt();
                                    }
                                }
                            }
                        }
                        try {
                            Thread.sleep(5000);
                        } catch (Exception e) {
                            // TODO: handle exception
                        }
                    }

                }
            });
            tt.setDaemon(true);
            tt.start();
        }

    }

}
```

执行后，确实出现了死锁，使用jstack可以看到如下结果：

![](.\png\java-ReentrantLock-dead.png)

通过中断来停止线程，结果如下：

![](.\png\java-ReentrantLock-interrupt.png)

### 概念锁

公平锁

非公平锁

可重入锁

### NonReentrantLock

#### 概念锁

非可重入锁

### ReentrantReadWriteLock

它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。

#### 父接口 ReadWriteLock

```java
public interface ReadWriterLock{
    Lock readLock();
    Lock writeLock();
}
```

#### 特性

- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。
- 可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。
- 锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。
- 锁获取中断：读取锁和写入锁都支持获取锁期间被中断。
- 条件变量：写入锁提供了条件变量（Condition）的支持，这个和独占锁一致，但是读取锁却不允许获取条件变量，将得到一个 UnsupportedOperationException 异常
- 重入数：读取锁和写入锁的数量最大分别只能是 65535（包括重入数）

#### 概念锁

共享锁

#### 示例

```java
public class ReadWriteCache {
    //充当cache
    static Map<String, Object> map = new HashMap<String, Object>();
    //实例化读写锁对象
    static ReentrantReadWriteLock reentrantReadWriteLock =
            new ReentrantReadWriteLock();
    //实例化读锁
    static Lock r = reentrantReadWriteLock.readLock();
    //实例化写锁
    static Lock w = reentrantReadWriteLock.writeLock();

    //获取缓存中值
    public static final Object get(String key) {
        r.lock();
        try {
            return map.get(key);
        } finally {
            r.unlock();
        }
    }

    //写缓存中值，并返回对应value
    public static final Object set(String key, Object obj) {
        w.lock();
        try {
            return map.put(key, obj);
        } finally {
            w.unlock();
        }
    }

    //清空所有内容
    public static final void clear() {
        w.lock();
        try {
            map.clear();
        } finally {
            w.unlock();
        }
    }
}
```



### Object

wait()、notify()、notifyAll()。

#### 特别说明

wait() 调用时会释放锁。

### Condition

Condition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。

#### 说明

在Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。

#### 特性

- 一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。
- Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()
- 支持响应中断
- 支持的定时唤醒功能

#### 方法

| 方法                 | 方法名                                                       | 描述             |
| -------------------- | ------------------------------------------------------------ | ---------------- |
| await                | void await() throws InterruptedException                     | 挂起线程，释放锁 |
| awaitUninterruptibly | void awaitUninterruptibly()                                  |                  |
| awaitNanos           | long awaitNanos(long nanosTimeout) throws InterruptedException |                  |
| await                | boolean await(long time, TimeUnit unit) throws InterruptedException |                  |
| awaitUntil           | boolean awaitUntil(Date deadline) throws InterruptedException |                  |
| signal               | void signal()                                                |                  |
| signalAll            | void signalAll()                                             |                  |



#### 注

Condition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。

每一个**Lock**可以有任意数据的**Condition**对象，**Condition**是与**Lock**绑定的，所以就有**Lock**的公平性特性：如果是公平锁，线程为按照FIFO的顺序从*Condition.await*中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。

#### 示例

```java
public class ProductQueue<T>{
    private final T[] items;
    private final Lock lock = new ReentrantLock();
    private Condition notFull = lock.newCondition();
    private Condition notEmpty = lock.newCondition();
    
    private int head,tail,count;
    
    public ProductQueue(int maxSize){
        items =(T[])new Object[maxSize];
    }
    
    public ProductQueue(){
        this(10);
    }
    
    public void put(T t) throws InterruptedException{
        lock.lock();
        try{
            while(count == getCapacity()){
                notFull.await();
            }
            items[tail] = t;
            if(++tail == getCapacity()){
                tail = 0;
            }
            ++count;
            notEmpty.signalAll();
        }finally{
            lock.unlock();
        }
    }
    
    public T take() throws InterruptedException{
        lock.lock();
        try{
            while(count ==0){
                notEmpty.await();
            }
            T ret = items[head];
            items[head] = null;
            
            if(++head == getCapacity()){
                head = 0;
            }
            --count;
            notFull.signalAll();
            return ret;
        }finally{
            lock.unlock();
        }
    }
    
    public int getCapacity(){
        return items.length;
    }
    
    public int size(){
        lock.lock();
        try{
            return count;
        }finally{
            lock.unlock();
        }
    }
}
```



### Semaphore

#### 概念

Semaphore是一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 `acquire()`，然后再获取该许可。每个 `release()` 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，`Semaphore` 只对可用许可的号码进行计数，并采取相应的行动。许可的数量可以通过构造函数的参数指定。

#### 使用场景

Semaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做**限流**。

#### 注

Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。

#### 特性

- 基于AQS 的共享模式
- 公平性：支持公平模式和非公平模式。默认使用了非公平模式。

#### 示例

- 访问特定资源前，必须使用 acquire 方法获得许可，如果许可数量为0，该线程一直阻塞，直到有可用许可。
- 访问资源后，使用 release 释放许可。

数据库连接，数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。

```java
public class SemaphoreTest {
    private static final int COUNT = 40;
    private static Executor executor = Executors.newFixedThreadPool(COUNT);
    private static Semaphore semaphore = new Semaphore(10);
    public static void main(String[] args) {
        for (int i=0; i< COUNT; i++) {
            executor.execute(new ThreadTest.Task());
        }
    }

    static class Task implements Runnable {
        @Override
        public void run() {
            try {
                //读取文件操作
                semaphore.acquire();
                // 存数据过程
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
            }
        }
    }
}
```



### Latch（闭锁）

闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。闭锁的状态是一次性的，改变了就不能复原。确保在闭锁打开之前所有特定的活动都需要再闭锁打开之后才能完成。

#### CountDownLatch

CountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。共享锁的线程共享同一个资源，一旦任意一个线程拿到共享资源，那么所有线程就都拥有的同一份资源。也就是通常情况下共享锁只是一个标志，所有线程都等待这个标识是否满足，一旦满足所有线程都被激活（相当于所有线程都拿到锁一样）。

CountDownLatch有一个**正数计数器**，countDown方法对计数器做减操作，await方法等待计数器达到0。所有await的线程都会阻塞直到计数器为0或者等待线程中断或者超时。

##### 方法

| 方法                               | 方法原型                                                     | 描述                               |
| ---------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| await()                            | public void await() throws InterruptedException              |                                    |
| await(long timeout, TimeUnit unit) | public boolean await(long timeout, TimeUnit unit) throws InterruptedException |                                    |
| countDown()                        | public void countDown()                                      |                                    |
| getCount()                         | public long getCount()                                       | 述的是当前计数，通常用于调试目的。 |

##### 示例

```java
public class PerformanceTestPool{
    public long timecost(final int times,final Runnable task) throws InterruptedException{
        if(times <= 0) throw new IllegalArgumentException();
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch overLatch = new CountDownLatch(times);
        for(int i =0;i<times;i++){
            new Thread(new Runnable(){
                @Override
                public void run(){
                    try{
                        startLatch.await();	//等待 startLatch  DownCount 到0，然后唤醒继续执行
                        task.run();
                    }catch(InterruptedException ex){
                        Thread.currentThread().interrupt();
                    }finally{
                        overLatch.countDown();
                    }
                }
            }).start();
        }
        //
		long start = System.nanoTime();
		startLatch.countDown();
        overLatch.await();	//等待 overLatch 执行到 0，唤醒再执行
        return System.nanoTime() - start;
    }
}
```

上面的例子中使用了两个闭锁，第一个闭锁确保在所有线程开始执行任务前，所有准备工作都已经完成，一旦准备工作完成了就调用*startLatch.countDown()*打开闭锁，所有线程开始执行。第二个闭锁在于确保所有任务执行完成后主线程才能继续进行，这样保证了主线程等待所有任务线程执行完成后才能得到需要的结果。在第二个闭锁当中，初始化了一个N次的计数器，每个任务执行完成后都会将计数器减一，所有任务完成后计数器就变为了0，这样主线程闭锁overLatch拿到此信号后就可以继续往下执行了。

### CyclicBarrier

允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。所谓屏障点就是一组任务执行完毕的时刻。

#### 特别说明

屏障点：初始化是指定的数目，然后await 数是否等于，等于则达到屏障点。

#### 方法

| 方法名                                             | 方法原型                                                     | 方法描述                                                     |
| -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| CyclicBarrier(int parties)                         | public CyclicBarrier(int parties)                            | 创建一个新的 `CyclicBarrier`，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。 |
| CyclicBarrier(int parties, Runnable barrierAction) | public CyclicBarrier(int parties, Runnable barrierAction)    | 创建一个新的 `CyclicBarrier`，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。 |
| await()                                            | public int await() throws InterruptedException, BrokenBarrierException | 在所有参与者都已经在此 barrier 上调用 `await` 方法之前，将一直等待。 |
| await(long timeout,TimeUnit unit)                  | public int await(long timeout,TimeUnit unit) throws InterruptedException, BrokenBarrierException,TimeoutException | 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。 |
| getNumberWaiting()                                 | public int getNumberWaiting()                                | 返回当前在屏障处等待的参与者数目。此方法主要用于调试和断言。 |
| getParties()                                       | public int getParties()                                      | 返回要求启动此 barrier 的参与者数目                          |
| isBroken()                                         | public boolean isBroken()                                    | 查询此屏障是否处于损坏状态                                   |
| reset()                                            | public void reset()                                          | 将屏障重置为其初始状态                                       |



#### 示例

##### 一个使用CyclicBarrier的例子

```java
public class CyclicBarrierDemo{
    final CyclicBarrier barrier;
    final int MAX_TASK;
    
    public CyclicBarrierDemo(int cnt){
        barrier = new CyclicBarrier(cnt+1);
        MAX_TASK = cnt;
    }
    
    public void doWork(final Runnable work){
        new Thread(){
            public void run(){
                work.run();
                try{
                    int index = barrier.await();
                    doWithIndex(index);
                }catch(InterruptedException ex){
                    return;
                }catch(BrokenBarrierException e){
                    return;
                }
            }
        }.start();
    }
    
    private void doWithIndex(int index){
        if(index == MAX_TASK /3){
            System.out.println("Left 30%");
        }else if(index == MAX_TASK/2){
            System.out.println("Left 50%");
        }else if(index == 0){
            System.out.println("run over");
        }
    }
    
    public void waitForNext(){
        try{
            doWithIndex(barrier.await());
        }catch(InterruptedException e){
            return;
        }catch(BrokenBarrierException e){
            return;
        }
    }
    
    public static void main(String[] args){
        final int count = 10;
        CyclicBarrierDemo demo = new CyclicBarrierDemo(count);
        for(int i=0;i<100;i++){
            demo.doWork(new Runnable(){
                public void run(){
                    //do something
                    try{
                        Thread.sleep(1000L);
                    }catch(Exception e){
                        return;
                    }
                }
            });
            if((i+1) % count ==0){
                demo.waitForNext();
            }
        }
    }
}
```

描述的是一个周期性处理任务的例子，在这个例子中有一对的任务（100个），希望每10个为一组进行处理，当前仅当上一组任务处理完成后才能进行下一组，另外在每一组任务中，当任务剩下50%，30%以及所有任务执行完成时向观察者发出通知。

CyclicBarrierDemo 构建了一个count+1的任务组（其中一个任务时为了外界方便挂起主线程）。每一个子任务里，人物本身执行完毕后都需要等待同组内其它任务执行完成后才能继续。同时在剩下任务50%、30%已经0时执行特殊的其他任务（发通知）。

#### 特点

- await()方法将挂起线程，直到同组的其它线程执行完毕才能继续
- await()方法返回线程执行完毕的索引，注意，索引时从任务数-1开始的，也就是第一个执行完成的任务索引为parties-1,最后一个为0，这个parties为总任务数，清单中是cnt+1
- CyclicBarrier 是可循环的，显然名称说明了这点。在清单1中，每一组任务执行完毕就能够执行下一组任务。
- 如果屏障操作不依赖于挂起的线程，那么任何线程都可以执行屏障操作。在清单1中可以看到并没有指定那个线程执行50%、30%、0%的操作，而是一组线程（cnt+1）个中任何一个线程只要到达了屏障点都可以执行相应的操作。
- CyclicBarrier 的构造函数允许携带一个任务，这个任务将在0%屏障点执行，它将在await()==0后执行。
- CyclicBarrier 如果在await时因为中断、失败、超时等原因提前离开了屏障点，那么任务组中的其他任务将立即被中断，以InterruptedException异常离开线程。
- 所有await()之前的操作都将在屏障点之前运行，也就是CyclicBarrier 的内存一致性效果

### 总结

![](.\png\java锁_小结.png)

## 线程

### 线程与进程

#### 进程：

每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（**进程是资源分配的最小单位**）

#### 线程：

同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（**线程是cpu调度的最小单位**）



线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

多进程是指操作系统能同时运行多个任务（程序）。

线程是指在同一程序中有多个顺序流在执行。

### 新建线程

#### Thread

继承Thread类，重写 run 方法

```java
Thread thread = new Thread(){
    @Override
    public void run(){
        System.out.println("继承Thread");
        super.run();
    }
}
thread.start();
```

##### 注

- start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态，什么时候运行是由操作系统决定的。
- start() 方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。



#### Runnable

实现runnable接口

```java
Thread thread = new Thread(new Runnable(){
   @Override
    public void run(){
        System.out.println("实现runnable接口")
    }
});
thread.start();
```

##### 注

- Thread类实际上也是实现了Runnable接口的类。
- 在启动多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。

#### Thread与Runnable的区别

- 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。如：

```java
class MyThread implements Runnable{
    private int ticket =5;
    @Override
    public void run(){
        for(int i=0;i<10;i++){
            try{
                Thread.sleep(500);	//睡眠0.5秒，不至于运行太快
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        if(this.ticket > 0){
            System.out.println("线程开始："+Thread.currentThread().getName()+"卖票："+this.ticket--);
        }
    }
}

public class TestMain(){
    public static void main(String[] args){
        MyThread mt = new MyThread();
        new Thread(mt).start();	
        //同一个mt，但是在Thread中就不可以，如果用同一个实例化对象mt，就会出现异常
        new Thread(mt).start();
        new Thread(mt).start();
        
    }
}
```

##### 实现Runnable接口比继承Thread类所具有的优势：

- 适合多个相同的程序代码的线程去处理同一个资源
- 可以避免Java中的单继承的限制
- 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
- 线程池只能放入实现Runnable或 callable 类线程，不能直接放入继承Thread的类

#### Callable

实现Callback接口

```
ExecutorService service = Executors.newSingleThreadExecutor();
Future<String> future = service.submit(new Callable(){
	@Override
	public String call() throws Exception{
		return "通过实现Callable接口";
	}
});
try{
	String result = future.get();
	System.out.println(result);
} catch (InterruptedException e) {
	e.printStackTrace();
} catch (ExecutionException e) {
	e.printStackTrace();
}
```

### 名词解释

**主线程**：JVM调用程序main()所产生的线程。
**当前线程**：一般指通过Thread.currentThread()来获取的进程。
**后台线程**：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束
**前台线程**：是指接受后台线程服务的线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。

#### 线程类的一些常用方法： 

| 方法名          | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| sleep()         | 强迫一个线程睡眠Ｎ毫秒                                       |
| isAlive()       | 判断一个线程是否存活                                         |
| join()          | 等待线程终止                                                 |
| activeCount()   | 程序中活跃的线程数                                           |
| enumerate()     | 枚举程序中的线程                                             |
| currentThread() | 得到当前线程                                                 |
| isDaemon()      | 一个线程是否为守护线程                                       |
| setDaemon()     | 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) |
| setName()       | 为线程设置一个名称                                           |
| wait()          | 强迫一个线程等待                                             |
| notify()        | 通知一个线程继续运行                                         |
| setPriority()   | 设置一个线程的优先级                                         |

#### 子线程

如果线程A 创建了线程 B，那么 B 就是A的子线程。

### 线程状态

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统第称作“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

新建状态：新创建一个线程对象。

就绪状态：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

运行状态：就绪状态的线程获取了CPU，执行程序代码。

阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

1. 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(**wait会释放持有的锁**)
2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（**sleep是不会释放持有的锁**）

死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

#### 状态转换

![](.\png\线程状态转换图.png)

#### 线程调度

##### 线程优先级

Java线程有优先级，优先级高的线程会获得较多的运行机会。

Java线程的优先级用整数表示，取值范围是 1~10，Thread类有以下三个静态常量：

```java
static int MAX_PRIORITY
	//线程可以具有的最高优先级，取值为10
static int MIN_PRIORITY
	//线程可以具有的最低优先级，取值为1
static int NORM_PRIORITY
	//分配给线程的默认优先级，取值为5
```

Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。

###### 注

- 主线程的默认优先级为Thread.NORM_PRIORITY。
- 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级

##### interrupted

中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用 isInterrupted（）来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用Thread的静态方法 interrupted（）对当前线程进行中断操作，该方法会清除中断标志位。

| 方法名                              | 详细解释                 | 备注                                                         |
| ----------------------------------- | ------------------------ | ------------------------------------------------------------ |
| public void interrupt()             | 中断该线程对象           | 如果该线程被调用了Object.wait/Object.wait(long)，或者被调用sleep(long)、join()/join(long)方法时会抛出InterruptedException并且中断标志位将会被清除 |
| public boolean isInterrupted()      | 测试该线程对象是否被中断 | 中断标志位不会被清除                                         |
| public static boolean interrupted() | 测试当前线程是否被中断   | 中断标志位会被清除                                           |

##### join

join方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出。如果一个线程实例A执行了threadB.join(),其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行。

| 方法                                                       |
| ---------------------------------------------------------- |
| public final synchronized void join(long millis)           |
| public final synchronized void join(long millis,int nanos) |
| public final void join() throws InterruptedException       |

join方法源码

```java
while(isAlive()){
    wait(0);
}
```

可以看出来当前等待对象threadA会一直阻塞，直到被等待对象threadB结束后即isAlive()返回false的时候才会结束while循环，当threadB退出时会调用notifyAll()方法通知所有的等待线程。

###### 示例

```java
public class JoinDemo {
    public static void main(String[] args) {
        Thread previousThread = Thread.currentThread();
        for (int i = 1; i <= 10; i++) {
            Thread curThread = new JoinThread(previousThread);
            curThread.start();
            previousThread = curThread;
        }
    }

    static class JoinThread extends Thread {
        private Thread thread;

        public JoinThread(Thread thread) {
            this.thread = thread;
        }

        @Override
        public void run() {
            try {
                thread.join();
                System.out.println(thread.getName() + " terminated.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

输出结果为

```shell
main terminated.
Thread-0 terminated.
Thread-1 terminated.
Thread-2 terminated.
Thread-3 terminated.
Thread-4 terminated.
Thread-5 terminated.
Thread-6 terminated.
Thread-7 terminated.
Thread-8 terminated.
```

创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。

##### wait

线程等待。Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的notify() 方法或 notifyAll() 唤醒方法。这两个唤醒方法也是Object类的方法，行为等价于调用wait(0)一样。

从语法角度来说就是Obj.wait()，Obj.notify() 必须在 synchronized(Obj){...} 语句块内。

##### sleep

| 方法                                         |
| -------------------------------------------- |
| public static native void sleep(long millis) |

如果当前线程获得了锁，sleep方法并不会失去锁。

##### sleep 与wait

###### 共同点

1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回

2.  wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 

   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。

   

   **需要注意的是**，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 

###### 区别

1. sleep()方法是Thread的静态方法，而wait是Object实例方法
2. wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
3. sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。

##### yield

| 方法名                            |
| --------------------------------- |
| public static native void yield() |

一旦执行，它会使当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配**给当前线程相同优先级**的线程。

###### yield 与 sleep的区别

同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程**都可以去竞争**，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有**相同优先级**的线程能够获得释放出来的CPU时间片。有可能在进入到可执行状态后马上又被执行。

##### notify()

线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。**选择是任意性的**，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。

### 守护线程Daemon

守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。

#### 设置为守护线程

setDaemon(true);

##### 特别注意

设置守护线程要优先于 start() 方法，否则会报错

```java
Exception in thread "main" java.lang.IllegalThreadStateException
at java.lang.Thread.setDaemon(Thread.java:1365)
at learn.DaemonDemo.main(DaemonDemo.java:19)
```

#### 示例代码

```java
public class DaemonDemo {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        System.out.println("i am alive");
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        System.out.println("finally block");
                    }
                }
            }
        });
        daemonThread.setDaemon(true);
        daemonThread.start();
        //确保main线程结束前能给daemonThread能够分到时间片
        try {
            Thread.sleep(800);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

输出结果

```shell
i am alive finally block i am alive
```

#### 特别注意

守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的

### 中断

```java
//中断线程（实例方法）
public void Thread.interrupt();

//判断线程是否被中断（实例方法）
public boolean Thread.isInterrupted();

//判断是否被中断并清除当前中断状态（静态方法）
public static boolean Thread.interrupted();
```

#### 线程处于被阻塞状态，中断该线程将抛出异常

当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用`Thread.interrupt()`方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程：

```java
public class InterruptSleepThread3{
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
          	@Override
            public void run(){
            	//while 在 try中，通过异常中断就可以退出 run循环
                try{
                	while(true){
                    	//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出
                    	Thread.sleep(2);
                	}
            	catch(IntertuptedException e){
                    System.out.println("Interrupted When Sleep");
                    boolean interrupt = this.isInterrupted();
                    //中断状态被复位
                    System.out.println("interrupt:"+interrupt);
                }
            }
        };
        t1.start();
		TimeUnit.SECONDS.sleep(2);
		//中断处于阻塞状态的线程
		t1.interrupt();
    }
}
    
//输出结果:
Interrupted When Sleep
interrupt:false
```

#### 处于运行期且非阻塞状态线程中断，不会得到任何响应

```java
public class InterruptThread{
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
            @Override
            public void run(){
                while(true){
                    System.out.println("未被中断");
                }
            }
        };
        t1.start();
        try{
            Thread.sleep(2);
            t1.interrupt();
        }catch(Exception e){
            
        }
    }
}

//输出结果（无限执行）
未被中断
未被中断
未被中断
.....
```

##### 需要手动中断检测并结束程序

```java
public class  InterruputThread {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(){
            @Override
            public void run(){
                while(true){
                    //判断当前线程是否被中断
                    if (this.isInterrupted()){
                        System.out.println("线程中断");
                        break;
                    }
                }

                System.out.println("已跳出循环,线程中断!");
            }
        };
        t1.start();
        TimeUnit.SECONDS.sleep(2);
        t1.interrupt();

        /**
         * 输出结果:
            线程中断
            已跳出循环,线程中断!
         */
    }
}
```

##### 注：

非阻塞状态调用 interrupt() 并不会导致中断状态重置。

#### 总结

- 当线程处于阻塞状态或者视图执行一个阻塞操作时，我们可以使用实例方法 interrupt() 进行线程中断，执行中断操作后将会抛出 interruptException 异常（该异常必须捕捉无法向外抛出）并将中断状态复位
- 当线程处于运行状态时，可调用实例方法 interrupt() 进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码（其实就是结束 run 方法体的代码）

```java
public void run(){
    try{
        //判断当前线程是否已中断，注意 interupted 方法是静态的，执行后会对中断状态进行复位
        while(!Thread.interrupted()){	//判断非阻塞状态下的中断，条件判断程序退出
            try{
                Thread.sleep(2000);
            }catch(InterruptedException e){
                //中断导致异常抛出，然后结束程序
            }
        }
    }
}
```

#### 命令行查看线程运行情况

用 jstack 查看一下这个任务的各个线程运行情况：

![](.\png\java-查看线程运行情况-jstack.jpg)

##### 发现死锁

Java-level = deadlock，即死锁，两个线程相互等待对方的锁

![](.\png\java-死锁.jpg)

### 线程工厂

ThreadFactory 就是一个线程工厂。用来创建线程。

#### 作用

统一在创建线程时设置一些参数，如是否守护线程。线程一些特性等。

#### 源码

```java
public interface ThreadFactory{
    Thread newThread(Runnable r);
}
```

#### 示例

##### JDK中使用

Executors 类当中

```java
static class DefaultThreadFactory implements ThreadFactory{
    private static final AtomicInteger poolNumber = new AtomicInteger(1);	//原子类，线程池的编号
    private final ThreadGroup group;	//线程组
    private final AtomicInteger threadNumber = new AtomicInteger(1);	//线程数目
    private final String namePrefix;	//为每个创建的线程添加的前缀
    
    DefaultThreadFactory(){
        SecurityManager s = System.getSecurityManager();
        group = (s != null)? s.getThreadGroup() : Thread.currentThread().getThreadGroup();	//取得线程组
        namePrefix = "pool-"+poolNumber.getAndIncrement() + "-thread-";
    }
    
    public Thread newThread(Runnable r){
        //真正创建线程的地方，设置了线程的线程组及线程名称
        Thread t = new Thread(group,r,namePrefix+threadNumber.getAndIncrement(),0);
        if(t.isDaemon()){
            t.setDaemon(false);
        }
        if(t.getPriority() != Thread.NORM_PRIORITY){	//默认是正常优先级
            t.setPriority(Thread.NORM_PRIORITY);
        }
        return t;
    }
}
```

##### 实现自己线程工厂

```java
public class ThreadFactoryTest {
	static class MyThreadFactory implements ThreadFactory {
		private int counter;
		private String name;
		private List<String> stats;
 
		public MyThreadFactory(String name) {
			counter = 0;
			this.name = name;
			stats = new ArrayList<String>();
		}
 
		@Override
		public Thread newThread(Runnable run) {
			Thread t = new Thread(run, name + "-Thread-" + counter);
			counter++;
			stats.add(String.format("Created thread %d with name %s on%s\n",t.getId(), t.getName(), new Date()));
			return t;
		}
 
		public String getStas() {
			StringBuffer buffer = new StringBuffer();
			Iterator<String> it = stats.iterator();
			while (it.hasNext()) {
				buffer.append(it.next());
				buffer.append("\n");
			}
			return buffer.toString();
		}
	}
	
	static class MyTask implements Runnable {
		
		private int num;
		public MyTask(int num) {
			this.num = num;
		}
 
		@Override
		public void run() {
			System.out.println("Task "+ num+" is running");
			try {
				Thread.sleep(2*10000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
		
	}

	public static void main(String[] args) {
		System.out.println("main thread beging");
		MyThreadFactory factory = new MyThreadFactory("MyThreadFactory");  
 
        Thread thread = null;  
        for(int i = 0; i < 10; i++) {  
            thread = factory.newThread(new MyTask(i));  
            thread.start();  
        }  
        System.out.printf("Factory stats:\n");  
        System.out.printf("%s\n",factory.getStas());  
    	System.out.println("main thread end");
	}
}
```

### ThreadLocal

ThreadLocal 是一个关于创建线程局部变量的类。

#### 特点

ThreadLocal 创建的变量只能被当前线程访问，其他线程则无法访问和修改。

#### 类

![](.\png\java-ThreadLocal.png)

#### 作用

ThreadLocal 为了方便每个线程处理自己的状态而引入的一个机制。不是用于解决共享变量的问题，不是为了协调线程同步而存在。

#### 结构

ThreadLocalMap 类相当于一个 Map，key 是ThreadLocal 本身，value 就是我们的值。

#### 方法

##### 创建，支持泛型

```java
ThreadLocal<String> mStrThreadLocal = new ThreadLocal<>();
```

##### set方法

```java
mStrThreadLocal.set("xxxxxx");
```

##### get方法

```java
mStrThreadLocal.get();
```

#### ThreadLocal 初始值

为ThreadLocal设置默认的 get 初始值，需要重写 initialValue 方法。

#### 内存泄漏的问题

```java
static class Entry extends WeakReference<ThreadLocal<?>>{
    //The value associated with this ThreadLocal.
    Object value;
    
    Entry(ThreadLocal<?> k,Object v){
        super(k);
        value = v;
    }
}
```

ThreadLocalMap使用ThreadLocal的弱引用作为Entry的key，如果一个ThreadLocal没有外部强引用来引用它，下一次系统GC时，这个ThreadLocal必然会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。

我们上面介绍的get、set、remove等方法中，都会对key为null的Entry进行清除（expungeStaleEntry方法，将Entry的value清空，等下一次垃圾回收时，这些Entry将会被彻底回收）。

但是如果当前线程一直在运行，并且一直不执行get、set、remove方法，这些key为null的Entry的value就会一直存在一条强引用练：Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value，导致这些key为null的Entry的value永远无法回收，造成内存泄漏。

##### 避免内存泄漏

在使用完 ThreadLocal 后，手动调用 remove 方法，以避免出现内存泄漏。

#### 真的只能被一个线程访问么

使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值。

如下，我们在主线程中创建一个 InheritableThreadLocal 的实例，然后在**子线程**(如果线程A创建了线程B，那么**B就是A的子线程**)中得到这个 InheritableThreadLocal 实例设置的值。

```java
private void testInheritableThreadLocal(){
    final ThreadLocal threadLocal = new InheritableThreadLocal();
    threadLocal.set（"xxxx"）;
    Thread t = new Thread(){
        @Override
        public void run(){
            super.run();
            Log.i(LOGTAG,"testInheritableThreadLocal =" +threadLocal.get());
        }
    };
    t.start();
}
```



#### 示例

```java
public class ThreadLocalTest{
    //创建一个 Integer 型的线程本地变量
    static final ThreadLocal<Integer> local = new ThreadLocal<Integer>(){
        @Override
        protected Integer initialValue(){
            return 0;
        }
    };
    
    static class Task implements Runnable{
        private int num;
        
        public Task(int num){
            this.num = num;
        }
        
        @Override
        public void run(){
            //获取当前线程的本地变量，然后累加10次
            Integer i = local.get();
            while(++1 <10);
            System.out.println("Task "+num+"local num result is "+i);
        }
    }
    static void Test1{
        System.out.println("main thread begin");
        ExecutorService executors = Executors.newCachedThreadPool();
        for(int i=1;i<=5;i++){
            executors.execute(new Task(i));
        }
        executors.shutdown();
        System.out.println("main thread end");
    }
    
    public static void main(String[] args){
        Test1();
    }
}
```

### InheritableThreadLocal

#### 特点

- InheritableThreadLocal 是 ThreadLocal 的子类。
- 该类扩展了 ThreadLocal，为子线程提供从父线程那里继承的值：在创建子线程时，子线程会接收所有可继承的线程局部变量的初始值，以获得父线程所具有的值。通常，子线程的值与父线程的值是一致的；
- 通过重写这个类中的 childValue 方法，子线程的值可以作为父线程值的一个任意函数。

#### 使用场景

当必须将变量（如用户 ID 和 事务 ID）中维护的每线程属性（per-thread-attribute）自动传送给创建的所有子线程时，应尽可能地采用可继承的线程局部变量，而不是采用普通的线程局部变量。

#### 示例

##### 对比ThreadLocal

###### ThreadLocalTest.java

```java
public class ThreadLocalTest{
    private static ThreadLocal<Integer> familyFortunes = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            Random random = new Random();
            return random.nextInt(1000);
        }
    };

    public static int get() {
        return familyFortunes.get();
    }

    public static void set(int value) {
        familyFortunes.set(value);
    }
}
```

###### InheritableThreadLocalTest.java

```java
public class InheritableThreadLocalTest{
    private static InheritableThreadLocal<Integer> familyFortunes = new InheritableThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            Random random = new Random();
            return random.nextInt(1000);
        }
    };

    public static int get() {
        return familyFortunes.get();
    }

    public static void set(int value) {
        familyFortunes.set(value);
    }
}
```

###### Thread.java

```java
public class Thread2 extends Thread {

    public Thread2(String name) {
        super(name);
    }

    @Override
    public void run() {
        super.run();
        System.out.printf("%s 从 ThreadLocal 取数据：%d\n",Thread.currentThread().getName(),ThreadLocalTest.get());
        
        System.out.printf("%s 从 InheritableThreadLocal 取数据：%d\n",Thread.currentThread().getName(),InheritableThreadLocalTest.get());
    }

    public static void main(String[] args) {
        System.out.printf("%s 从 ThreadLocal 取数据：%d\n",Thread.currentThread().getName(), ThreadLocalTest.get());
        System.out.printf("%s 从 InheritableThreadLocal 取数据：%d\n",Thread.currentThread().getName(),InheritableThreadLocalTest.get());
        Thread2 t1 = new Thread2("Child1");
        t1.start();
    }
}
```

###### 输出

```shell
main 从 ThreadLocal 取数据：444
main 从 InheritableThreadLocal 取数据：401
Child1 从 ThreadLocal 取数据：513
Child1 从 InheritableThreadLocal 取数据：401
```

##### 可见性

- 可变对象：父线程初始化, 因为Thread Construct浅拷贝, 共用索引, 子线程修改父线程跟着变; 父线程不初始化, 子线程初始化, 无Thread Construct浅拷贝, 子线程和父线程都是单独引用, 不同对象, 子线程修改父线程不跟着变。
- 不可变对象：不可变对象由于每次都是新对象, 所以无论父线程初始化与否，子线程和父线程都互不影响。

###### 代码

```java
public class TestInheritableThreadLocal2 {
    public static ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>();
    public static ThreadLocal<Integer> inheritableThreadLocal = new InheritableThreadLocal<Integer>();
    public static ThreadLocal<User> mutableInheritableThreadLocal = new InheritableThreadLocal<User>();
    public static ThreadLocal<User> mutableInheritableThreadLocalTo = new InheritableThreadLocal<User>();
    public static ThreadLocal<String> immutableInheritableThreadLocal = new InheritableThreadLocal<String>();
    public static ThreadLocal<String> immutableInheritableThreadLocalTo = new InheritableThreadLocal<String>();
 
    public static void main(String args[]) throws InterruptedException {
        // 测试0.ThreadLocal普通测试;
        // 结论0: ThreadLocal下子线程获取不到父线程的值
        threadLocal.set(new Integer(123)); // 父线程初始化
        Thread thread = new MyThread();
        thread.start();
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + threadLocal.get());
        System.out.println();
        
        // 测试1.InheritableThreadLocal普通测试;
        // 结论1: InheritableThreadLocal下子线程可以获取父线程的值
        inheritableThreadLocal.set(new Integer(123)); // 父线程初始化
        Thread threads = new MyThreadTo();
        threads.start();
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + inheritableThreadLocal.get());
        System.out.println();
 
        // 测试2.父线程和子线程的传递关系测试: 可变对象, 父线程初始化;
        // 结论2: 父线程初始化, Thread Construct浅拷贝, 共用索引, 子线程先get()对象, 再修改对象的属性,
        // 父线程跟着变, 注意: 此处子线程如果没有先get()直接使用set()一个新对象, 父线程是不会跟着变的
        mutableInheritableThreadLocal.set(new User("joon"));// 2.1父线程初始化
        Thread TestThread = new TestThread(); // 2.2先初始化父线程再创建子线程, 确保子线程能继承到父线程的User
        TestThread.start(); // 开始执行子进程
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + mutableInheritableThreadLocal.get()); 
        // 2.5此处输出值为子线程修改的值, 因此可得出上述结论2
        System.out.println();
 
        // 测试3.父线程和子线程的传递关系测试: 可变对象, 父线程不初始化;
        // 结论3: 父线程没有初始化, 子线程初始化, 无Thread Construct浅拷贝, 子线程和主线程都是单独引用, 不同对象,
        // 子线程修改父线程不跟着变
        Thread TestThreadTo = new TestThreadTo(); // 3.1创建子进程
        TestThreadTo.start();
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + mutableInheritableThreadLocalTo.get()); 
        // 3.3此处输出为null, 可得出上述结论3
        System.out.println();
 
        // 测试4.父线程和子线程的传递关系测试: 不可变对象, 父线程初始化;
        // 结论4: 父线程初始化, Thread Construct浅拷贝, 但由于不可变对象由于每次都是新对象, 所以互不影响
        immutableInheritableThreadLocal.set("joon");// 4.1父线程初始化
        Thread TestThreadTre = new TestThreadTre(); // 4.2先初始化父线程再创建子线程, 确保子线程能继承到父线程的值
        TestThreadTre.start(); // 执行子进程
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + immutableInheritableThreadLocal.get()); 
        // 4.5此处输出为父线程的值, 因此可得出上述结论4
        System.out.println();
 
        // 测试5.父线程和子线程的传递关系测试: 不可变对象, 父线程不初始化;
        // 结论5: 父线程没有初始化, 子线程初始化, 无Thread Construct浅拷贝, 子线程和父线程操作不同对象, 互不影响
        Thread TestThreadFour = new TestThreadFour(); // 5.1创建子线程
        TestThreadFour.start();
        TimeUnit.MILLISECONDS.sleep(100); // 睡眠, 以等待子线程执行完毕
        System.out.println("main = " + immutableInheritableThreadLocalTo.get()); 
        // 5.3此处输出为空, 因此可得出上述结论5
    }
 
    private static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("MyThread = " + threadLocal.get());
        }
    }
 
    private static class MyThreadTo extends Thread {
        @Override
        public void run() {
            System.out.println("inheritableThreadLocal = " + inheritableThreadLocal.get());
        }
    }
 
    private static class TestThread extends Thread {
        @Override
        public void run() {
            // 2.3此处输出父线程的初始化对象值, 代表子线程确实继承了父线程的对象值
            System.out.println("TestThread.before = " + mutableInheritableThreadLocal.get());
            // 2.4子类拿到对象并修改
            mutableInheritableThreadLocal.get().setName("whee");
            System.out.println("mutableInheritableThreadLocal = " + mutableInheritableThreadLocal.get());
        }
    }
 
    private static class TestThreadTo extends Thread {
        @Override
        public void run() {
            mutableInheritableThreadLocalTo.set(new User("whee"));// 3.2子线程调用set方法
            System.out.println("mutableInheritableThreadLocalTo = " + mutableInheritableThreadLocalTo.get());
        }
    }
 
    private static class TestThreadTre extends Thread {
        @Override
        public void run() {
            // 4.3此处输出父线程初始化的值, 代表子线程确实继承了父线程的对象值
            System.out.println("TestThreadTre.before = " + immutableInheritableThreadLocal.get());
            // 4.4子线程调用set方法
            immutableInheritableThreadLocal.set("whee");
            System.out.println("immutableInheritableThreadLocal = " + immutableInheritableThreadLocal.get());
        }
    }
 
    private static class TestThreadFour extends Thread {
        @Override
        public void run() {
            immutableInheritableThreadLocalTo.set("whee");// 5.2子线程调用set方法
            System.out.println("immutableInheritableThreadLocalTo = " + immutableInheritableThreadLocalTo.get());
        }
    }
 
    private static class User {
        String name;
 
        public User(String name) {
            this.name = name;
        }
 
        public String getName() {
            return name;
        }
 
        public void setName(String name) {
            this.name = name;
        }
 
        @Override
        public String toString() {
            return "User [name=" + name + "]";
        }
 
    }
}
```

###### 结果

```shell
MyThread = null
main = 123

inheritableThreadLocal = 123
main = 123

TestThread.before = User [name==joon]
mutableInheritableThreadLocal = User [name=whee]
main = User [name=whee]

mutableInheritableThreadLocalTo = User [name=whee]
main = null

TestThreadTre.before = joon
immutableInheritableThreadLocal = whee
main = joon

immutableInheritableThreadLocalTo = whee
main = null
```

###### 解决互相影响

重写 childValue() 方法实现子线程和与父线程之间互不影响。

##### childValue

这个方法返回的是子线程在第一次get的时候的初始值，如果不重写，默认就是返回父线程的值。

```java
public class InheritableThreadLocalTest {
    private static InheritableThreadLocal<Integer> familyFortunes = new InheritableThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            Random random = new Random();
            return random.nextInt(1000);
        }

        @Override
        protected Integer childValue(Integer parentValue) {
            return parentValue+1;
        }
    };
    public static int get() {
        return familyFortunes.get();
    }

    public static void set(int value) {
        familyFortunes.set(value);
    }
}
```

### Thread 捕获自定义异常

通常 java.lang.Thread 对象运行设置一个默认的异常处理方法：

```java
java.lang.Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler)
```

这个默认的静态全局的异常捕获方法是直接输出异常堆栈。

我们可以覆盖此默认实现，只需要一个自定义的java.lang.Thread.UncaughtExceptionHandler接口实现即可。

## 线程池 

### 产生原因

- 减少在创建和销毁线程上所花的时间以及系统资源的开销 
- 将当前任务与主线程隔离，能实现和主线程的异步执行，特别是很多可以分开重复执行的任务

### 分类

| 方法                        | 描述                                                         | 特点                                                       | 使用场景                               | 联系                                                         |
| --------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| newFixedThreadPool          | 创建一个固定长度的线程池，当到达线程最大数量时，线程池的规模将不再变化 | 固定，没有IDLE                                             | 多数针对一些很稳定很固定的正规并发线程 | 与newCacheThreadPool，newSingleThreadPoolExecutor调用同一个低层池，只不过参数不同<br>参数： IDLE 0 |
| newCachedThreadPool         | 创建一个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模无限制 | 缓存性。有，则reuse；没有，则创建。缺省timeout 60 (IDLE)   | 面向连接的daemon型SERVER中用得不多     | 与newCacheThreadPool，newSingleThreadPoolExecutor调用同一个低层池，只不过参数不同<br/>参数： IDLE  缺省 60s |
| newSingleThreadPoolExecutor | 创建一个单线程的Executor，确保任务对了，串行执行             | 单个，串行执行                                             |                                        | 与newCacheThreadPool，newSingleThreadPoolExecutor调用同一个低层池，只不过参数不同<br/>参数：1,-1,0秒IDLE |
| newScheduledThreadPool      | 创建一个固定长度的线程池，而且以延迟或者定时的方式来执行，类似Timer | 固定长度，调度型，可按 schedule 依次 delay执行，或周期执行 |                                        |                                                              |

### 使用

#### 定义线程类

```java
class Handler implements Runnable{
    
}
```

#### 建立ExecutorService线程池

```java
ExecutorService executorService = Executors.newCachedThreadPool();
```

或

```java
int cpuNums = Runtime.getRuntime().availableProcessors();  
//获取当前系统的CPU 数目
ExecutorService executorService =Executors.newFixedThreadPool(cpuNums * POOL_SIZE); //ExecutorService通常根据系统资源情况灵活定义线程池大小
```

#### 调用线程池操作

```java
while(true){
    executorService.execute(new Handler(socket));
    //class Handler implements Runnable
    
    或者
    executorService.execute(createTask(i));
    //private static Runnable createTask(final int taskID)
}
```

execute(Runnable对象)方法其实就是对Runnable对象调用start()方法（当然还有一些其他后台动作，比如队列，优先级，IDLE timeout，active激活等）

### 示例

#### CachedThreadPool

客户端线程和线程池之间会有一个任务队列。当程序要关闭时，需要注意两件事情：

1. 入队的这些任务的情况怎么样了
2. 正在运行的这个任务执行的如何了

有意识地关闭线程池，正确的方法有两种：

1. 让所有的入队任务都执行完毕（shutdown()）
2. 舍弃这些任务（shutdownNow()）

```java
class Handle implements Runnable {
	private String name;
	public Handle(String name) {
		this.name = "thread"+name;
	}	
	@Override
	public void run() {
		System.out.println( name +" Start. Time = "+new Date());
        processCommand();
        System.out.println( name +" End. Time = "+new Date());
	}
	 private void processCommand() {
	        try {
	            Thread.sleep(1000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	    }
	 @Override
	    public String toString(){
	        return this.name;
	    }	
}
```

```java
public static void testCachedThreadPool(){
    System.out.println("Main:Starting at:"+new Date());
    //创建一个线程池，缓冲池容量大小为 Integer.MAX_VALUE
    ExecutorService exec = Executors.newCachedThreadPool();
    for(int i=0; i<10;i++){
        exec.execute(new Handle(String.valueOf(i)));
    }
    //执行到此处并不会马上关闭线程池，但之后不能再往线程池中加线程，否则会报错
    exec.shutdown();
    System.out.println("Main:Finished all threads at"+new Date());
}
```

##### 注：

exec.shutdown();  执行到此处并不会马上关闭线程池，但之后不能再往线程池中加线程，否则会报错

#### FixedThreadPool

#### SingleThreadPool

#### newScheduledThreadPool

这是一个计划线程池类，它能设置线程执行的先后间隔及执行时间等，功能比上面的三个强大了一些。

```java
public static void testScheduledThreadPool(){
    System.out.println("Main Thread: Starting at:"+new Date());
    //创建大小为 10 的线程池
    ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor)Executors.newScheduledThreadPool(10);
    for(int i=0;i<10;i++){
        //延迟10秒执行
        exec.schedule(new Handle(String.valueOf(i)),10,TimeUnit.SECONDS);
    }
    //执行到此处并不会马上关闭线程池
    exec.shutdown();
    while(!exec.isTerminated()){
        //wait for all tasks to finish
    }
    System.out.println("Main Thread: Finished at:"+new Date());
}
```

##### ScheduledThreadPoolExecutor的定时方法

```java
schedule(Runnable,long,TimeUnit);
schedule(Callable<V>,long,TimeUnit);
scheduleAtFixedRate(Runnable,long,long,TimeUnit);
scheduleWithFixedDelay(Runnable,long,long,TimeUnit)
```

###### scheduleAtFixedRate

按指定频率周期执行某个任务

```java
public ScheduleFuture<?> scheduleAtFixedRate(Runnable command,	//执行线程
                                             long initialDelay,	//初始化延时
                                             long period,		//两次开始执行最小间隔时间
                                             TimeUnit unit);	//计时单位
);
```

###### scheduleWithFixedDelay

周期定时执行某个任务/按指定频率间隔执行某个任务

```java
public ScheduleFuture<?> scheduleWithFixedDelay(Runnable command,	//执行线程
                                                long initialDelay,	//初始化延时
                                                long delay,			//间隔延时时间
                                                TimeUnit unit);		//计时单位
```

##### 示例

```java
class MyHandle implements Runnable {
 
	@Override
	public void run() {
		System.out.println(System.currentTimeMillis());
		try {
			Thread.sleep(1 * 1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
}
```

###### 按指定频率周期执行某个任务

下面实现每隔2秒执行一次，注意，如果上次的线程还没有执行完成，那么会阻塞下一个线程的执行。即使线程池设置得足够大。

```java
/**
* 初始化延迟0ms开始执行，每隔2000ms重新执行一次任务
* @author linbingwen
* @since  2016年6月6日
*/
public static void executeFixedRate() {  
	ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);  
	executor.scheduleAtFixedRate(  
				new MyHandle(),  
	            0,  
	            2000,  
	            TimeUnit.MILLISECONDS);  
}
```

间隔指的是连续两次任务开始执行的间隔。对于scheduleAtFixedRate方法，当执行任务的时间大于我们指定的间隔时间时，它并不会在指定间隔时开辟一个新的线程并发执行这个任务。而是**等待该线程执行完毕**。

###### 按指定频率间隔执行某个任务

```java
/**
* 以固定延迟时间进行执行
* 本次任务执行完成后，需要延迟设定的延迟时间，才会执行新的任务
*/
public static void executeFixedDelay() {  
	ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);  
	executor.scheduleWithFixedDelay(  
	            new MyHandle(),  
	            0,  
	            2000,  
	            TimeUnit.MILLISECONDS);  
}
```

间隔指的是连续上次执行完成和下次开始执行之间的间隔。

###### 周期定时执行某个任务

周期性的执行一个任务，可以使用下面方法设定每天在固定时间执行一次任务。

```java
/**
* 每天晚上 9 点执行一次
* 每天定时安排任务进行执行
*/
public static void executeEightAtNightPerDay(){
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);  
	long oneDay = 24 * 60 * 60 * 1000;  
	long initDelay  = getTimeMillis("21:00:00") - System.currentTimeMillis();  
	initDelay = initDelay > 0 ? initDelay : oneDay + initDelay;  
	executor.scheduleAtFixedRate(  
		new MyHandle(),  
		initDelay,  
		oneDay,  
		TimeUnit.MILLISECONDS);
}

/** 
* 获取指定时间对应的毫秒数 
* @param time "HH:mm:ss" 
* @return 
*/  
private static long getTimeMillis(String time) {  
	try {  
		DateFormat dateFormat = new SimpleDateFormat("yy-MM-dd HH:mm:ss");  
		DateFormat dayFormat = new SimpleDateFormat("yy-MM-dd");  
		Date curDate = dateFormat.parse(dayFormat.format(new Date()) + " " + time);  
		return curDate.getTime();  
	} catch (ParseException e) {  
		e.printStackTrace();  
	}  
	return 0;  
}
```

### 方法

#### execute

```java
public void execute(Runnable r)
```

表示往线程池添加线程，有可能会立即运行，也有可能不会。无法预知线程何时开始，何时结束。

#### submit

将线程放入线程池中，除了使用execute，也可以使用submit。submit的方法很适应于生产者-消费者模式，通过和Future结合一起使用，可以起到如果线程没有返回结果，就阻塞当前线程等待线程 池结果返回。

```java
<T> Future<T> submit(Callable<T> )

Future<?> submit(Runnable task)

<T> Future<T> submit(Runnable task,T result)
```

##### Runnable



##### Callable

```java
public interface Callable<V>{
    /**
    * Computes a result, or throws an exception if unable to do so.
    * 
    * @return computed result
    * @throws Exception if unable to compute a result
    */
    V call() throws Exception;
}
```

##### Future（本身也是一种设计模式）

```java
public interface Future<V>{
    //试图取消对此任务的执行，如果任务已完成，或已取消，或者由于某些其他原因而无法取消，则此尝试将失败，
    //当调用cancel时，如果调用成功，而此任务尚未启动，则此任务将永不运行，如果任务已经启动，
    //则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程，
    //此方法返回后，对 isDone() 的后续调用将始终返回 true,如果此方法返回 true，则对 
    //isCancelled() 的后续调用将始终返回 true
    boolean cancel(boolean mayInterruptIfRunning);
    
    //如果在任务正常完成前将其取消，则返回 true
    boolean isCancelled();
    
    //如果任务已完成，则返回 true，可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true
    boolean isDone();
    
    //等待线程结果返回，会阻塞
    V get() throws InterruptedException,ExecutionException;
    
    //设置超时时间
    V get(long timeout,TimeUnit unit) throws InterruptedException,ExecutionException,TimeoutException;
}
```

###### 示例

```java
public class FutureTest{
    public static void main(String[] args){
        ExecutorService executor = Executors.newCachedThreadPool();
        HandleCallable task1 = new HandleCallable("1");
        HandleCallable task2 = new HandleCallable("2");
        
        Future<Integer> result1 = executor.submit(task1);
        Future<Integer> result2 = executor.submit(task2);
        
        executor.shutdown();
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){
            
        }
        try{
            System.out.println("task1 运行结果："+result1.get());
            Systen.out.println("task2 运行结果："+result2.get());
        }catch(InterruptedException e){
            
        }
        
    }
}

class HandleCallable implements Callable<Integer>{
    private String name;
    public HandleCallable(String name){
        this.name = name;
    }
    
    @Override
    public Integer call() throws Exception{
        System.out.println("task"+name+" 开始运行....");
        Thread.sleep(3000);
        int sum = new Random().nextInt(300);
        int result = 0;
        for(int i =0;i<sum;i++){
            result += i;
        }
        return result; 
    }
}
```

##### FutureTask

```java
public interface RunnableFuture<V> extends Runnable,Future<V>{}
```

```java
public class FutureTask<V> implements RunnableFuture<V>{
    //真正用来执行线程的类
    private final Sync sync;
    
    //构造方法1，从Callable来创建 FutureTask
    public FutureTask(Callable<V> callable){
        if(callable == null){
            throw new NullPointerException();
        }
        sync = new Sync(callable);
    }
    
    //构造方法2，从Runnable来创建FutureTask,V就是线程执行返回结果
    public FutureTask(Runnable runnable,V result){
        sync = new Sync(Executors.callable(runnable,result));
    }
    
    //和Future一样
    public boolean isCancelled(){
        return sync.innerIsCancelled();
    }
    
    //和Future一样
    public boolean isDone(){
        return sync.innerIsDone();
    }
    
    //和Future一样
    public boolean cancel(boolean mayInterruptIfRunning){
        return sync.innerCancel(mayInterruptIfRunning);
    }
    
    //和Future一样
    public V get() throws InterruptedException,ExecutionException{
        return sync.innerGet();
    }
    
    //和Future一样
    public V get(long timeout,TimeUnit unit) throws InterruptedException,ExecutionException,TimeoutException{
            return sync.innerGet(unit.toNanos(timeout));
    }

	//线程结束后的操作
	protected void done(){}

	//设置结果
	protected void set(V v){
        sync.innerSet(v);
    }

	//设置异常
	protected void setException(Throwable t){
        sync.innerRun();
    }
	
	//重置
	protected boolean runAndReset(){
        return sync.innerRunAndReset();
    }
	
	//这个类才是真正执行、关闭线程的类
    private final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = -7828117401763700385L;
        //线程运行状态
        private static final int RUNNING   = 1;
        private static final int RAN       = 2;
        private static final int CANCELLED = 4;
 
        
        private final Callable<V> callable;
        private V result;
        private Throwable exception;
 
        //线程实例
        private volatile Thread runner;
        //构造函数
        Sync(Callable<V> callable) {
            this.callable = callable;
        }
    ....
    }
}
```

FutureTask类是Future 的一个实现，并实现了Runnable，所以可通过Excutor(线程池) 来执行,也可传递给Thread对象执行。如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。 Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时的计算。一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。FutureTask类既可以使用new Thread(Runnable r)放到一个新线程中跑，也可以使用ExecutorService.submit(Runnable r)放到线程池中跑，而且两种方式都可以获取返回结果，但实质是一样的，即如果要有返回结果那么构造函数一定要注入一个Callable对象。

###### 示例

Thread

```java
public class FutureTaskTest{
    public static void main(String[] args){
        //采用直接启动线程的方法
        MyTask task1 = new MyTask("1");
        FutureTask<Integer> result1 = new FutureTask<Integer>(task1);
        Thread thread1 = new Thread(result1);
        thread1.start();
        
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        
        try{
            System.out.println("task1 返回结果："+result.get());
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
}

public MyTask implements Callable<Integer>{
    private String name;
    
    public MyTask(String name){
        this.name = name;
    }
    
    @Override
    public Integer call() throws Exception{
        Thread.sleep(3000);
        int sum = new Random().nextInt(300);
        int result = 0;
        for(int i=0;i<sum;i++){
            result += i;
        }
        return result;
    }
}
```

通过线程池来启动线程

```java
public class FutureTask2{
    public static void main(String[] args){
        ExecutorService executor = Executors.newCachedThreadPool();
        MyTask2 task = new MyTask2("1");
        Future<Integer> result1 = executor.submit(task);
        executor.shutdown();
        try{
            Thread.sleep(1000);
        }catch(Exception e){
            e.printStackTrace();
        }
        try{
            System.out.println("task 返回结果："+result.get());
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}

class MyTask2 implements Callable<Integer>{
    private String name;
    
    public MyTask2(String name){
        this.name = name;
    }
    
    @Override
    public Integer call() throws Exception{
        System.out.println("task"+ name + "开始进行计算");
		Thread.sleep(3000);
		int sum = new Random().nextInt(300);
		int result = 0;
		for (int i = 0; i < sum; i++)
			result += i;
		return result;
    }
}
```

##### CompletionService

###### 原理

将一组线程的执行结果放入一个BlockQueueing 当中。这里线程的执行结果放入到 Blockqueue 的顺序只和这个线程的执行时间有关。和它们的启动顺序无关。无需自己去写很多判断哪个线程是否执行完成，它已经做了处理。

###### 源码

```java
package java.util.concurrent;

public interface CompletionService<V>{
    //提交线程任务
    Future<V> submit(Callable<V> task);
    
    //提交线程任务
    Future<V> submit(Runnable task,V result);
    
    //阻塞等待
    Future<V> take() throws InterruptedException;
    
    //非阻塞等待
    Future<V> poll();
    
    //带时间的非阻塞等待
    Future<V> poll(long timeout,TimeUnit unit) throws InterruptedException;
}
```

###### 源码接口实现类

```java
package java.util.concurrent;
 
public class ExecutorCompletionService<V> implements CompletionService<V> {
    private final Executor executor;	//线程池类
    private final AbstractExecutorService aes;
    //存放线程执行结果的阻塞队列
    private final BlockingQueue<Future<V>> completionQueue;

    //内部封装的一个用来执线程的FutureTask
    private class QueueingFuture extends FutureTask<Void> {
        QueueingFuture(RunnableFuture<V> task) {
            super(task, null);
            this.task = task;
        }
        //线程执行完成后调用此函数将结果放入阻塞队列
        protected void done() { completionQueue.add(task); }
        private final Future<V> task;
    }
 
    private RunnableFuture<V> newTaskFor(Callable<V> task) {
        if (aes == null)
            return new FutureTask<V>(task);
        else
            return aes.newTaskFor(task);
    }
 
    private RunnableFuture<V> newTaskFor(Runnable task, V result) {
        if (aes == null)
            return new FutureTask<V>(task, result);
        else
            return aes.newTaskFor(task, result);
    }
 
    //构造函数，这里一般传入一个线程池对象executor的实现类
    public ExecutorCompletionService(Executor executor) {
        if (executor == null)
            throw new NullPointerException();
        this.executor = executor;
        this.aes = (executor instanceof AbstractExecutorService) ?
            (AbstractExecutorService) executor : null;
        //默认的是链表阻塞队列
        this.completionQueue = new LinkedBlockingQueue<Future<V>>();
    }
 
    //构造函数，可以自己设定阻塞队列
    public ExecutorCompletionService(Executor executor,
                                     BlockingQueue<Future<V>> completionQueue) {
        if (executor == null || completionQueue == null)
            throw new NullPointerException();
        this.executor = executor;
        this.aes = (executor instanceof AbstractExecutorService) ?
            (AbstractExecutorService) executor : null;
        this.completionQueue = completionQueue;
    }
    
    //提交线程任务，其实最终还是executor去提交
    public Future<V> submit(Callable<V> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<V> f = newTaskFor(task);
        executor.execute(new QueueingFuture(f));
        return f;
    }
    
    //提交线程任务，其实最终还是executor去提交
    public Future<V> submit(Runnable task, V result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<V> f = newTaskFor(task, result);
        executor.execute(new QueueingFuture(f));
        return f;
    }
 
    public Future<V> take() throws InterruptedException {
        return completionQueue.take();
    }
 
    public Future<V> poll() {
        return completionQueue.poll();
    }
 
    public Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException {
        return completionQueue.poll(timeout, unit);
    }
 
}
```

每次有线程执行完成后往阻塞队列添加一个Future。

###### 示例1（自定义一个Callable）

自定义一个 Callable（**自定义---循环获取结果实现**）

```java
class HandleFuture<Integer> implements Callable<Integer>{
    private Integer num;
    
    public HandleFuture(Integer num){
        this.num = num;
    }
    @Override
    public Integer call() throws Exception{
        Thread.sleep(3*100);
        System.out.println(Thread.currentThread().getName());
        return num;
    }
}
```

```java
public static void FutureTest() throws InterruptedException, ExecutionException {
	ExecutorService executor = Executors.newCachedThreadPool();
	List<Future<Integer>> result = new ArrayList<Future<Integer>>();
	for (int i = 0;i<10;i++) {
		Future<Integer> submit = executor.submit(new HandleFuture(i));
		result.add(submit);
	}
	executor.shutdown();
	for (int i = 0;i<10;i++) {//一个一个等待返回结果
		System.out.println("返回结果："+result.get(i).get());
	}
}
```

**弊端：**

只能一个一个阻塞的取出。这中间肯定会浪费一定的时间在等待上。如7返回了。但是前面1-6都没有返回。那么7就得等1-6输出才能输出。

###### 示例2 （CompletionService）

```java
public static void CompleTest() throws InterruptedException,ExecutionException{
    ExecutorService executor = Executors.newCachedThreadPool();
    //构建完成服务
    CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(executor);
    for(int i=0;i<10;i++){
        completionService.submit(new HandleFuture(i));
    }
    for(int i=0;i<10;i++){	//一个一个等待返回结果
        System.out.println("返回结果："+completionService.take().get());
    }
}
```

**说明：**

结果的输出和线程的放入顺序无关系。每一个线程执行成功后，立刻就输出。

##### execute 与 submit 的区别

###### execute

1. 只能提交一个Runnable 对象
2. 返回值为 void
3. 异常无法获取，需要主动通过ThreadFactory 设置线程的异常处理

###### submit

-  <T> Future<T> submit(Callback<T> task)
  1. 提交一个实现了Callable 接口的对象
  2. 返回线程执行结果，通过 Future 的get() 方法；执行异常时，get() 会获取到异常的额信息
- Future<?> submit(Runnable task)
  1. 提交一个实现了 Callable，也可以提交一个 Runnable 接口的对象
  2. get：调用成功，返回null；执行异常，返回异常信息
- <T> Future<T> submit(Runnable task,T result)
  1. 提交一个实现了 Callable，也可以提交一个 Runnable 接口的对象
  2. get：正常结束时，返回 result 对象；抛出异常时，会获取到对应的异常信息

#### shutdown

```java
shutdown()
```

通常放在 execute 后面，如果调用了这个方法。

- 表明当前线程池已不再接收新添加的线程，新添加的线程会被拒绝执行。
- 表明当所有线程执行完毕时，回收线程池的资源。

###### 注意

不会马上关闭线程池

#### shutdownNow()

不管当前有没有线程在执行，马上关闭线程池！这个方法要小心使用，要不可能会引起系统数据异常。

### Java线程池源码

#### 继承关系

![](.\png\java-线程池源码-继承关系图.png)

#### 源码

##### newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}
```

##### newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
}
```

##### newSingleThreadExecutor

```java
public static ExecutorServicee newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()));
}
```

##### ThreadPoolExecutor

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
 
    //运行状态标志位
    volatile int runState;
    static final int RUNNING    = 0;
    static final int SHUTDOWN   = 1;
    static final int STOP       = 2;
    static final int TERMINATED = 3;
 
    //线程缓冲队列，当线程池线程运行超过一定线程时并满足一定的条件，待运行的线程会放入到这个队列
    private final BlockingQueue<Runnable> workQueue;
    //重入锁，更新核心线程池大小、最大线程池大小时要加锁
    private final ReentrantLock mainLock = new ReentrantLock();
    //重入锁状态
    private final Condition termination = mainLock.newCondition();
    //工作都set集合
    private final HashSet<Worker> workers = new HashSet<Worker>();
    //线程执行完成后在线程池中的缓存时间
    private volatile long  keepAliveTime;
    //核心线程池大小 
    private volatile int   corePoolSize;
    //最大线程池大小 
    private volatile int   maximumPoolSize;
    //当前线程池在运行线程大小 
    private volatile int   poolSize;
    //当缓冲队列也放不下线程时的拒绝策略
    private volatile RejectedExecutionHandler handler;
    //线程工厂，用来创建线程
    private volatile ThreadFactory threadFactory;   
    //用来记录线程池中曾经出现过的最大线程数
    private int largestPoolSize;   
   //用来记录已经执行完毕的任务个数
   private long completedTaskCount;   
 
    ................
}
```

###### 初始化线程池大小

```java
ThreadPoolExecutor(int,int,long,TimeUnit,BlockingQueue<Runnable>)

ThreadPoolExecutor(int,int,long,TimeUnit,BlockingQueue<Runnable>,ThreadFactory)
    
ThreadPoolExecutor(int,int,long,TimeUnit,BlockingQueue<Runnable>,RejectedExecutionHandler)
    
ThreadPoolExecutor(int,int,long,TimeUnit,BlockingQueue<Runnable>,ThreadFactory,RejectedExecutionHandler)
```

###### Block Queue

- ArrayBlockingQueue

  有界的数组队列

- LinkedBlockingQueue

  可支持有界/无界的队列，使用链表实现

- PriorityBlockingQueue

  优先队列，可以针对任务排序

- SynchronousQueue

  队列长度为1的队列，和Array有点区别就是：client thread 提交到 block queue 会是一个阻塞过程，直到有一个worker thread 链接上来 poll task。

###### 任务拒绝策略

当线程的任务缓存队列已满并且线程池的数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：

- ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常
- ThreadPoolExecutor.DiscaedPolicy：也是丢弃任务，但是不抛出异常
- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

```java
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 3,TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(3),Executors.defaultThreadFactory(),new ThreadPoolExecutor.DiscardOldestPolicy());
```

核心线程数为2，最大线程数为4，线程缓存时间为3秒，缓冲队列的容量设置为3。线程工厂设置为默认

### 线程池任务拒绝策略

RejectedExecutionHandler 提供了四种方式来处理任务拒绝策略。

![](.\png\java-线程池拒绝策略.png)

#### 类图

![](.\png\java-线程池拒绝策略-类图.png)

#### 使用

```java
ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(1));
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
```

### 线程池捕获异常

默认情况下，线程池 java.util.concurrent.ThreadPoolExecutor 会Catch住所有异常， 当任务执行完成(java.util.concurrent.ExecutorService.submit(Callable))获取其结果 时(java.util.concurrent.Future.get())会抛出此RuntimeException。

```java
V get() throws InterruptedException,ExecutionException;
```

其中 ExecutionException 异常即是java.lang.Runnable 或者 java.util.concurrent.Callable 抛出的异常。

也就是说，线程池在执行任务时捕获了所有异常，并将此异常加入结果中。这样一来线程池中的所有线程都将无法捕获到抛出的异常。 从而无法通过设置线程的默认捕获方法拦截的错误异常。

也不同通过自定义线程来完成异常的拦截。



好在java.util.concurrent.ThreadPoolExecutor 预留了一个方法，运行在任务执行完毕进行扩展（当然也预留一个protected方法beforeExecute(Thread t, Runnable r)）：

```java
protected void afterExecute(Runnable r,Throwable t){}
```

此方法的默认实现为空，这样我们就可以通过继承或者覆盖ThreadPoolExecutor 来达到自定义的错误处理。

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(11, 100, 1, TimeUnit.MINUTES, //
        new ArrayBlockingQueue<Runnable>(10000),//
        new DefaultThreadFactory()) {

    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        printException(r, t);
    }
};

private static void printException(Runnable r, Throwable t) {
    if (t == null && r instanceof Future<?>) {
        try {
            Future<?> future = (Future<?>) r;
            if (future.isDone())
                future.get();
        } catch (CancellationException ce) {
            t = ce;
        } catch (ExecutionException ee) {
            t = ee.getCause();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt(); // ignore/reset
        }
    }
    if (t != null)
        log.error(t.getMessage(), t);
}
```

此办法的关键在于，事实上 afterExecute 并不会总是抛出异常 Throwable t，通过查看源码得知，异常是封装在此时的Future对象中的， 而此Future对象其实是一个java.util.concurrent.FutureTask的实现，默认的run方法其实调用的 java.util.concurrent.FutureTask.Sync.innerRun()。

```java
void innerRun() {
    if (!compareAndSetState(0, RUNNING))
        return;
    try {
        runner = Thread.currentThread();
        if (getState() == RUNNING) // recheck after setting thread
            innerSet(callable.call());
        else
            releaseShared(0); // cancel
    } catch (Throwable ex) {
        innerSetException(ex);
    }
}

void innerSetException(Throwable t) {
    for (;;) {
        int s = getState();
        if (s == RAN)
            return;
        if (s == CANCELLED) {
            // aggressively release to set runner to null,
            // in case we are racing with a cancel request
            // that will try to interrupt runner
            releaseShared(0);
            return;
        }
        if (compareAndSetState(s, RAN)) {
            exception = t;
            result = null;
            releaseShared(0);
            done();
            return;
        }
    }
}
```

这里我们可以看到它吃掉了异常，将异常存储在java.util.concurrent.FutureTask.Sync的exception字段中：

```java
/** The exception to throw from get() */
private Throwable exception;
```

当我们获取异步执行的结果时， java.util.concurrent.FutureTask.get()

```java
public V get() throws InterruptedException, ExecutionException {
    return sync.innerGet();
}
```

java.util.concurrent.FutureTask.Sync.innerGet()

```java
V innerGet() throws InterruptedException, ExecutionException {
    acquireSharedInterruptibly(0);
    if (getState() == CANCELLED)
        throw new CancellationException();
    if (exception != null)
        throw new ExecutionException(exception);
    return result;
}
```

异常就会被包装成ExecutionException异常抛出。

也就是说当我们想线程池 ThreadPoolExecutor(java.util.concurrent.ExecutorService)提交任务时， 如果不理会任务结果（Feture.get()），那么此异常将被线程池吃掉。

```java
<T> Future<T> submit(Callable<T> task);
Future<?> submit(Runnable task);
```

而java.util.concurrent.ScheduledThreadPoolExecutor是继承ThreadPoolExecutor的，因此情况类似。

结论，通过覆盖ThreadPoolExecutor.afterExecute 方法，我们才能捕获到任务的异常（RuntimeException）。

## 线程组

Java提供 ThreadGroup 类来组织线程。ThreadGroup 对象可以由 Thread 对象组成和由另外的 ThreadGroup 对象组成，生成线程树结构。

![](.\png\java线程组.png)

### 概念

线程组 ThreadGroup 表示一组线程的集合，一旦一个线程归属到一个线程组之中后，就不能再更换其所在的线程组。

### ThreadGroup

```java
public class ThreadGroup extends Object implements Thread.UncaughtExceptionHandler{
    private final ThreadGroup parent;
    String name;
    int maxPriority;
    boolean destroyed;	//是否被销毁
    boolean daemon;		//是否守护线程
    boolean vmAllowSuspension;	//是否可以中断
    
    int nUnstartedThreads = 0;	//还未启动的线程
    int nthreads;	//ThreadGroup中线程数目
    Thread threads[];	//ThreadGroup中的线程
    
    int ngroups;	//线程组数目
    ThreadGroup groups[];	//线程组数组
    
    
    //私有构造函数
    private ThreadGroup(){
        this.name = "system";
        this.maxPriority = Thread.MAX_PRIORITY;
        this.parent = null;
    }
    
    //默认是以当前ThreadGroup 传入作为 parent ThreadGroup,新线程组的父线程组是目前正在运行线程的线程粗
    public ThreadGroup(String name){
        this(Thread.currentThread().getThreadGroup(),name);
    }
    
    //构造函数
    public ThreadGroup(ThreadGroup parent,String name){
        this(checkParentAccess(parent),parent,name);
    }
    
    //私有构造函数
    private ThreadGroup(Void unused,ThreadGroup parent,String name){
        this.name = name;
        this.maxPriority = parent.maxPriority;
        this.daemon = parent.daemon;
        this.vmAllowSuspension = parent.vmAllowSuspension;
        this.parent = parent;
        parent.add(this);
    }
    
}
```

```java
public static interface Thread.UncaughtExceptionHandler{
    //用于处理线程发生的未处理异常
    void uncaughtException(Thread t,Throwable e);
}
```

### 作用

ThreadGroup是为了方便线程管理出现的，可以统一设置一些属性,设置统一的安全策略等等，也可以通过线程组的方便获取一些信息。

### 特性

- 用户创建的所有线程都属于指定线程组，如果没有显示指定线程属于哪个线程组，则该线程属于默认线程组（与其父线程处于同一个线程组），没有指定线程组，那么自动归到当前线程所属的线程组中。
- 一旦某个线程加入了指定线程组之后，该线程将一直属于该线程组，直到线程死亡，线程运行中途不能改变它所属的线程组

### 特别说明

线程必须启动后才能归到指定线程组中。

### 方法

#### 构造方法

1. ThreadGroup(String name);

   以指定的线程组名字来创建新的线程组

2. ThreadGroup(ThreadGroup parent,String name);

   以指定的名字、指定的父线程组创建一个新的线程组

#### 线程加入线程组

1.  Thread(ThreadGroup group,Runnable target)

   以 target 的run() 方法为线程执行体创建新线程，属于 group 线程组

2. Thread(ThreadGroup group,Runnable target,String name)

   为上面线程指定了名字

3. Thread(ThreadGroup group,Runnable target,String name,long stackSize)

   

4. Thread(ThreadGroup group,String name)

   创建新线程，名字为 name，属于 group 线程组

#### 常见方法

1.  getThreadGroup

   ThreadGroup getThreadGroup()，返回该线程所属的线程组

2. getName

   String getName()，返回该线程组的名字

3. activeCount

   int activeCount()，返回此线程组中活动线程的数目

4. interrupt

   void interrupt()，中断此线程组中所有的线程

5. isDaemon

   boolean isDaemon()，返回此线程组是否为后台线程组

6. setDaemon

   void setDaemon(boolean daemon)，设置给线程组是后台线程组

7. setMaxpriority

   void setMaxpriority(int pri)，设置线程组的最高优先级

8. uncaughtException

   该方法是对 Thread.UncaughtExceptionHandler 接口里的方法实现

   void uncaughtException(Thread t,Throwable e)，处理该线程组组内的任意线程 t 抛出的未处理异常。 t 代表出现异常的线程， e 代表该线程抛出的异常。

#### 根线程组

```java
public static void main(String[] args){
    System.out.println(Thread.currentThread().getThreadGroup().getParent().getName());
    System.out.println(Thread.currentThread().getThreadGroup().getParent().getParent().getName());
}
```

**运行结果：**

```shell
system
Exception in thread "main" java.lang.NullPointerException
	at xxx.TestMain.main(TestMain.java:11)
```

##### 结论

1. 根线程组就是系统线程组 system
2. 抛空指针异常是因为系统线程组上已经没有线程组了，所以 system 的 getParent() 方法返回的是 null，对null 调用 getName() 方法自然是 NullPointerException

##### 源码

```java
/**
* Creates an empty Thread group that is not in any Thread group.
* This method is used to create the system Thread group.
*/
private ThreadGroup(){	// called from C code  C代码调用，用于构建系统线程组
    this.name = "system";
    this.maxPriority = Thread.MAX_PRIORITY;
}
```

### 示例

#### 一级关联

1 级关联就是父对象中有子对象，但并不创建孙对象。

```java
public class MyThread implements Runnable
{
    public void run()
    {
        try
        {
            while (!Thread.currentThread().isInterrupted())
            {
                System.out.println("ThreadName = " + Thread.currentThread().getName());
                Thread.sleep(3000);
            }
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}
```

```java
public static void main(String[] args)
{
    MyThread mt0 = new MyThread();
    MyThread mt1 = new MyThread();
    ThreadGroup tg = new ThreadGroup("新建线程组1");
    Thread t0 = new Thread(tg, mt0);
    Thread t1 = new Thread(tg, mt1);
    t0.start();
    t1.start();
    System.out.println("活动的线程数为：" + tg.activeCount());
    System.out.println("线程组的名称为：" + tg.getName());
}
```

**运行结果**

```shell
活动的线程数为：2
ThreadName = Thread-1
ThreadName = Thread-0
线程组的名称为：新建线程组1
ThreadName = Thread-1
ThreadName = Thread-0
ThreadName = Thread-1
ThreadName = Thread-0
ThreadName = Thread-1
ThreadName = Thread-0
...
```

#### 多级关联

多级关联就是父对象中有子对象，子对象中再创建子对象也就出现了子孙的效果。

- ThreadGroup(String name)

  构造一个新线程组

- ThreadGroup(ThreadGroup parent,String name)

  创建一个新线程组

使用多级关联一般就是用第二个构造函数。第一个参数表示新线程组的父线程组，第二个参数表示新线程组的名称，有了父线程组和新线程组的名称，自然可以构造出一个新的线程组来。当然用第一个构造方法也是可以的。



#### 复制线程组

##### 源码

```java
//此线程组及其子组中的所有活动线程复制到指定数组中。
public int enumerate(ThreadGroup list[]) {
	checkAccess();
	return enumerate(list, 0, true);
}

//此线程组及其子组中的所有活动线程复制到指定数组中。
public int enumerate(ThreadGroup list[], boolean recurse) {
	checkAccess();
	return enumerate(list, 0, recurse);
}
    
//此线程组中的所有活动线程复制到指定数组中。如果 recurse 标志为 true，则还包括对此线程的子组中的所有活动线程的引用。
//如果数组太小而无法保持所有线程，则忽略额外的线程。
private int enumerate(ThreadGroup list[], int n, boolean recurse) {
	int ngroupsSnapshot = 0;
	ThreadGroup[] groupsSnapshot = null;
	synchronized (this) {
		if (destroyed) {
			return 0;
		}
		int ng = ngroups;
		if (ng > list.length - n) {//防止list放不下线程数目
			ng = list.length - n;
        }
        if (ng > 0) {
			System.arraycopy(groups, 0, list, n, ng);//复制线程组
			n += ng;
        }
        if (recurse) { //取得其子组
			ngroupsSnapshot = ngroups;
			if (groups != null) {
				groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
			} else {
				groupsSnapshot = null;
			}
		}
	}
    if (recurse) {//复制子组
		for (int i = 0 ; i < ngroupsSnapshot ; i++) {
			n = groupsSnapshot[i].enumerate(list, n, true);
		}
    }
    return n;
}
```

##### 实例

```java
//复制 group 里面的 thread 信息
Thread[] threads = new Thread[threadGroup.activeCount()];
threadGroup.enumerate(threads);
```

activeCount 很明显就是取得活动的线程。默认情况下，连同其子线程组也会进行复制。

#### 批量停止组内线程

```java
public class MyThread extends Thread
{
    public MyThread(ThreadGroup tg, String name)
    {
        super(tg, name);
    }
    
    public void run()
    {
        System.out.println("ThreadName = " + Thread.currentThread().getName() + 
                "准备开始循环了");
        while (!this.isInterrupted()){}
        System.out.println("ThreadName = " + Thread.currentThread().getName() + 
                "结束了");
    }
}
```

开3个线程

```java
public static void main(String[] args) throws InterruptedException{
    ThreadGroup tg = new ThreadGroup("我的线程组");
    MyThread mt = null;
    for(int i=0;i<3;i++){
        mt = new MyThread(tg,"线程"+i);
        mt.start();
    }
    Thread.sleep(5000);
    tg.interrupt();
    System.out.println("调用了 interrupt 方法");
}
```

调用 ThreadGroup 中的 interrupt() 方法批量中断了线程组内的线程。

#### 未捕获异常的处理

##### 源码

```java
public void uncaughtException(Thread t,Throwable e){
    if(parent !=null){
        parent.uncaughtException(t,e);
    }else{
        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();
        if(ueh != null){
            ueh.uncaughtException(t,e);
        }else if(!(e instanceof ThreadDeath)){
            System.err.print("Exception in thread \""+t.getName()+"\" ");
            e.printStackTrace(System.err);
        }
    }
}
```

如果父线程不存在，则调用它的 uncaughtException 方法，如果父线程组不存在，但指定了默认处理器，则调用默认的处理器，如果默认的处理器没有设置，则写错误日志。但如果 exception 是 ThreadDeath 实例的话，忽略。

##### 落实到各线程捕获异常

```java
//自定义异常处理器
class MyExHandler implements Thread.UncaughtExceptionHandler{
    //实现 uncaughtException 方法，该方法将处理线程的未处理异常
    public void uncaughtException(Thread t,Throwable e){
        System.out.println(t +"线程出现了异常："+e);
    }
}

//程序没有正常结束，说明该处理器处理完异常后还是把异常传给其调用者（JVM）
public class ExHandler{
    public static void main(String[] args){
        //设置主线程的异常处理
        Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler());
        int a = 5/0;
        System.out.println("程序正常结束！");
    }
}
```



##### 统一异常处理

```java
public class ThreadGroupDemo{
    public static void main(String[] args){
        ThreadGroup threadGroup1 = new ThreadGroup("group1"){
          	//继承ThreadGroup 并重新定义以下方法
          	//在线程成员抛出 unchecked exception
            //会执行此方法
            public void uncaughtException(Thread t,Throwable e){
                System.out.println(t.getName()+":"+e.getMessage());
            }
        };
        
        Thread thread1 = new Thread(threadGroup1,new Runnable(){
            public void run(){
                //抛出 unchecked 异常
                throw new RuntimeException("测试异常");
            }
        });
        
        thread1.start();
    }
}
```

##### 模拟搜索

10个随机时间休眠的线程，然后当其中一个完成，就中断其余的。

```java
public class Result{
    private String name;
    
    public void setName(String name){
    	this.name = name;    
    }
    
   	public String getName(){
        return name;
    }
}
```



```java
public class SearchTask implements Runnable{
    private Result result;
    public SearchTask(Result result){
        this.result = result;
    }
    
    @Override
    public void run(){
        String name = Thread.currentThread().getName();
        System.out.printf("Thread %s: Start\n",name);
        try{
            doTask();
            result.setName(name);
        }catch(InterruptedException e){
            System.out.printf("Thread %s: Interrupted\n",name);
            return;
        }
        System.out.printf("Thread %s:End\n",name);
    }
    
    private void doTask() throws InterruptedException{
        Random random = new Random((new Date()).getTime());
        int value = (int)(random.nextDouble() * 100);
        System.out.printf("Thread %s: %d\n",Thread.currentThread().getName(),value);
        TimeUnit.SECONDS.sleep(value);
    }
}
```



```java
public class Main{
    public static void main(String[] args){
        ThreadGroup threadGroup = new ThreadGroup("Searcher");
        Result result = new Result();
        SearchTask searchTask = new SearchTask(result);
        
        for(int i=0;i<10;i++){
            Thread thread = new Thread(threadGroup,searchTask);
            thread.start();
            try{
                TimeUnit.SECONDS.sleep(1);
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        
        System.out.printf("Number of Threads:%d\n",threadGroup.activeCount());
        System.out.printf("Information about the Thread Group\n");
        threadGroup.list();
        
        Thread[] threads = new Thread[threadGroup.activeCount()];
        threadGroup.enumrate(threads);
        for(int i=0;i<threadGroup.activeCount();i++){
            System.out.printf("Thread %s:%s\n",threads[i].getName(),threads[i].getState());
        }
        
        waitFinish(threadGroup);
        
        threadGroup.interrupt();
    }
    
    private static void waitFinish(ThreadGroup threadGroup){
        while(threadGroup.activeCount() >9){
            try{
                TimeUnit.SECONDS.sleep(1);
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
```



## 关键字

### synchronized

#### 对象锁、类锁和私有锁

见 Java锁模块中的 《锁对象、类锁、私有锁》

#### 特性

- 执行控制问题

- 创建内存屏障，保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性。

- 可重入性

  当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。

  当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。

#### 使用场景

##### 方法

###### 实例方法

锁住的对象

​		**类的实例对象**

伪代码

```java
//实例方法，锁住的是该类的一个实例对象
public synchronized void method(){
    .......
}
```

###### 静态方法

锁住的对象

​		**类对象**

伪代码

```java
//静态方法，锁住的是类对象
public static synchronized void method(){
    .......
}
```

##### 代码块

###### 实例对象

锁住的对象

​		**类的实例对象**

伪代码

```java
//同步代码块，锁住的是该类的实例对象
synchronized(this){
    ......
}
```

###### class对象

锁住的对象

​		**类对象**

伪代码

```java
//同步代码块，锁住的是该类的类对象
synchronized(SynchronizedDemo.class){
    .......
}
```

###### 任意实例对象Object

锁住的对象

​		**实例对象Object**

伪代码

```java
//同步代码块，锁住的是配置的实例的对象
//String 对象作为锁
String lock ="";
synchronized(lock){
    ......
}
```

##### 示例

```java
/**
  * 先定义一个测试模板类
  *     这里补充一个知识点：Thread.sleep(long)不会释放锁
  *     读者可参见笔者的`并发番@Thread一文通`
  */ 
public class SynchronizedDemo {
    public static synchronized void staticMethod(){
        System.out.println(Thread.currentThread().getName() + "访问了静态同步方法staticMethod");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "结束访问静态同步方法staticMethod");
    }
    public static void staticMethod2(){
        System.out.println(Thread.currentThread().getName() + "访问了静态同步方法staticMethod2");
        synchronized (SynchronizedDemo.class){
            System.out.println(Thread.currentThread().getName() + "在staticMethod2方法中获取了SynchronizedDemo.class");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public synchronized void synMethod(){
        System.out.println(Thread.currentThread().getName() + "访问了同步方法synMethod");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "结束访问同步方法synMethod");
    }
    public synchronized void synMethod2(){
        System.out.println(Thread.currentThread().getName() + "访问了同步方法synMethod2");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "结束访问同步方法synMethod2");
    }
    public void method(){
        System.out.println(Thread.currentThread().getName() + "访问了普通方法method");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "结束访问普通方法method");
    }
    private Object lock = new Object();
    public void chunkMethod(){
        System.out.println(Thread.currentThread().getName() + "访问了chunkMethod方法");
        synchronized (lock){
            System.out.println(Thread.currentThread().getName() + "在chunkMethod方法中获取了lock");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void chunkMethod2(){
        System.out.println(Thread.currentThread().getName() + "访问了chunkMethod2方法");
        synchronized (lock){
            System.out.println(Thread.currentThread().getName() + "在chunkMethod2方法中获取了lock");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void chunkMethod3(){
        System.out.println(Thread.currentThread().getName() + "访问了chunkMethod3方法");
        //同步代码块
        synchronized (this){
            System.out.println(Thread.currentThread().getName() + "在chunkMethod3方法中获取了this");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void stringMethod(String lock){
        synchronized (lock){
            while (true){
                System.out.println(Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

#### 特殊说明

##### 普通方法与同步方法调用互不关联

###### 当一个线程进入同步方法时，其他线程可以正常访问其他非同步方法

```java
public static void main(String[] args){
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(){
        @Override
        public void run(){
            //调用普通方法
            synDemo.method();
        }
    };
    Thread thread2 = new Thread(){
        @Override
        public void run(){
            //调用同步方法
            synDemo.synMethod();
        }
    };
    thread1.start();
    thread2.start();
}

输出：
Thread-1 访问了同步方法 synMethod
Thread-0 访问了普通方法method
Thread-0结束访问普通方法method
Thread-1结束访问同步方法synMethod
//分析：通过结果可知，普通方法和同步方法是非阻塞执行的
```

##### 所有同步方法只能被一个线程访问

###### 当一个线程执行同步方法时，其他线程不能访问任何同步方法

```java
public static void main(String[] args) {
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> {
        synDemo.synMethod();
        synDemo.synMethod2();
    });
    Thread thread2 = new Thread(() -> {
        synDemo.synMethod2();
        synDemo.synMethod();
    });
    thread1.start();
    thread2.start();
}
---------------------
//输出：
Thread-0访问了同步方法synMethod
Thread-0结束访问同步方法synMethod
Thread-0访问了同步方法synMethod2
Thread-0结束访问同步方法synMethod2
Thread-1访问了同步方法synMethod2
Thread-1结束访问同步方法synMethod2
Thread-1访问了同步方法synMethod
Thread-1结束访问同步方法synMethod
//分析：通过结果可知，任务的执行是阻塞的，显然Thread-1必须等待Thread-0执行完毕之后才能继续执行
```

##### 同一个锁的同步代码块同一时刻只能被一个线程访问

###### 当同步代码块都是同一个锁时，方法可以被所有线程访问，但同一个锁的同步代码块同一时刻只能被一个线程访问

```java
public static void main(String[] args){
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(){
        @Override
        public void run(){
            //调用同步块方法
            synDemo.chunkMethod();
            synDemo.chunkMethod2();
        }
    };
    Thread thread2 = new Thread(){
        @Override
        public void run(){
            //调用同步块方法
            synDemo.chunkMethod();
            synDemo.synMethod2();
        }
    };
    thread1.start();
    thread2.start();
}

//输出：
Thread-0 访问了chunkMethod方法
Thread-1 访问了chunkMethod方法
Thread-0 在chunkMethod方法中获取了lock  
...停顿等待...
Thread-1 在chunkMethod方法中获取了lock
...停顿等待...
Thread-0 访问了chunkMethod2方法
Thread-0 在chunkMethod2方法中获取了lock
...停顿等待...
Thread-1 访问了chunkMethod2方法
Thread-1 在chunkMethod2方法中获取了lock
//分析可知：
//1.对比18行和19行可知，即使普通方法有同步代码块，但方法的访问是非阻塞的，任何线程都可以自由进入
//2.对比20行、22行以及25行和27行可知，对于同一个锁的同步代码块的访问一定是阻塞的
```

##### 线程间同时访问同一个锁的多个同步代码的执行顺序不定

- 线程间同时访问同一个锁多个同步代码的执行顺序不定，即使是使用同一个对象锁，这点跟同步方法有很大差异

```java
public static void main(String[] args){
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> {
        //调用同步块方法
        synDemo.chunkMethod();
        synDemo.chunkMethod2();
    });
    Thread thread2 = new Thread(() -> {
        //调用同步块方法
        synDemo.chunkMethod2();
        synDemo.chunkMethod();
    });
    thread1.start();
    thread2.start();
}

---------------------
//输出：
Thread-0访问了chunkMethod方法
Thread-1访问了chunkMethod2方法
Thread-0在chunkMethod方法中获取了lock
...停顿等待...
Thread-0访问了chunkMethod2方法
Thread-1在chunkMethod2方法中获取了lock
...停顿等待...
Thread-1访问了chunkMethod方法
Thread-0在chunkMethod2方法中获取了lock
...停顿等待...
Thread-1在chunkMethod方法中获取了lock

//分析可知：
//现象：对比20行、22行和24行、25行可知，虽然是同一个lock对象，但其不同代码块的访问是非阻塞的
//原因：根源在于锁的释放和重新竞争，当Thread-0访问完chunkMethod方法后会先释放锁，这时Thread-1就有机会能获取到锁从而优先执行，依次类推到24行、25行时，Thread-0又重新获取到锁优先执行了
//注意：但有一点是必须的，对于同一个锁的同步代码块的访问一定是阻塞的
//补充：同步方法之所有会被全部阻塞，是因为synDemo对象一直被线程在内部把持住就没释放过，论把持住的重要性！
```

##### 不同锁之间访问非阻塞

由于三种使用方式的锁对象都不一样，因此相互之间不会有任何影响。但两种情况除外：

- 当同步代码块使用的Class对象和类对象一致时属于同一个锁
- 当同步代码块使用的是this，即与同步方法使用锁属于同一个锁

```java
public static void main(String[] args) {
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> synDemo.chunkMethod() );
    Thread thread2 = new Thread(() -> synDemo.chunkMethod3());
    Thread thread3 = new Thread(() -> staticMethod());
    Thread thread4 = new Thread(() -> staticMethod2());
    thread1.start();
    thread2.start();
    thread3.start();
    thread4.start();
}
---------------------
//输出：
Thread-1访问了chunkMethod3方法
Thread-1在chunkMethod3方法中获取了this
Thread-2访问了静态同步方法staticMethod
Thread-0访问了chunkMethod方法
Thread-0在chunkMethod方法中获取了lock
Thread-3访问了静态同步方法staticMethod2
...停顿等待...
Thread-2结束访问静态同步方法staticMethod
Thread-3在staticMethod2方法中获取了SynchronizedDemo.class
//分析可知：
//现象：对比16行、18行和24行、25行可知，虽然是同一个lock对象，但其不同代码块的访问是非阻塞的
//原因：根源在于锁的释放和重新竞争，当Thread-0访问完chunkMethod方法后会先释放锁，这时Thread-1就有机会能获取到锁从而优先执行，依次类推到24行、25行时，Thread-0又重新获取到锁优先执行了
```

##### synchronized 与String锁

###### 隐患

由于在JVM中具有String常量池缓存的功能，因此**相同字面量是同一个锁！！！**

###### 注意

严重不推荐将String作为锁对象，而应该改用其他非缓存对象

```java
public static void main(String[] args) {
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> synDemo.stringMethod("sally"));
    Thread thread2 = new Thread(() -> synDemo.stringMethod("sally"));
    thread1.start();
    thread2.start();
}
---------------------
//输出：
Thread-0
Thread-0
Thread-0
Thread-0
...死循环...
//分析：输出结果永远都是Thread-0的死循环，也就是说另一个线程，即Thread-1线程根本不会运行
//原因：同步块中的锁是同一个字面量
```

##### synchronized 与不可变锁

###### 隐患

当使用不可变类对象(final class)作为对象锁时，使用synchronized同样会有并发问题

###### 原因

由于不可变特性，**当作为锁但同步块内部仍然有计算操作**，会生成一个新的锁对象

###### 注意

严重不推荐将final Class作为锁对象时仍对其有计算操作

```java
public class SynchronizedDemo {
    static Integer i = 0;   //Integer是final Class
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                for (int j = 0;j<10000;j++){
                    synchronized (i){
                        i++;
                    }
                }
            }
        };
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(i);
    }
}
---------------------
//输出：
14134
//分析：跟预想中的20000不一致，当使用Integer作为对象锁时但还有计算操作就会出现并发问题
```

#### 中断

```java
//中断线程（实例方法）
public void Thread.interrupt();

//判断线程是否被中断（实例方法）
public boolean Thread.isInterrupted();

//判断是否被中断并清除当前中断状态（静态方法）
public static boolean Thread.interrupted();
```

##### 线程处于被阻塞状态，中断该线程将抛出异常

当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用`Thread.interrupt()`方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程：

```java
public class InterruptSleepThread3{
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
          	@Override
            public void run(){
            	//while 在 try中，通过异常中断就可以退出 run循环
                try{
                	while(true){
                    	//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出
                    	Thread.sleep(2);
                	}
            	catch(IntertuptedException e){
                    System.out.println("Interrupted When Sleep");
                    boolean interrupt = this.isInterrupted();
                    //中断状态被复位
                    System.out.println("interrupt:"+interrupt);
                }
            }
        };
        t1.start();
		TimeUnit.SECONDS.sleep(2);
		//中断处于阻塞状态的线程
		t1.interrupt();
    }
}
    
//输出结果:
Interrupted When Sleep
interrupt:false
```

##### 处于运行期且非阻塞状态线程中断，不会得到任何响应

```java
public class InterruptThread{
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
            @Override
            public void run(){
                while(true){
                    System.out.println("未被中断");
                }
            }
        };
        t1.start();
        try{
            Thread.sleep(2);
            t1.interrupt();
        }catch(Exception e){
            
        }
    }
}

//输出结果（无限执行）
未被中断
未被中断
未被中断
.....
```

###### 需要手动中断检测并结束程序

```java
public class  InterruputThread {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(){
            @Override
            public void run(){
                while(true){
                    //判断当前线程是否被中断
                    if (this.isInterrupted()){
                        System.out.println("线程中断");
                        break;
                    }
                }

                System.out.println("已跳出循环,线程中断!");
            }
        };
        t1.start();
        TimeUnit.SECONDS.sleep(2);
        t1.interrupt();

        /**
         * 输出结果:
            线程中断
            已跳出循环,线程中断!
         */
    }
}
```

###### 注：

非阻塞状态调用 interrupt() 并不会导致中断状态重置。

##### 总结

- 当线程处于阻塞状态或者视图执行一个阻塞操作时，我们可以使用实例方法 interrupt() 进行线程中断，执行中断操作后将会抛出 interruptException 异常（该异常必须捕捉无法向外抛出）并将中断状态复位
- 当线程处于运行状态时，可调用实例方法 interrupt() 进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码（其实就是结束 run 方法体的代码）

```java
public void run(){
    try{
        //判断当前线程是否已中断，注意 interupted 方法是静态的，执行后会对中断状态进行复位
        while(!Thread.interrupted()){	//判断非阻塞状态下的中断，条件判断程序退出
            try{
                Thread.sleep(2000);
            }catch(InterruptedException e){
                //中断导致异常抛出，然后结束程序
            }
        }
    }
}
```

#### 中断与 synchronized

##### 线程等待锁，synchronized方法和代码块并不起作用

线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。演示代码如下：

```java
public class SynchronizedBlocked implements Runnable{

    public synchronized void f() {
        System.out.println("Trying to call f()");
        while(true) // Never releases lock
            Thread.yield();
    }

    /**
     * 在构造器中创建新线程并启动获取对象锁
     */
    public SynchronizedBlocked() {
        //该线程已持有当前实例锁
        new Thread() {
            public void run() {
                f(); // Lock acquired by this thread
            }
        }.start();
    }
    public void run() {
        //中断判断
        while (true) {
            if (Thread.interrupted()) {
                System.out.println("中断线程!!");
                break;
            } else {
                f();
            }
        }
    }


    public static void main(String[] args) throws InterruptedException {
        SynchronizedBlocked sync = new SynchronizedBlocked();
        Thread t = new Thread(sync);
        //启动后调用f()方法,无法获取当前实例锁处于等待状态
        t.start();
        try{
            Thread.sleep(2);
        }catch(Exception e){
            
        }
        //中断线程,无法生效
        t.interrupt();
    }
}
```

#### 等待唤醒机制与 synchronized

等待唤醒机制指的是 notify/notifyAll 和 wait 方法，在使用这 3个方法时，必须处于 synchronized 代码块或者 synchronized 方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。

```java
synchronized(obj){
    obj.wait();
    obj.notify();
    obj.notifyAll();
}
```



#### synchronized实现原理

同步代码块的同步基于进入和退出管程（**Monitor**）对象实现，无论是显式同步还是隐式同步都是如此。

同步方法并不是由 monitorenter 和 monitorexit 指令实现同步的，而是由方法调用指令读取运行时常量池中方法的 **ACC_SYNCHRONIZED** 标志来隐式实现的。

##### 对象锁(monitor)机制

```java
public class SynchronizedDemo{
    public static void main(String[] args){
        synchronized(SynchronizedDemo.class){
        }
        method();
    }
    private synchronized static void method(){}
}
```

反编译得到如下字节码文件：（javap -v SynchronizedDemo.class）

![](.\png\java_synchronized_class反编译.png)

执行同步代码块后首先要先执行**monitorenter**指令，退出的时候**monitorexit**指令。通过分析之后可以看出，使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是**互斥**的，即同一时刻只有一个线程能够获取到monitor。上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是**锁的重入性**，即在同一锁程中，线程不需要再次获取同一把锁。**Synchronized先天具有重入性**。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：

![](.\png\java-monitor-流程图.png)

该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

其中轻量级和偏向锁时 Java 6 对 synchronized 锁进行优化后新增加的。重量锁也就是通常说 synchronized的对象锁，锁标识为 10，其中指针指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码 ObjectMonitor.hpp文件，C++实现的）

```c++
ObjectMonitor(){
    _header = NULL;
    _count	= 0;	//记录个数
    _waiters=0;
    _recursions = 0;
    _object	= NULL;
    _owner	= NULL;
    _WaitSet =NULL;	//处于 wait状态的线程，会被加入到 _WaitSet
    _WaitSetLock = 0;
    _Responsible =NULL;
    _succ 	= NULL;
    _cxq	= NULL;
    FreeNext = NULL;
    _EntryList = NULL; //处于等待锁 block 状态的线程，会被加入到该列表
    _SpinFreq = 0;
    _SpinClock = 0;
    OwnerIsThread = 0;
}
```

ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：

![](.\png\java-synchronized原理-monitor.png)

由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)。

##### ACC_SYNCHRONIZED

方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 **ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法**。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，**如果设置了，执行线程将先持有monitor**（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时**释放monitor**。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。

```java
public class SyncMethod{
    public int i;
    
    public synchronized void syncTask(){
        i++;
    }
}
```

使用 javap 反编译后的字节码如下：

```shell
Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncMethod.class
  Last modified 2017-6-2; size 308 bytes
  MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94
  Compiled from "SyncMethod.java"
public class com.zejian.concurrencys.SyncMethod
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool;

   //省略没必要的字节码
  //==================syncTask方法======================
  public synchronized void syncTask();
    descriptor: ()V
    //方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #2                  // Field i:I
         5: iconst_1
         6: iadd
         7: putfield      #2                  // Field i:I
        10: return
      LineNumberTable:
        line 12: 0
        line 13: 10
}
SourceFile: "SyncMethod.java"
```

synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

##### happens-before

监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。

```java
public class MonitorDemo{
    private int a = 0;
    
    public synchronized void writer(){	//1
        a++;							//2
    }									//3
    
    public synchronized void reader(){	//4
        int i = a;						//5
    }									//6
}
```

该代码的 happens-before 关系如图所示：

![](.\png\java-synchronized-happens_before.png)

在图中每一个箭头连接的两个节点就代表之间的happens-before关系，**黑色**的是通过程序顺序规则推导出来，**红色**的为监视器锁规则推导而出：**线程A释放锁happens-before线程B加锁**，**蓝色**的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。

##### 锁获取和锁释放的内存语义

![](.\png\java-synchronized-获取锁.png)

从上图可以看出，线程A会首先先从主内存中读取共享变量a=0的值然后将该变量拷贝到自己的本地内存，进行加一操作后，再将该值刷新到主内存，整个过程即为线程A 加锁-->执行临界区代码-->释放锁相对应的内存语义。

![](.\png\java-synchronized-释放锁.png)

线程B获取锁的时候同样会从主内存中共享变量a的值，这个时候就是最新的值1,然后将该值拷贝到线程B的工作内存中去，释放锁的时候同样会重写到主内存中。

从整体上来看，线程A的执行结果（a=1）对线程B是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了2 happens-before 5，2的执行结果对5是可见的。

从横向来看，这就像线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。

#### synchronized优化

##### CAS操作

使用锁时，线程获取锁是一种**悲观锁策略**，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种**乐观锁策略**，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用**CAS(compare and swap)**又叫做比较交换来鉴别线程是否出现冲突，出现冲突就**重试**当前操作直到没有冲突为止。

##### Java对象头

在同步的时候是获取对象的monitor,即获取到对象的锁。那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为：

| 锁状态   | 25bit          | 4bit         | 1bit是否是偏向锁 | 2bit锁标志位 |
| -------- | -------------- | ------------ | ---------------- | ------------ |
| 无锁状态 | 对象的hashCode | 对象分代年龄 | 0                | 01           |

Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：

![](.\png\java-synchronized-优化-java对象头.png)

### volatile

#### 特性

- 可见性	对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
- 顺序性    Java内存模型不会对 volatile 指令的操作进行重排序，保证对 volatile 变量的操作时按照指令的出现顺序执行

#### 特别说明

使用volatile 关键字仅能实现对原始变量(如boolean、short、int、long等)操作的原子性；需要特别注意， volatile 不能保证复合操作的原子性，即使只是 i++ ,实际上也是由多个原子操作组成：`read i; inc; write i`，假如多个线程同时执行`i++`，`volatile`只能保证他们操作的`i`是同一块内存，但依然可能出现写入脏数据的情况。

#### 使用原则

1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2. 变量的状态不需要与其它变量共同参与不变约束
3. 访问变量不需要加锁

#### 内存屏障

#### 示例

```java
class VolatileFeaturesExample{
    volatile long v1 = 0L;	//使用volatile声明64位的long型变量
    
    public void set(long l){
        v1 =1;	//单个 volatile 变量的写
    }
    
    public void getAndIncrement(){
        v1++;	//复合(多个)volatile变量的读/写
    }
    
    public long get(){
        return v1;	//单个 volatile变量的读
    }
}
```

假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价:

```java
class VolatileFeaturesExample{
    long v1 = 0;	//64位的 long型普通变量
    
    public synchronized void set(long l){//对单个的普通变量的写用同一个监视器
        v1 = 1;
    }
    
    public void getAndIncrement(){	//普通方法调用
        long temp = get();	//调用自己同步的读方法
        temp+=1L;	//普通写操作
        set(temp);	//调用已同步的写方法
    }
    
    public synchronized long get(){
        //对单个的普通变量的读用同一个监视器同步
        return v1;
    }
}
```

对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。

监视器锁的 happens-before 规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。

监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。

#### volatile 写-读建立的happens before关系

上面讲的是 volatile 变量自身的特性，对程序员来说，volatile **对线程的内存可见性的影响**比 volatile 自身的特性更为重要，也更需要我们去关注。

从 JSR-133 开始，**volatile 变量的写 - 读可以实现线程之间的通信**。

从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。

##### 示例

```java
class VolatileExample{
    int a =0;
    volatile boolean flag = false;
    
    public void writer(){
        a = 1;	//1
        flag = true;	//2
    }
    
    public void reader(){
        if(flag){	//3
            int i = a;	//4
            ...
        }
    }
}
```

假设线程 A 执行 writer() 方法之后，线程 B 执行 reader() 方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：

1. 根据程序次序规则：1 happens before 2; 3 happens before 4
2. 根据volatile规则， 2 happens before 3
3. 根据 happens before 的传递性规则，1 happens before 4

上述 happens before 关系的图形化表现形式如下：

![](.\png\java-volatile对线程的内存可见性.png)

在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。

这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。

#### volatile 写-读的内存语义

###### volatile写的内存语义

当写一个 volatile 变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。

###### volatile读的内存语义

当读一个volatile变量时，JMM会把改线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

###### 总结

- 线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。
- 线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。
- 线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。

#### volatile内存语义的实现

为了实现 volatile 内存语义，JMM 会分别限制编译器重排序和处理器重排序。下面是 JMM 针对编译器制定的 volatile 重排序规则表：

| 是否能重排序 | 第二个操作  |             |             |
| ------------ | ----------- | ----------- | ----------- |
| 第一个操作   | 普通读 / 写 | volatile 读 | volatile 写 |
| 普通读 / 写  |             |             | NO          |
| volatile 读  | NO          | NO          | NO          |
| volatile 写  |             | NO          | NO          |

##### 总结

- 当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。
- 当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。
- 当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。

为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取**保守策略**。下面是基于保守策略的 JMM 内存屏障插入策略：

- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。

##### volatile 写插入

保守策略下，volatile **写插入**内存屏障后生成的指令序列示意图：

![](.\png\java-volatile-内存屏障-保守策略.png)

上图中的 StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。

这里比较有意思的是 volatile 写后面的 StoreLoad 屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile 读 / 写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个 StoreLoad 屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：在每个 volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。从这里我们可以看到 JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。

##### volatile 读插入

在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图：

![](.\png\java-volatile-读插入-保守策略.png)

上图中的 LoadLoad 屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序。LoadStore 屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序。

在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：

```java
class VolatileBarrierExample{
    int a;
    volatile int v1 =1;
    volatile int v2 = 2;
    
    void readAndWrite(){
        int i = v1;	//第一个volatile读
        int j = v2;	//第二个volatile读
        a = i + j;	//普通写
        v1 = i+j;	//第一个volatile写
        v2 = j*2;	//第二个volatile写
    }
    ....
}
```

针对 readAndWrite()方法，编译器在生成字节码时可以做如下的优化：

![](.\png\java-volatile-内存屏障-保守策略-优化.png)

注意，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个 StoreLoad 屏障。

上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的 StoreLoad 屏障外，其它的屏障都会被省略。

x86 处理器仅会对写 - 读操作做重排序。X86 不会对读 - 读，读 - 写和写 - 写操作做重排序，因此在 x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个 StoreLoad 屏障即可正确实现 volatile 写 - 读的内存语义。这意味着在 x86 处理器中，volatile 写的开销比 volatile 读的开销会大很多（因为执行 StoreLoad 屏障开销会比较大）。

#### JSR-133 增强volatile的内存语义

在 JSR-133 之前的旧 Java 内存模型中，虽然不允许 volatile 变量之间重排序，但旧的 Java 内存模型允许 volatile 变量与普通变量之间重排序。在旧的内存模型中，VolatileExample 示例程序可能被重排序成下列时序来执行：

![](.\png\java-volatile-旧内存模型-重排序.png)

在旧的内存模型中，当 1 和 2 之间没有数据依赖关系时，1 和 2 之间就可能被重排序（3 和 4 类似）。其结果就是：读线程 B 执行 4 时，不一定能看到写线程 A 在执行 1 时对共享变量的修改。

因此在旧的内存模型中 ，volatile 的写 - 读没有监视器的释放 - 获取所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133 专家组决定增强 volatile 的内存语义：严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写 - 读和监视器的释放 - 获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要 volatile 变量与普通变量之间的重排序可能会破坏 volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。

#### 使用示例

##### 状态标记量

```java
volatile boolean inited = false;
//线程1:
context = loadContext();  
inited = true;            
 
//线程2:
while(!inited ){
sleep()
}
doSomethingwithconfig(context);
```

##### double check

```java
class Singleton{
    private volatile static Singleton instance = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

#### 总结

由于 volatile 仅仅保证对单个 volatile 变量的读 / 写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。如果读者想在程序中用 volatile 代替监视器锁，请一定谨慎。

### volatile 与synchronized区别

##### synchronized

- 执行控制问题
- 创建内存屏障，保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性。

##### volatile

- 可见性

##### 区别

- volatile本质是在告诉 JVM 当前变量在寄存器(工作内存)中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以保证变量的修改可见性和原子性
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞
- volatile标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化

## concurrent包的实现

由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：

1. A线程写volatile变量，随后B线程读这个volatile变量
2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量
3. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量
4. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量

Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读 - 改 - 写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读 - 改 - 写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读 - 改 - 写操作的原子指令）。同时，volatile 变量的读 / 写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个 concurrent 包得以实现的基石。如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：

1. 首先，声明共享变量为 volatile
2. 然后，使用CAS的原子条件更新来实现线程之间的同步
3. 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：

![](.\png\java-concurrent包的实现示意图.png)

![](.\png\java-concurrent.png)

### 分类

- locks 部分：显式锁（互斥锁和速写锁）相关
- atomic部分：原子变量类相关，是构建非阻塞算法的基础
- executor部分：线程池相关
- collections部分：并发容器相关
- tools部分：同步工具相关，如信号量、闭锁、栅栏等功能

### 原子操作

简单的、高效的、线程安全的递增递减方案。

#### 产生原因

在Java里面，++i或者--i不是线程安全的，这里面有三个独立的操作：

- 获取变量当前值

- 为该值+1 或 -1
- 然后写回新的值

#### 实现

- 采用纯 Java 实现的，不可避免的采用了 synchronized 关键字。

  public final synchronized void set(int newValue);

  public final synchronized int getAndSet(int newValuee);

  public final synchronized int incrementAndGet();

- 在变量上使用了 volatile 来保证 get() 的时候不用加锁

#### 方法

| 方法名               | 方法原型                                          | 方法描述                                                     |
| -------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| addAndGet(int delta) | int addAndGet(int delta)                          | 以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作 |
| compareAndSet        | boolean compareAndSet(int expect, int update)     | 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。 |
| decrementAndGet      | int decrementAndGet()                             | 以原子方式将当前值减 1。 相当于线程安全版本的--i操作。       |
| get                  | int get()                                         | 获取当前值                                                   |
| getAndAdd            | int getAndAdd(int delta)                          | 以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。 |
| getAndDecrement      | int getAndDecrement()                             | 以原子方式将当前值减 1。 相当于线程安全版本的i--操作。       |
| getAndIncrement      | int getAndIncrement()                             | 以原子方式将当前值加 1。 相当于线程安全版本的i++操作         |
| getAndSet            | int getAndSet(int newValue)                       | 以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。 |
| incrementAndGet      | int incrementAndGet()                             | 以原子方式将当前值加 1。 相当于线程安全版本的++i操作         |
| lazySet              | void lazySet(int newValue)                        | 最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。 |
| set                  | void set(int newValue)                            | 设置为给定值。 直接修改原始值，也就是i=newValue操作          |
| weakCompareAndSet    | boolean weakCompareAndSet(int expect, int update) | 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。   |

#### 示例

```java
public class AtomicIntegerTest {

    @Test
    public void testAll() throws InterruptedException{
        final AtomicInteger value = new AtomicInteger(10);
        assertEquals(value.compareAndSet(1, 2), false);
        assertEquals(value.get(), 10);
        assertTrue(value.compareAndSet(10, 3));
        assertEquals(value.get(), 3);
        value.set(0);
        //
        assertEquals(value.incrementAndGet(), 1);
        assertEquals(value.getAndAdd(2),1);
        assertEquals(value.getAndSet(5),3);
        assertEquals(value.get(),5);
        //
        final int threadSize = 10;
        Thread[] ts = new Thread[threadSize];
        for (int i = 0; i < threadSize; i++) {
            ts[i] = new Thread() {
                public void run() {
                    value.incrementAndGet();
                }
            };
        }
        //
        for(Thread t:ts) {
            t.start();
        }
        for(Thread t:ts) {
            t.join();
        }
        //
        assertEquals(value.get(), 5+threadSize);
    }

}
```

#### AtomicIntegerArray

AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray的API类似，选择有代表性的AtomicIntegerArray来描述这些问题。

##### API

| 方法名            | 方法原型                                                 | 描述                    |
| ----------------- | -------------------------------------------------------- | ----------------------- |
| get               | int get(int i)                                           | 获取位置 `i` 的当前值。 |
| set               | void set(int i, int newValue)                            |                         |
| lazySet           | void lazySet(int i, int newValue)                        |                         |
| getAndSet         | int getAndSet(int i, int newValue)                       |                         |
| compareAndSet     | boolean compareAndSet(int i, int expect, int update)     |                         |
| weakCompareAndSet | boolean weakCompareAndSet(int i, int expect, int update) |                         |
| getAndIncrement   | int getAndIncrement(int i)                               |                         |
| getAndDecrement   | int getAndDecrement(int i)                               |                         |
| getAndAdd         | int getAndAdd(int i, int delta)                          |                         |
| incrementAndGet   | int incrementAndGet(int i)                               |                         |
| decrementAndGet   | int decrementAndGet(int i)                               |                         |
| addAndGet         | int addAndGet(int i, int delta)                          |                         |

#### AtomicIntegerFieldUpdater<T>

AtomicIntegerFieldUpdater<T>/AtomicLongFieldUpdater<T>/AtomicReferenceFieldUpdater<T,V>是基于反射的原子更新字段的值。

##### 约束

- 字段必须是 volatile类型的
- 字段描述类型（修饰符 public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。
- 只能是实例变量，不能是类变量，也就是说不能加 static 关键字
- 只能是可修改变量，不能是 final 变量。
- 对于 AtomicIntegerFieldUpdater 和 AtomicLongFieldUpdater 只能修改 int / long 类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 AtomicReferenceFieldUpdater。

##### 示例

```java
public class AtomicIntegerFieldUpdaterDemo{
    class DemoData{
        public volatile int value1 = 1;
        volatile int value2 =2;
        protected volatile int value3 = 3;
        private volatile int value4 = 4;
    }
    
    AtomicIntegerFieldUpdater<DemoData> getUpdater(String fieldName){
        return AtomicIntegerFieldUpdater.newUpdater(DemoData.class,fieldName);
    }
    
    void doit(){
        DemoData data = new DemoData();
        System.out.println("1=======>"+getUpdater("value1").getAndSet(data,10));
        System.out.println("3 ==> "+getUpdater("value2").incrementAndGet(data));
        System.out.println("2 ==> "+getUpdater("value3").decrementAndGet(data));
        System.out.println("true ==> "+getUpdater("value4").compareAndSet(data, 4, 5));
    }
    public static void main(String[] args) {
        AtomicIntegerFieldUpdaterDemo demo = new AtomicIntegerFieldUpdaterDemo();
        demo.doit();
    }
}
```

上面的例子中DemoData的字段value3/value4对于AtomicIntegerFieldUpdaterDemo类是不可见的，因此通过反射是不能直接修改其值的。

#### AtomicMarkableReference 与 AtomicStampedReference

**AtomicMarkableReference** 类描述的一个 <Object,Boolean> 对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。

**AtomicStampedReference**类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比**AtomicMarkableReference**类的<Object,Boolean>，**AtomicStampedReference**维护的是一种类似<Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与**AtomicInteger**不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。

**AtomicMarkableReference/AtomicStampedReference**在解决“**ABA**问题”上很有用

### 并发容器

#### ConcurrentMap

##### Map 体系结构

![](.\png\java-map体系结构图.png)

1. Hashtable是JDK 5之前Map唯一线程安全的内置实现Hashtable继承的是Dictionary（Hashtable是其唯一公开的子类），并**不继承AbstractMap或者HashMap**。尽管Hashtable和HashMap的结构非常类似，但是他们之间并没有多大联系。
2. ConcurrentHashMap是HashMap的线程安全版本，ConcurrentSkipListMap是TreeMap的线程安全版本。
3. 最终可用的线程安全版本Map实现是ConcurrentHashMap/ConcurrentSkipListMap/Hashtable/Properties四个，但是Hashtable是过时的类库，因此如果可以的应该尽可能的使用ConcurrentHashMap和ConcurrentSkipListMap。

##### API

在原有 java.util.map 接口基础上又新提供了 4种方法，进一步扩展了原有Map的功能：

```java
public interface ConcurrentMap<K,V> extends Map<K,V>{
    //插入元素
    V putIfAbsent(K key,V value);
    
    //移除元素
    boolean remove(Object key,Object value);
    
    //替换元素
    boolean replace(K key,V oldValue,V newValue);
    
    //替换元素
    V replace(K key,V value);
}
```



| 方法                  | 方法原型                                            | 方法描述                                                     |
| --------------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| putIfAbsent(K,V)      | public V putIfAbsent(K,V)                           | 与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值 |
| remove(Object,Object) | public boolean remove(Object key,Object value)      | 与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key--value不能与Map中原有的key--value对应上，则不会删除该元素 |
| replace(K,V)          | public V replace(K key,V value)                     | 与上面的replace不同的是，此replace不会对Map中原有的key--value进行比较，如果key存在则直接替换 |
| replace(K,V,V)        | public boolean replace(K key,V oldValue,V newValue) | 增加了对value值的判断，如果key--oldValue能与Map中原有的key--value对应上，才进行替换操作 |

##### 示例

###### 一种单例模式的实现

```java
public class ConcurrentDemo{
    private static final ConcurrentMap<String,ConcurrentDemo> map = new ConcurrentHashMap<String,ConcurrentDemo>();
    private static ConcurrentDemo instance;
    public static ConcurrentDemo getInstance(){
        if(instance == null){
            map.putIfAbsent("INSTANCE",new ConcurrentDemo());
            instance = map.get("INSTANCE");
        }
        return instance;
    }
    
    private ConcurrentDemo(){}
}
```

#### ConcurrentHashMap

##### 类图

![](.\png\java-ConcurrentHashmap.png)

##### 原理

ConcurrentHashMap类中包含两个静态内部类 HashEntry 和 Segment，其中 HashEntry 用来封装具体的K/V对，是个典型的四元组；Segment 用来充当锁的角色，每个 Segment 对象守护整个ConcurrentHashMap的若干个桶 (可以把Segment看作是一个小型的哈希表)，其中每个桶是由若干个 HashEntry 对象链接起来的链表。总的来说，一个ConcurrentHashMap实例中包含由若干个Segment实例组成的数组，而一个Segment实例又包含由若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。特别地，ConcurrentHashMap 在默认并发级别下会创建16个Segment对象的数组，如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。
对于一次Map的查找来说，首先就需要定位到Segment，然后从过Segment定位到HashEntry链表，最后才是通过遍历链表得到需要的元素。

回头看Segment的类图，可以看到Segment除了有一个volatile类型的元素大小count外，Segment还是集成自ReentrantLock的。

##### 优点

在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。

特别地，**在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。**

##### 高并发机制

ConcurrentHashMap 的高效并发机制是通过以下三方面来保证的：

- 通过锁分段技术保证并发环境下的写操作
- 通过HashEntry 的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作
- 通过不加锁和加锁两种方案控制跨段操作的安全性

##### JDK定义

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>,Serializable{
    .....
}
```

##### 成员变量定义

与HashMap相比，ConcurrentHashMap 增加了两个属性用于定位段，分别是 segmentMask 和 segmentShift。此外，不同于HashMap的是，ConcurrentHashMap底层结构是一个Segment数组，而不是Object数组，具体源码如下：

```java
/**
* Mask value for indexing into segments. The upper bits of a
* key's hash code are used to choose the segment.
*/
final int segmentMask;  // 用于定位段，大小等于segments数组的大小减 1，是不可变的

/**
* Shift value for indexing within segments.
*/
final int segmentShift;    // 用于定位段，大小等于32(hash值的位数)减去对segments的大小取以2为底的对数值，是不可变的

/**
* The segments, each of which is a specialized hash table
*/
final Segment<K,V>[] segments;   // ConcurrentHashMap的底层结构是一个Segment数组
```

##### 段定义

**Segment 类继承于 ReentrantLock 类**，从而使得 Segment 对象能充当锁的角色。Segment 对象用来守护它的成员对象 table 中包含的若干个桶。table 是一个由 HashEntry 对象组成的链表数组，table 数组的每一个数组成员就是一个桶。

```java
/**
* Segments are specialized versions of hash tables.  This
* subclasses from ReentrantLock opportunistically, just to
* simplify some locking and avoid separate construction.
*/
static final class Segment<K,V> extends ReentrantLock implements Serializable {

/**
* The number of elements in this segment's region.
*/
transient volatile int count;    // Segment中元素的数量，可见的

/**
* Number of updates that alter the size of the table. This is
* used during bulk-read methods to make sure they see a
* consistent snapshot: If modCounts change during a traversal
* of segments computing size or checking containsValue, then
* we might have an inconsistent view of state so (usually)
* must retry.
*/
transient int modCount;  //对count的大小造成影响的操作的次数（比如put或者remove操作）

/**
* The table is rehashed when its size exceeds this threshold.
* (The value of this field is always <tt>(int)(capacity *
* loadFactor)</tt>.)
*/
transient int threshold;      // 阈值，段中元素的数量超过这个值就会对Segment进行扩容

/**
* The per-segment table.
*/
transient volatile HashEntry<K,V>[] table;  // 链表数组

/**
* The load factor for the hash table.  Even though this value
* is same for all segments, it is replicated to avoid needing
* links to outer object.
* @serial
*/
final float loadFactor;  // 段的负载因子，其值等同于ConcurrentHashMap的负载因子
	...
}
```

###### 段的成员变量

count :

​	volatile 修饰，表示每个 Segment 对象管理的 table 数组包含的 HashEntry 对象的个数。对count的任何更新对其它线程都是立即可见的。

modCount：

​	用于统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变。

threashold：

​	表示段需要进行重哈希的阈值。

loadFactor：

​	表示段的负载因子，其值等同于ConcurrentHashMap的负载因子的值。

table：

​	一个典型的链表数组，而且也是volatile的，这使得对table的任何更新对其它线程也都是立即可见的。

##### HashEntry

在HashEntry类中，key，hash和next域都被声明为final的，value域被volatile所修饰，因此**HashEntry对象几乎是不可变的，这是ConcurrentHashmap读操作并不需要加锁的一个重要原因**。

**由于value域被volatile修饰，所以其可以确保被读线程读到最新的值，这是ConcurrentHashmap读操作并不需要加锁的另一个重要原因。**

next域被声明为final本身就意味着我们不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，因此所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点**整个复制(重新new)一遍**，最后一个节点指向要删除结点的下一个结点。

###### 源码

```java
static final class HashEntry<K,V> {
	final K key;                       // 声明 key 为 final 的
	final int hash;                   // 声明 hash 值为 final 的
	volatile V value;                // 声明 value 被volatile所修饰
	final HashEntry<K,V> next;      // 声明 next 为 final 的

	HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
		this.key = key;
		this.hash = hash;
		this.next = next;
		this.value = value;
	}

	@SuppressWarnings("unchecked")
	static final <K,V> HashEntry<K,V>[] newArray(int i) {
		return new HashEntry[i];
	}
}
```

##### ConcurrentHashMap的构造函数

**ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)**

构造一个具有指定容量、指定负载因子和指定段数目/并发级别(若不是2的幂次方，则会调整为2的幂次方)的空ConcurrentHashMap。

**ConcurrentHashMap(int initialCapacity, float loadFactor)**

构造一个具有指定容量、指定负载因子和默认并发级别(16)的空ConcurrentHashMap。

**ConcurrentHashMap(int initialCapacity)**

构造一个具有指定容量、默认负载因子(0.75)和默认并发级别(16)的空ConcurrentHashMap。

**ConcurrentHashMap()**

构造一个具有默认初始容量(16)、默认负载因子(0.75)和默认并发级别(16)的空ConcurrentHashMap。

**ConcurrentHashMap(Map<? extends K, ? extends V> m)**

构造一个与指定 Map 具有相同映射的 ConcurrentHashMap，其初始容量不小于 16 (具体依赖于指定Map的大小)，负载因子是 0.75，并发级别是 16， 是 Java Collection Framework 规范推荐提供的。

```java
public ConcurrentHashMap(Map<? extends K,? extends V> m){
    this(Math.max((int)(m.size() / DEFAULT_LOAD_FACTOR)+1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
    putAll(m);
}
```

##### ConcurrentHashMap的数据结构

![](.\png\java-ConcurrentHaspMap数据结构.png)

##### ConcurrentHashMap 并发存取

在ConcurrentHashMap中，线程对映射表做读操作时，一般情况下不需要加锁就可以完成，**对容器做结构性修改的操作**(比如，put操作、remove操作等)才需要加锁。

###### put(key,value)

**源码**

```java
public V put(K key, V value) {
	if (value == null)
		throw new NullPointerException();
	int hash = hash(key.hashCode());
	return segmentFor(hash).put(key, hash, value, false);
}
```

```java
final Segment<K,V> segmentFor(int hash) {
	return segments[(hash >>> segmentShift) & segmentMask];
}
```

假设Segment的数量(segments数组的长度)是2的n次方(Segment的数量总是2的倍数，具体见构造函数的实现)，那么segmentShift的值就是32-n(hash值的位数是32)，而segmentMask的值就是2^n-1（写成二进制的形式就是n个1）。进一步地，我们就可以得出以下结论：根据key的hash值的高n位就可以确定元素到底在哪一个Segment中。

```java
V put(K key, int hash, V value, boolean onlyIfAbsent) {
	lock();    // 上锁
	try {
		int c = count;
		if (c++ > threshold) // ensure capacity
			rehash();
		HashEntry<K,V>[] tab = table;    // table是Volatile的
		int index = hash & (tab.length - 1);    // 定位到段中特定的桶
		HashEntry<K,V> first = tab[index];   // first指向桶中链表的表头
		HashEntry<K,V> e = first;

		// 检查该桶中是否存在相同key的结点
		while (e != null && (e.hash != hash || !key.equals(e.key)))  
			e = e.next;

		V oldValue;
		if (e != null) {        // 该桶中存在相同key的结点
			oldValue = e.value;
			if (!onlyIfAbsent)
				e.value = value;        // 更新value值
		}else {         // 该桶中不存在相同key的结点
			oldValue = null;
			++modCount;     // 结构性修改，modCount加1
			tab[index] = new HashEntry<K,V>(key, hash, first, value);  // 创建HashEntry并将其链到表头
			count = c;      //write-volatile，count值的更新一定要放在最后一步(volatile变量)
		}
		return oldValue;    // 返回旧值(该桶中不存在相同key的结点，则返回null)
	} finally {
		unlock();      // 在finally子句中解锁
	}
}
```

###### refresh()

ConcurrentHashMap的重哈希实际上是对ConcurrentHashMap的某个段的重哈希。

```java
void rehash() {
	HashEntry<K,V>[] oldTable = table;    // 扩容前的table
	int oldCapacity = oldTable.length;
	if (oldCapacity >= MAXIMUM_CAPACITY)   // 已经扩到最大容量，直接返回
		return;

	// 新创建一个table，其容量是原来的2倍
	HashEntry<K,V>[] newTable = HashEntry.newArray(oldCapacity<<1);   
	threshold = (int)(newTable.length * loadFactor);   // 新的阈值
	int sizeMask = newTable.length - 1;     // 用于定位桶
	for (int i = 0; i < oldCapacity ; i++) {
		// We need to guarantee that any existing reads of old Map can
		//  proceed. So we cannot yet null out each bin.
		HashEntry<K,V> e = oldTable[i];  // 依次指向旧table中的每个桶的链表表头

		if (e != null) {    // 旧table的该桶中链表不为空
			HashEntry<K,V> next = e.next;
			int idx = e.hash & sizeMask;   // 重哈希已定位到新桶
			if (next == null)    //  旧table的该桶中只有一个节点
				newTable[idx] = e;
			else {    
				// Reuse trailing consecutive sequence at same slot
				HashEntry<K,V> lastRun = e;
				int lastIdx = idx;
 				for (HashEntry<K,V> last = next;last != null;last = last.next) {
					int k = last.hash & sizeMask;
					// 寻找k值相同的子链，该子链尾节点与父链的尾节点必须是同一个
					if (k != lastIdx) {
						lastIdx = k;
						lastRun = last;
					}
				}

				// JDK直接将子链lastRun放到newTable[lastIdx]桶中
				newTable[lastIdx] = lastRun;

				// 对该子链之前的结点，JDK会挨个遍历并把它们复制到新桶中
				for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
					int k = p.hash & sizeMask;
					HashEntry<K,V> n = newTable[k];
					newTable[k] = new HashEntry<K,V>(p.key, p.hash,n, p.value);
				}
			}
		}
	}
	table = newTable;   // 扩容完成
}
```

链接指针next是final的，因此看起来我们好像只能把该桶的HashEntry链中的每个节点复制到新的桶中(这意味着我们要重新创建每个节点)，但事实上JDK对其做了一定的优化。因为在理论上原桶里的HashEntry链可能存在一条子链，这条子链上的节点都会被重哈希到同一个新的桶中，这样我们只要拿到该子链的头结点就可以直接把该子链放到新的桶中，从而避免了一些节点不必要的创建，提升了一定的效率。

##### get(Object key)

ConcurrentHashMap中查询一个指定Key的键值对时，首先会定位其应该存在的段，然后查询请求委托给这个段进行处理，源码如下：

```java
public V get(Object key){
    int hash = hash(key.hashCode());
    return segmentFor(hash).get(key,hash);
}
```

```java
V get(Object key, int hash) {
	if (count != 0) {            // read-volatile，首先读 count 变量
		HashEntry<K,V> e = getFirst(hash);   // 获取桶中链表头结点
		while (e != null) {
			if (e.hash == hash && key.equals(e.key)) {    // 查找链中是否存在指定Key的键值对
				V v = e.value;
				if (v != null)  // 如果读到value域不为 null，直接返回
					return v;   
  				// 如果读到value域为null，说明发生了重排序，加锁后重新读取
				return readValueUnderLock(e); // recheck
			}
			e = e.next;
		}
	}
	return null;  // 如果不存在，直接返回null
}
```

ConcurrentHashMap不同于HashMap，它既不允许key值为null，也不允许value值为null。但是，此处怎么会存在键值对存在且的Value值为null的情形呢？JDK官方给出的解释是，这种情形发生的场景是：初始化HashEntry时发生的指令重排序导致的，也就是在HashEntry初始化完成之前便返回了它的引用。这时，JDK给出的解决之道就是加锁重读。

```java
V readValueUnderLock(HashEntry<K,V> e){
    lock();
    try{
        return e.value;
    }finally{
        unlock();
    }
}
```

##### ConcurrentHashMap读操作不需要加锁的奥秘

- 用HashEntry 对象的不变性来降低读操作对加锁的需求
- 用 volatile 变量协调读写线程的内存可见性
- 若读时发现指令重排序现象，则加锁重读

###### 用HashEntery对象的不变性来降低读操作对加锁的需求

在ConcurrentHashMap 中，结构性修改操作包括 put 操作、remove 操作和 clear 操作，下面分别分析这三个操作：

- clear操作只是把ConcurrentHashMap中所有的桶置空，每个桶之前引用的链表依然存在，只是桶不再引用这些链表而已，而链表本身的结构并没有发生任何修改。因此，正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。
- put操作如果需要插入一个新节点到链表中时会在链表头部插入这个新节点，此时链表中的原有节点的链接并没有被修改。也就是说，插入新的健/值对到链表中的操作不会影响读线程正常遍历这个链表。
- 在执行remove操作时，原始链表并没有被修改，也就是说，读线程不会受同时执行 remove 操作的并发写线程的干扰。

**remove 操作源码**

```java
public V remove(Object key){
    int hash = hash(key.hashCode());
    return segmentFor(hash).remove(key,hash,null);
}
```



```java
V remove(Object key, int hash, Object value) {
	lock();     // 加锁
	try {
		int c = count - 1;      
		HashEntry<K,V>[] tab = table;
		int index = hash & (tab.length - 1);        // 定位桶
		HashEntry<K,V> first = tab[index];
		while (e != null && (e.hash != hash || !key.equals(e.key)))  // 查找待删除的键值对
			e = e.next;

		V oldValue = null;
		if (e != null) {    // 找到
			V v = e.value;
			if (value == null || value.equals(v)) {
				oldValue = v;
				// All entries following removed node can stay
				// in list, but all preceding ones need to be
				// cloned.
				++modCount;
				// 所有处于待删除节点之后的节点原样保留在链表中
				HashEntry<K,V> newFirst = e.next;
				// 所有处于待删除节点之前的节点被克隆到新链表中
				for (HashEntry<K,V> p = first; p != e; p = p.next)
					newFirst = new HashEntry<K,V>(p.key, p.hash,newFirst, p.value); 
				tab[index] = newFirst;   // 将删除指定节点并重组后的链重新放到桶中
				count = c;      // write-volatile，更新Volatile变量count
			}
		}
		return oldValue;
	} finally {
		unlock();          // finally子句解锁
	}
}
```

Segment的remove操作和前面提到的get操作类似，首先根据散列码找到具体的链表，然后遍历这个链表找到要删除的节点，最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中。假设写线程执行remove操作，要删除链表的C节点，另一个读线程同时正在遍历这个链表，如下图所示：

![](.\png\java-ConcurrentHashMap-remove.png)

可以看出，删除节点C之后的所有节点原样保留到新链表中；删除节点C之前的每个节点被克隆到新链表中(它们在新链表中的链接顺序被反转了)。因此，在执行remove操作时，原始链表并没有被修改，也就是说，读线程不会受同时执行 remove 操作的并发写线程的干扰。

##### ConcurrentHashMap 跨段操作

在ConcurrentHashMap中，有些操作需要涉及到多个段，比如说**size操作**、**containsValaue操作**等。以size操作为例，如果我们要统计整个ConcurrentHashMap里元素的大小，那么就必须统计所有Segment里元素的大小后求和。我们知道，Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？显然不能，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。

```java
public int size() {
	final Segment<K,V>[] segments = this.segments;
	long sum = 0;
	long check = 0;
	int[] mc = new int[segments.length];
	// Try a few times to get accurate count. On failure due to
	// continuous async changes in table, resort to locking.
	for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {
		check = 0;
		sum = 0;
		int mcsum = 0;
		for (int i = 0; i < segments.length; ++i) {
			sum += segments[i].count;   
			mcsum += mc[i] = segments[i].modCount;  // 在统计size时记录modCount
		}
		if (mcsum != 0) {
			for (int i = 0; i < segments.length; ++i) {
				check += segments[i].count;
 				if (mc[i] != segments[i].modCount) {  // 统计size后比较各段的modCount是否发生变化
					check = -1; // force retry
					break;
				}
			}
		}
		if (check == sum)// 如果统计size前后各段的modCount没变，且两次得到的总数一致，直接返回
			break;
	}
	if (check != sum) { // Resort to locking all segments  // 加锁统计
		sum = 0;
		for (int i = 0; i < segments.length; ++i)
			segments[i].lock();
		for (int i = 0; i < segments.length; ++i)
			sum += segments[i].count;
		for (int i = 0; i < segments.length; ++i)
			segments[i].unlock();
	}
	if (sum > Integer.MAX_VALUE)
		return Integer.MAX_VALUE;
	else
		return (int)sum;
}
```

size方法主要思路是先在没有锁的情况下对所有段大小求和，这种求和策略最多执行RETRIES_BEFORE_LOCK次(默认是两次)：在没有达到**RETRIES_BEFORE_LOCK**之前，求和操作会不断尝试执行（这是因为遍历过程中可能有其它线程正在对已经遍历过的段进行结构性更新）；在**超过RETRIES_BEFORE_LOCK之后，如果还不成功就在持有所有段锁的情况下再对所有段大小求和。**事实上，在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试RETRIES_BEFORE_LOCK次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。

　　那么，ConcurrentHashMap是如何判断在统计的时候容器的段发生了结构性更新了呢？我们在前文中已经知道，Segment包含一个modCount成员变量，在会引起段发生结构性改变的所有操作(put操作、 remove操作和clean操作)里，都会将变量**modCount**进行加1，因此，JDK只需要在统计size前后比较modCount是否发生变化就可以得知容器的大小是否发生变化。

##### ConcurrentHashMap 红黑树转换

1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node+CAS+Synchronized 来保证并发安全进行实现，结构如下：

![](.\png\java-ConcurrentHashMap-1_8.png)

ConcurrentHashMap的实现过程，其中有提到在put操作时，如果发现链表结构中的元素超过了TREEIFY_THRESHOLD（默认为8），则会把链表转换为红黑树（**详见 数据结构-树-红黑树**），已便于提高查询效率。

```java
if(binCount >= TREEIFY_THRESHOLD){
    treeifyBin(tab,i);
    ....
}
```

treeifyBin主要的功能就是把链表所有的节点Node转换为TreeNode节点，如下：

```java
private final void treeifyBin(Node<K,V>[] tab, int index) {
	Node<K,V> b; int n, sc;
	if (tab != null) {
		if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
			tryPresize(n << 1);
		else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
			synchronized (b) {
				if (tabAt(tab, index) == b) {
					TreeNode<K,V> hd = null, tl = null;
					for (Node<K,V> e = b; e != null; e = e.next) {
						TreeNode<K,V> p = new TreeNode<K,V>(e.hash, e.key, e.val,null, null);
						if ((p.prev = tl) == null)
							hd = p;
						else
							tl.next = p;
						tl = p;
					}
					setTabAt(tab, index, new TreeBin<K,V>(hd));
				}
			}
		}
	}
}
```

先判断当前Node的数组长度是否小于MIN_TREEIFY_CAPACITY（64），如果小于则调用tryPresize扩容处理以缓解单个链表元素过大的性能问题。否则则将Node节点的链表转换为TreeNode的节点链表，构建完成之后调用setTabAt()构建红黑树。

TreeNode继承Node，如下：

```java
 static final class TreeNode<K,V> extends Node<K,V> {
	TreeNode<K,V> parent;  // red-black tree links
	TreeNode<K,V> left;
	TreeNode<K,V> right;
	TreeNode<K,V> prev;    // needed to unlink next upon deletion
	boolean red;

 	TreeNode(int hash, K key, V val, Node<K,V> next,TreeNode<K,V> parent) {
		super(hash, key, val, next);
		this.parent = parent;
	}
	......
}
```

我们以下面一个链表作为案例，结合源代码来分析ConcurrentHashMap创建红黑树的过程：

![](.\png\java-ConcurrentHashMap-红黑树转换-1.png)

**12**

12作为跟节点，直接为将红编程黑即可，对应源码：

```java
next = (TreeNode<K,V>)x.next();
x.left = x.right = null;
if(r == null){
    x.parent = null;
    x.red = false;
    r = x;
}
```

**1**

此时根节点root不为空，则插入节点时需要找到合适的插入位置，源码如下：

```java
K k = x.key;
int h = x.hash;
Class<?> kc = null;
for (TreeNode<K,V> p = r;;) {
	int dir, ph;
	K pk = p.key;
	if ((ph = p.hash) > h)
		dir = -1;
	else if (ph < h)
		dir = 1;
	else if ((kc == null && (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0)
		dir = tieBreakOrder(k, pk);
	TreeNode<K,V> xp = p;
	if ((p = (dir <= 0) ? p.left : p.right) == null) {
		x.parent = xp;
		if (dir <= 0)
			xp.left = x;
		else
			xp.right = x;
		r = balanceInsertion(r, x);
		break;
	}
}
```

从上面可以看到起处理逻辑如下：

1. 计算节点的hash值 p。dir 表示为往左移还是往右移。x 表示要插入的节点，p 表示带比较的节点。
2. 从根节点出发，计算比较节点p的的hash值 ph ，若ph > h ,则dir = -1 ,表示左移，取p = p.left。若p == null则插入，若 p != null，则继续比较，直到直到一个合适的位置，最后调用balanceInsertion()方法调整红黑树结构。ph < h，右移。
3. 如果ph = h，则表示节点“冲突”（和HashMap冲突一致），那怎么处理呢？首先调用comparableClassFor()方法判断节点的key是否实现了Comparable接口，如果kc ！= null ，则通过compareComparables()方法通过compareTo()比较带下，如果还是返回 0，即dir == 0，则调用tieBreakOrder()方法来比较了。tieBreakOrder如下：

```java
static int tieBreakOrder(Object a,Object b){
    int d;
	if (a == null || b == null ||(d = a.getClass().getName().compareTo(b.getClass().getName())) == 0)
		d = (System.identityHashCode(a) <= System.identityHashCode(b) ? -1 : 1);
	return d;
}
```

tieBreakOrder()方法最终还是通过调用System.identityHashCode()方法来比较。

确定插入位置后，插入，由于插入的节点有可能会打破红黑树的结构，所以插入后调用balanceInsertion()方法来调整红黑树结构。

```java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,TreeNode<K,V> x) {
	x.red = true;       // 所有节点默认插入为红
	for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
		// x.parent == null，为跟节点，置黑即可
		if ((xp = x.parent) == null) {
			x.red = false;
			return x;
		}
		// x 父节点为黑色，或者x 的祖父节点为空，直接插入返回
		else if (!xp.red || (xpp = xp.parent) == null)
			return root;
		/*
		* x 的 父节点为红色
		* ---------------------
		* x 的 父节点 为 其祖父节点的左子节点
		*/
		if (xp == (xppl = xpp.left)) {
            /*
            * x的叔父节点存在，且为红色，颜色交换即可
            * x的父节点、叔父节点变为黑色，祖父节点变为红色
            */
            if ((xppr = xpp.right) != null && xppr.red) {
                xppr.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }else {
                /*
                * x 为 其父节点的右子节点，则为内侧插入
                * 则先左旋，然后右旋
                */
                if (x == xp.right) {
                    // 左旋
                    root = rotateLeft(root, x = xp);
                    // 左旋之后x则会变成xp的父节点
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                /**
                * 这里有两部分。
                * 第一部分：x 原本就是其父节点的左子节点，则为外侧插入，右旋即可
                * 第二部分：内侧插入后，先进行左旋，然后右旋
                */
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateRight(root, xpp);
                    }
                }
			}
		}
        /**
        * 与上相对应
        */
        else {
            if (xppl != null && xppl.red) {
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }else {
                if (x == xp.left) {
                    root = rotateRight(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
	}
}
```

回到节点1，其父节点为黑色，即：

```java
else if( !xp.red || (xpp = xp.parent) ==null)
    return root;
```

直接插入：

![](.\png\java-ConcurrentHashMap-红黑树-2.png)

**9** 

9作为1的右子节点插入，但是存在红红冲突，此时9的并没有叔父节点。9的父节点1为12的左子节点，9为其父节点1的右子节点，所以处理逻辑是先左旋，然后右旋，对应代码如下：

```java
if (x == xp.right) {
	root = rotateLeft(root, x = xp);
	xpp = (xp = x.parent) == null ? null : xp.parent;
}
if (xp != null) {
	xp.red = false;
	if (xpp != null) {
		xpp.red = true;
		root = rotateRight(root, xpp);
	}
}
```

图例变化如下：

![](.\png\java-ConcurrentHashMap-红黑树-3.png)



**2**

节点2 作为1 的右子节点插入，红红冲突，切其叔父节点为红色，直接变色即可：

```java
if ((xppr = xpp.right) != null && xppr.red) {
    xppr.red = false;
    xp.red = false;
    xpp.red = true;
    x = xpp;
}
```

对应图例为：

![](.\png\java-ConcurrentHashMap-红黑树-4.png)



**0**

节点0作为1的左子节点插入，由于其父节点为黑色，不会插入后不会打破红黑树结构，直接插入即可：

![](.\png\java-ConcurrentHashMap-红黑树-5.png)

**11**

节点11作为12的左子节点，其父节点12为黑色，和0一样道理，直接插入：

![](.\png\java-ConcurrentHashMap-红黑树-6.png)

**7**

节点7作为2右子节点插入，红红冲突，其叔父节点0为红色，变色即可：

![](.\png\java-ConcurrentHashMap-红黑树-7.png)

**19**

节点19作为节点12的右子节点，直接插入：

![](.\png\java-ConcurrentHashMap-红黑树-8.png)

至此，整个过程已经完成了，最终结果如下：

![](.\png\java-ConcurrentHashMap-红黑树-9.png)

#### ConcurrentSkipListMap

##### 优点

- ConcurrentSkipListMap 的 key 是有序的
- ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是 log(N) ,和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap 越能体现出他的优势。

##### ConcurrentSkipListMap 与 ConcurrentHashMap 的区别

ConcurrentHashMap 的存取速度很快。

ConcurrentSkipListMap 的 key 是有序的。支持更高的并发。

##### Skip List

**详情见 集合.md 中 key-value 中的 SkipList。**

##### 原理

利用底层的插入、删除的CAS原子性操作，通过死循环不断获取最新的结点指针来保证不会出现竟态条件。

##### 实现

ConcurrentSkipListMap其内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。

###### Node

```java
static final class Node<K,V>{
    final K key;
    volatile Object value;
    volatile ConcurrentSkipListMap.Node<K,V> next;
    ....
}
```

###### Index

```java
static class Index<K,V> {
	final ConcurrentSkipListMap.Node<K,V> node;
	final ConcurrentSkipListMap.Index<K,V> down;
	volatile ConcurrentSkipListMap.Index<K,V> right;
	...
}
```

###### HeadIndex

```java
static final class HeadIndex<K,V> extends Index<K,V> {
	final int level;  //索引层，从1开始，Node单链表层为0
	HeadIndex(Node<K,V> node, Index<K,V> down, Index<K,V> right, int level) {
		super(node, down, right);
		this.level = level;
	}
}
```



#### BlockingQueue （阻塞队列）

##### 类图

![](.\png\java-blockingqueue.png)

##### 主要方法

![](.\png\java-blockingqueue-method.png)

| 方法名  | 方法原型                              | 类别     | 描述                                                         |
| ------- | ------------------------------------- | -------- | ------------------------------------------------------------ |
| add     | add(Object)                           | 放入数据 | 队列没满的话，放入成功。否则抛出异常                         |
| offer   | offer(Object)                         | 放入数据 | 表示如果可能的话,将object加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程） |
| offer   | offer(E o,long timeout,TimeUnit unit) | 放入数据 | 可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败 |
| put     | put(Object)                           | 放入数据 | 把object加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程阻塞。直到BlockingQueue里面有空间再继续 |
| poll    | poll(time)                            | 获取数据 | 取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null |
| poll    | poll(long timeout,TimeUnit unit)      | 获取数据 | 从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败 |
| take    | take()                                | 获取数据 | 取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入 |
| drainTo | drainTo()                             | 获取数据 | 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁 |

##### ArrayBolckingQueue

一个基本数组的阻塞队列。可以设置队列的大小

###### 特点

- 由数组支持的有界阻塞队列
- 读写操作上都需要锁住整个容器

###### 使用场景

吞吐量与一般的实现是相似的，适合于实现“生产者消费者”模式。

###### 源码

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
 
    private static final long serialVersionUID = -817911632652898426L;
 
    /** 真正存入数据的数组*/
    final Object[] items;
 
    /** take, poll, peek or remove的下一个索引 */
    int takeIndex;
 
    /** put, offer, or add的下一个索引 */
    int putIndex;
 
    /**队列中元素个数*/
    int count;
 
 
    /**可重入锁 */
    final ReentrantLock lock;
 
    /** 队列不为空的条件 */
    private final Condition notEmpty;
 
    /** 队列未满的条件 */
    private final Condition notFull;
 
    transient Itrs itrs = null;
 
 
    /**
     *当前元素个数-1
     */
    final int dec(int i) {
        return ((i == 0) ? items.length : i) - 1;
    }
 
    /**
     * 返回对应索引上的元素
     */
    @SuppressWarnings("unchecked")
    final E itemAt(int i) {
        return (E) items[i];
    }
 
    /**
     * 非空检查
     *
     * @param v the element
     */
    private static void checkNotNull(Object v) {
        if (v == null)
            throw new NullPointerException();
    }
 
    /**
     * 元素放入队列，注意调用这个方法时都要先加锁
     * 
     */
    private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;//当前拥有元素个数加1
        notEmpty.signal();//有一个元素加入成功，那肯定队列不为空
    }
 
    /**
     * 元素出队，注意调用这个方法时都要先加锁
     * 
     */
    private E dequeue() {
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        E x = (E) items[takeIndex];
        items[takeIndex] = null;
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;/当前拥有元素个数减1
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();//有一个元素取出成功，那肯定队列不满
        return x;
    }
 
    /**
     * 指定删除索引上的元素
     * 
     */
    void removeAt(final int removeIndex) {
        final Object[] items = this.items;
        if (removeIndex == takeIndex) {
            items[takeIndex] = null;
            if (++takeIndex == items.length)
                takeIndex = 0;
            count--;
            if (itrs != null)
                itrs.elementDequeued();
        } else {
            final int putIndex = this.putIndex;
            for (int i = removeIndex;;) {
                int next = i + 1;
                if (next == items.length)
                    next = 0;
                if (next != putIndex) {
                    items[i] = items[next];
                    i = next;
                } else {
                    items[i] = null;
                    this.putIndex = i;
                    break;
                }
            }
            count--;
            if (itrs != null)
                itrs.removedAt(removeIndex);
        }
        notFull.signal();//有一个元素删除成功，那肯定队列不满
    }
 
    /**
     * 
     * 构造函数，设置队列的初始容量
     */
    public ArrayBlockingQueue(int capacity) {
        this(capacity, false);
    }
 
    /**
     * 构造函数。capacity设置数组大小 ，fair设置是否为公平锁
     * capacity and the specified access policy.
     */
    public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);//是否为公平锁，如果是的话，那么先到的线程先获得锁对象。
        //否则，由操作系统调度由哪个线程获得锁，一般为false，性能会比较高
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
 
    /**
     *构造函数，带有初始内容的队列
     */
    public ArrayBlockingQueue(int capacity, boolean fair,
                              Collection<? extends E> c) {
        this(capacity, fair);
 
        final ReentrantLock lock = this.lock;
        lock.lock(); //要给数组设置内容，先上锁
        try {
            int i = 0;
            try {
                for (E e : c) {
                    checkNotNull(e);
                    items[i++] = e;//依次拷贝内容
                }
            } catch (ArrayIndexOutOfBoundsException ex) {
                throw new IllegalArgumentException();
            }
            count = i;
            putIndex = (i == capacity) ? 0 : i;//如果putIndex大于数组大小 ，那么从0重新开始
        } finally {
            lock.unlock();//最后一定要释放锁
        }
    }
 
    /**
     * 添加一个元素，其实super.add里面调用了offer方法
     */
    public boolean add(E e) {
        return super.add(e);
    }
 
    /**
     *加入成功返回true,否则返回false
     * 
     */
    public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();//上锁
        try {
            if (count == items.length) //超过数组的容量
                return false;
            else {
                enqueue(e); //放入元素
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 如果队列已满的话，就会等待
     */
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();//和lock()方法的区别是让它在阻塞时也可抛出异常跳出
        try {
            while (count == items.length)
                notFull.await(); //这里就是阻塞了，要注意。如果运行到这里，那么它会释放上面的锁，一直等到notify
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 带有超时时间的插入方法，unit表示是按秒、分、时哪一种
     */
    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
 
        checkNotNull(e);
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length) {
                if (nanos <= 0)
                    return false;
                nanos = notFull.awaitNanos(nanos);//带有超时等待的阻塞方法
            }
            enqueue(e);//入队
            return true;
        } finally {
            lock.unlock();
        }
    }
 
    //实现的方法，如果当前队列为空，返回null
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return (count == 0) ? null : dequeue();
        } finally {
            lock.unlock();
        }
    }
     //实现的方法，如果当前队列为空，一直阻塞
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();//队列为空，阻塞方法
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    //带有超时时间的取元素方法，否则返回Null
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0) {
                if (nanos <= 0)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);//超时等待
            }
            return dequeue();//取得元素
        } finally {
            lock.unlock();
        }
    }
    //只是看一个队列最前面的元素，取出是不删除队列中的原来元素。队列为空时返回null
    public E peek() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return itemAt(takeIndex); // 队列为空时返回null
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 返回队列当前元素个数
     *
     */
    public int size() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 返回当前队列再放入多少个元素就满队
     */
    public int remainingCapacity() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return items.length - count;
        } finally {
            lock.unlock();
        }
    }
 
    /**
     *  从队列中删除一个元素的方法。删除成功返回true,否则返回false
     */
    public boolean remove(Object o) {
        if (o == null) return false;
        final Object[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count > 0) {
                final int putIndex = this.putIndex;
                int i = takeIndex;
                do {
                    if (o.equals(items[i])) {
                        removeAt(i); //真正删除的方法
                        return true;
                    }
                    if (++i == items.length)
                        i = 0;
                } while (i != putIndex);//一直不断的循环取出来做判断
            }
            return false;
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 是否包含一个元素
     */
    public boolean contains(Object o) {
        if (o == null) return false;
        final Object[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count > 0) {
                final int putIndex = this.putIndex;
                int i = takeIndex;
                do {
                    if (o.equals(items[i]))
                        return true;
                    if (++i == items.length)
                        i = 0;
                } while (i != putIndex);
            }
            return false;
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 清空队列
     *
     */
    public void clear() {
        final Object[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            int k = count;
            if (k > 0) {
                final int putIndex = this.putIndex;
                int i = takeIndex;
                do {
                    items[i] = null;
                    if (++i == items.length)
                        i = 0;
                } while (i != putIndex);
                takeIndex = putIndex;
                count = 0;
                if (itrs != null)
                    itrs.queueIsEmpty();
                for (; k > 0 && lock.hasWaiters(notFull); k--)
                    notFull.signal();
            }
        } finally {
            lock.unlock();
        }
    }
 
    /**
     * 取出所有元素到集合
     */
    public int drainTo(Collection<? super E> c) {
        return drainTo(c, Integer.MAX_VALUE);
    }
 
    /**
     * 取出所有元素到集合
     */
    public int drainTo(Collection<? super E> c, int maxElements) {
        checkNotNull(c);
        if (c == this)
            throw new IllegalArgumentException();
        if (maxElements <= 0)
            return 0;
        final Object[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            int n = Math.min(maxElements, count);
            int take = takeIndex;
            int i = 0;
            try {
                while (i < n) {
                    @SuppressWarnings("unchecked")
                    E x = (E) items[take];
                    c.add(x);
                    items[take] = null;
                    if (++take == items.length)
                        take = 0;
                    i++;
                }
                return n;
            } finally {
                // Restore invariants even if c.add() threw
                if (i > 0) {
                    count -= i;
                    takeIndex = take;
                    if (itrs != null) {
                        if (count == 0)
                            itrs.queueIsEmpty();
                        else if (i > take)
                            itrs.takeIndexWrapped();
                    }
                    for (; i > 0 && lock.hasWaiters(notFull); i--)
                        notFull.signal();
                }
            }
        } finally {
            lock.unlock();
        }
    }
}
```

##### LinkedBlockingQueue

###### 特点

- 基于链表的阻塞队列。

- 只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会

  阻塞生产者队列，反之对于消费者这端的处理也基于同样的原理。

- 生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
    private static final long serialVersionUID = -6903933977591709194L;
    /**
     * 链表节点类
     */
    static class Node<E> {
        E item;
        Node<E> next;//下一节点
        Node(E x) { item = x; }
    }
    /** 链表大小 ，默认大小 是Integer.MAX_VALUE */
    private final int capacity;
    /**当前队列中存放的元素个数，注意是原子类*/
    private final AtomicInteger count = new AtomicInteger();
    /**
     * 链表队列头节点
     */
    transient Node<E> head;
    /**
     * 链表队列尾节点
     */
    private transient Node<E> last;
    /** 取元素时的可重入锁 */
    private final ReentrantLock takeLock = new ReentrantLock();
 
    /**不为空条件*/
    private final Condition notEmpty = takeLock.newCondition();
    /**放元素是时的重入锁 */
    private final ReentrantLock putLock = new ReentrantLock();
    /** 不为满的条件 */
    private final Condition notFull = putLock.newCondition();
    /**
     * 不为空通知方法
     */
    private void signalNotEmpty() {
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();
        try {
            notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
    }
    /**
     * 不为满通知方法
     */
    private void signalNotFull() {
        final ReentrantLock putLock = this.putLock;
        putLock.lock();
        try {
            notFull.signal();
        } finally {
            putLock.unlock();
        }
    }
    /**
     * 进队
     *
     * @param node the node
     */
    private void enqueue(Node<E> node) {
        last = last.next = node;
    }
    /**
     * 出队
     */
    private E dequeue() {
        Node<E> h = head;
        Node<E> first = h.next;
        h.next = h; // help GC
        head = first;
        E x = first.item;
        first.item = null;
        return x;
    }
    /**
     * 取和入都上锁，此时无法取和放
     */
    void fullyLock() {
        putLock.lock();
        takeLock.lock();
    }
    /**
     * 释放锁
     */
    void fullyUnlock() {
        takeLock.unlock();
        putLock.unlock();
    }
    /**
     * 构造函数
     */
    public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
    }
    /**
     * 构造函数
     *
     */
    public LinkedBlockingQueue(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node<E>(null);
    }
    /**
     * 构造函数
     */
    public LinkedBlockingQueue(Collection<? extends E> c) {
        this(Integer.MAX_VALUE);
        final ReentrantLock putLock = this.putLock;
        putLock.lock(); //取得放入锁
        try {
            int n = 0;
            for (E e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (n == capacity)
                    throw new IllegalStateException("Queue full");
                enqueue(new Node<E>(e));
                ++n;
            }
            count.set(n);
        } finally {
            putLock.unlock();
        }
    }
     //阻塞等待放入
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly(); //取得放入锁
        try {
            while (count.get() == capacity) {//队列已满
                notFull.await();
            }
            enqueue(node);//入队
            c = count.getAndIncrement();//当前队列中元素个数加1
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
    }
    /**
     *带超时时间的阻塞等待放入，队列不满。放入成功返回true，否则返回fasle
     */
    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
 
        if (e == null) throw new NullPointerException();
        long nanos = unit.toNanos(timeout);
        int c = -1;
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {
                if (nanos <= 0)
                    return false;
                nanos = notFull.awaitNanos(nanos);
            }
            enqueue(new Node<E>(e));
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
        return true;
    }
 
    /**
     * 非阻塞放入。队列不满放入成功返回true，否则返回fasle
     */
    public boolean offer(E e) {
        if (e == null) throw new NullPointerException();
        final AtomicInteger count = this.count;
        if (count.get() == capacity)
            return false;
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        putLock.lock();
        try {
            if (count.get() < capacity) {
                enqueue(node);
                c = count.getAndIncrement();
                if (c + 1 < capacity)
                    notFull.signal();
            }
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
        return c >= 0;
    }
    //阻塞等待取出元素
    public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            while (count.get() == 0) {
                notEmpty.await();
            }
            x = dequeue();
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
    //带有超时时间等待的取出元素
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        E x = null;
        int c = -1;
        long nanos = unit.toNanos(timeout);
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();//等待时可抛出异常跳出
        try {
            while (count.get() == 0) {
                if (nanos <= 0)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);//超时等待
            }
            x = dequeue();
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();//不这空条件成立
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
    //取队头元素。没有的话返回null，有的话返回元素，并将队列中删除此元素
    public E poll() {
        final AtomicInteger count = this.count;
        if (count.get() == 0)
            return null;
        E x = null;
        int c = -1;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();//获得取得锁
        try {
            if (count.get() > 0) {
                x = dequeue();//出队
                c = count.getAndDecrement();//当前队列中元素个数减去1
                if (c > 1)
                    notEmpty.signal();//不为空条件成功
            }
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
    //取队头元素，但不从队列中删除 ，没有的话返回null,不阻塞
    public E peek() {
        if (count.get() == 0)
            return null;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();//获得取得锁
        try {
            Node<E> first = head.next;
            if (first == null)
                return null;
            else
                return first.item;
        } finally {
            takeLock.unlock();
        }
    }
 
 
    /**
     * 删除时要同时取得放入锁和取得锁
     */
    public boolean remove(Object o) {
        if (o == null) return false;
        fullyLock();//同时取得放入锁和取得锁
        try {
            for (Node<E> trail = head, p = trail.next;
                 p != null;
                 trail = p, p = p.next) {
                if (o.equals(p.item)) {
                    unlink(p, trail);
                    return true;
                }
            }
            return false;
        } finally {
            fullyUnlock();
        }
    }
 
    /**
     * 是否包含
     */
    public boolean contains(Object o) {
        if (o == null) return false;
        fullyLock();//同时取得放入锁和取得锁
        try {
            for (Node<E> p = head.next; p != null; p = p.next)
                if (o.equals(p.item))
                    return true;
            return false;
        } finally {
            fullyUnlock();
        }
    }
}
```

###### ArrayBlockingQueue 与 LinkedBlockingQueue的区别

- 队列中锁的实现不同

  ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁。

  LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock。

- 在生产或消费时操作不同

  ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的。

  LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<E>进行插入或移除，会影响性能。

- 队列大小初始化方式不同

  ArrayBlockingQueue实现的队列中必须指定队列的大小。

  LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE。

##### SynchronousQueue

SynchronousQueue 这个队列实现了 BlockingQueue 接口。

###### 特点

- 容量为 0，无论何时 size 方法总是返回 0
- put 操作阻塞，直到另外一个线程取走队列的元素
- take 操作阻塞，直到另外的线程 put 某个元素的队列中
- 任何线程只能取得其他线程 put 进去的元素，而不会取到自己 put 进去的元素

```java
public SynchronousQueue(boolean fair){
    transferer = fair ? new TransferQueue() : new TransferStack();
}
```

表示这是一个公平的基于队列的排队模式，还是一个非公平的基于栈的排队模式。

###### 示例

```java
public class SynchronousQueueDemo{
    public static void main(String[] args) throws InterruptedException{
        final SynchronousQueue<Integer> queue = new SynchronousQueue<Integer>();
        Thread putThread = new Thread(new Runnable(){
            @Override
            public void run(){
                System.out.println("put thread start");
                try{
                    queue.put(1);
                }catch(InterruptedException e){
                    
                }
                System.out.println("put thread end");
            }
        });
        
        Thread takeThread = new Thread(new Runnable(){
            @Override
            public void run(){
                System.out.println("take thread start");
                try{
                    System.out.println("take from putThread:"+queue.take());
                }catch(InterruptedException e){
                    
                }
                System.out.println("take thread end");
           }
        });
    }
}
```

**结果**

```java
put thread start
take thread start
take from putThread: 1
put thread end
take thread end
```

###### 实现原理

**公平模式下的模型**

初始化时，TransferQueue的状态如下：

![](.\png\java-synchronousQueue-1.png)

接着我们进行一些操作：

1、线程put1执行 put(1)操作，由于当前没有配对的消费线程，所以put1线程入队列，自旋一小会后睡眠等待，这时队列状态如下：

![](.\png\java-synchronousQueue-2.png)

2、接着，线程put2执行了put(2)操作，跟前面一样，put2线程入队列，自旋一小会后睡眠等待，这时队列状态如下：

![](.\png\java-synchronousQueue-3.png)

3、这时候，来了一个线程take1，执行了 take操作，由于tail指向put2线程，put2线程跟take1线程配对了(一put一take)，这时take1线程不需要入队，但是请注意了，这时候，要唤醒的线程并不是put2，而是put1。为何？ 大家应该知道我们现在讲的是公平策略，所谓公平就是谁先入队了，谁就优先被唤醒，我们的例子明显是put1应该优先被唤醒。至于读者可能会有一个疑问，明明是take1线程跟put2线程匹配上了，结果是put1线程被唤醒消费，怎么确保take1线程一定可以和次首节点(head.next)也是匹配的呢？其实大家可以拿个纸画一画，就会发现真的就是这样的。 
公平策略总结下来就是：队尾匹配队头出队。 
执行后put1线程被唤醒，take1线程的 take()方法返回了1(put1线程的数据)，这样就实现了线程间的一对一通信，这时候内部状态如下：
![](.\png\java-synchronousQueue-4.png)

4、最后，再来一个线程take2，执行take操作，这时候只有put2线程在等候，而且两个线程匹配上了，线程put2被唤醒， 
take2线程take操作返回了2(线程put2的数据)，这时候队列又回到了起点，如下所示：

![](.\png\java-synchronousQueue-5.png)

公平模式下：队尾匹配对头出队，先进先出。

**非公平模式下的模型**

非公平模式底层的实现使用的是TransferStack，一个栈，实现中用head指针指向栈顶，接着我们看看它的实现模型:

1、线程put1执行 put(1)操作，由于当前没有配对的消费线程，所以put1线程入栈，自旋一小会后睡眠等待，这时栈状态如下：

![](.\png\java-synchronousQueuee-nofair-1.png)

2、接着，线程put2再次执行了put(2)操作，跟前面一样，put2线程入栈，自旋一小会后睡眠等待，这时栈状态如下：

![](.\png\java-synchronousQueue-nofair-2.png)

3、这时候，来了一个线程take1，执行了take操作，这时候发现栈顶为put2线程，匹配成功，但是实现会先把take1线程入栈，然后take1线程循环执行匹配put2线程逻辑，一旦发现没有并发冲突，就会把栈顶指ReentrantLock 针直接指向 put1线程

![](.\png\java-synchronousQueue-nofair-3.png)

4、最后，再来一个线程take2，执行take操作，这跟步骤3的逻辑基本是一致的，take2线程入栈，然后在循环中匹配put1线程，最终全部匹配完毕，栈变为空，恢复初始状态，如下图所示：

![](.\png\java-synchronousQueue-nofair-4.png)

可以从上面流程看出，虽然put1线程先入栈了，但是却是后匹配，这就是非公平的由来。

##### ConcurrentLinkedQueue

ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。

###### 类图

![](.\png\java-ConcurrentLinkedQueue-类图.png)

1. 所有结构（head/tail/item/next）都是volatile类型。这是因为ConcurrentLinkedQueue是非阻塞的，所以只有volatile才能使变量的写操作对后续读操作是可见的。同样不会导致指令的重排序。
2. 所有结构的操作都带有原子操作，这是由AtomicReferenceFieldUpdater保证的。
3. 于队列中任何一个节点（Node）只有下一个节点的引用，所以这个队列是单向的，根据FIFO特性，也就是说出队列在头部(head)，入队列在尾部(tail)。头部保存有进入队列最长时间的元素，尾部是最近进入的元素。
4. 没有对队列长度进行计数，所以队列的长度是无限的，同时获取队列的长度的时间不是固定的，这需要遍历整个队列，并且这个计数也可能是不精确的。
5. 初始情况下队列头和队列尾都指向一个空节点，但是非null，这是为了方便操作，不需要每次去判断head/tail是否为空。但是head却不作为存取元素的节点，tail在不等于head情况下保存一个节点元素。也就是说head.item这个应该一直是空，但是tail.item却不一定是空（如果head!=tail，那么tail.item!=null）。

###### 入队列

```java
public boolean offer(E e) {
	if (e == null) throw new NullPointerException();
    Node<E> n = new Node<E>(e, null);
    for (;;) {
        Node<E> t = tail;
        Node<E> s = t.getNext();
        if (t == tail) {
            if (s == null) {
                if (t.casNext(s, n)) {
                    casTail(t, n);
                    return true;
                }
            } else {
                casTail(t, s);
            }
        }
    }
}
```

1. 获取尾节点t，以及尾节点的下一个节点s。如果尾节点没有被别人修改，也就是t==tail，进行2，否则进行1。
2. 如果s不为空，也就是说此时尾节点后面还有元素，那么就需要把尾节点往后移，进行1。否则进行3。
3. 修改尾节点的下一个节点为新节点，如果成功就修改尾节点，返回true。否则进行1。

**特别说明**

对尾节点的tail的操作需要换成临时变量t和s，一方面是为了去掉volatile变量的可变性，另一方面是为了减少volatile的性能影响。

##### LinkedTransferQueue

LinkedTransferQueue是基于链表的FIFO无界阻塞队列，它出现在JDK7中。Doug Lea 大神说**LinkedTransferQueue是一个聪明的队列**。它是ConcurrentLinkedQueue、SynchronousQueue (公平模式下)、无界的LinkedBlockingQueues等的超集。

###### 概念

LinkedTransferQueue采用一种**预占模式**。有就直接拿走，没有就占着这个位置直到拿到或者超时或者中断。即消费者线程到队列中取元素时，如果发现队列为空，则会生成一个null节点，然后park住等待生产者。后面如果生产者线程入队时发现有一个null元素节点，这时生产者就不会入列了，直接将元素填充到该节点上，唤醒该节点的线程，被唤醒的消费者线程拿东西走人。

###### 结构

LinkedTransferQueue与其他的BlockingQueue一样，同样继承AbstractQueue类，但是它实现了TransferQueue，TransferQueue接口继承BlockingQueue，所以TransferQueue算是对BlockingQueue一种扩充，该接口提供了一整套的transfer接口：

```java
public interface TransferQueue<E> extends BlockingQueue<E> {
	/**
	* 若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；
	* 若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作
	*/
	boolean tryTransfer(E e);

	/**
	* 若当前存在一个正在等待获取的消费者线程，即立刻移交之；
	* 否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素
	*/
	void transfer(E e) throws InterruptedException;

	/**
	* 若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；
	* 若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除。
	*/
	boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException;

	/**
	* 判断是否存在消费者线程
	*/
	boolean hasWaitingConsumer();
	
    /**
	* 获取所有等待获取元素的消费线程数量
	*/
	int getWaitingConsumerCount();
}
```

相对于其他的BlockingQueue，LinkedTransferQueue就多了上面几个方法。这几个方法在LinkedTransferQueue中起到了核心作用。

LinkedTransferQueue定义的变量如下：

```java
    // 判断是否为多核
    private static final boolean MP =
            Runtime.getRuntime().availableProcessors() > 1;

    // 自旋次数
    private static final int FRONT_SPINS   = 1 << 7;

    // 前驱节点正在处理，当前节点需要自旋的次数
    private static final int CHAINED_SPINS = FRONT_SPINS >>> 1;

    static final int SWEEP_THRESHOLD = 32;

    // 头节点
    transient volatile Node head;

    // 尾节点
    private transient volatile Node tail;

    // 删除节点失败的次数
    private transient volatile int sweepVotes;

    /*
     * 调用xfer()方法时需要传入,区分不同处理
     * xfer()方法是LinkedTransferQueue的最核心的方法
     */
    private static final int NOW   = 0; // for untimed poll, tryTransfer
    private static final int ASYNC = 1; // for offer, put, add
    private static final int SYNC  = 2; // for transfer, take
    private static final int TIMED = 3; // for timed poll, tryTransfer
```

###### Node节点

Node节点由四个部分构成：

- isData：表示该节点是存放数据还是获取数据
- item：存放数据，isData为false时，该节点为 null，为 true 时，匹配后，该节点会置为 null
- next：指向下一个节点
- waiter：park 住消费者线程，线程就放在这里



**源码如下：**

```java
static final class Node {
	// 表示该节点是存放数据还是获取数据
	final boolean isData;
	// 存放数据，isData为false时，该节点为null，为true时，匹配后，该节点会置为null
	volatile Object item;
	//指向下一个节点
	volatile Node next;

	// park住消费者线程，线程就放在这里
	volatile Thread waiter; // null until waiting

	/**
	* CAS Next域
	*/
	final boolean casNext(Node cmp, Node val) {
		return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
	}

	/**
	* CAS itme域
	*/
	final boolean casItem(Object cmp, Object val) {
		return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
	}

	/**
	* 构造函数
	*/
	Node(Object item, boolean isData) {
		UNSAFE.putObject(this, itemOffset, item); // relaxed write
		this.isData = isData;
	}

	/**
	* 将next域指向自身，其实就是剔除节点
	*/
	final void forgetNext() {
		UNSAFE.putObject(this, nextOffset, this);
	}

	/**
	*  匹配过或节点被取消的时候会调用
	*/
	final void forgetContents() {
		UNSAFE.putObject(this, itemOffset, this);
		UNSAFE.putObject(this, waiterOffset, null);
	}

	/**
	* 校验节点是否匹配过，如果匹配做取消了，item则会发生变化
	*/
	final boolean isMatched() {
		Object x = item;
		return (x == this) || ((x == null) == isData);
	}

	/**
	* 是否是一个未匹配的请求节点
	* 如果是的话isData应为false，item == null，因位如果匹配了，item则会有值
	*/
	final boolean isUnmatchedRequest() {
		return !isData && item == null;
	}

	/**
	* 如给定节点类型不能挂在当前节点后返回true
	*/
	final boolean cannotPrecede(boolean haveData) {
		boolean d = isData;
		Object x;
		return d != haveData && (x = item) != this && (x != null) == d;
	}

	/**
	* 匹配一个数据节点
	*/
	final boolean tryMatchData() {
		// assert isData;
		Object x = item;
		if (x != null && x != this && casItem(x, null)) {
			LockSupport.unpark(waiter);
			return true;
		}
		return false;
	}

	private static final long serialVersionUID = -3375979862319811754L;

	// Unsafe mechanics
	private static final sun.misc.Unsafe UNSAFE;
	private static final long itemOffset;
	private static final long nextOffset;
	private static final long waiterOffset;
	static {
		try {
			UNSAFE = sun.misc.Unsafe.getUnsafe();
			Class<?> k = Node.class;
			itemOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("item"));
			nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("next"));
			waiterOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("waiter"));
		} catch (Exception e) {
			throw new Error(e);
		}
	}
}
```

节点Node为LinkedTransferQueue的内部类，其内部结构和公平方式的SynchronousQueue差不多，里面也同样提供了一些很重要的方法。

###### put操作

LinkedTransferQueue提供了add、put、offer三类方法，用于将元素插入队列中，如下：

```java
public void put(E e) {
	xfer(e, true, ASYNC, 0);
}

public boolean offer(E e, long timeout, TimeUnit unit) {
	xfer(e, true, ASYNC, 0);
	return true;
}

public boolean offer(E e) {
	xfer(e, true, ASYNC, 0);
	return true;
}

public boolean add(E e) {
	xfer(e, true, ASYNC, 0);
	return true;
}
```

由于LinkedTransferQueue是无界的，不会阻塞，所以在调用xfer方法是传入的是ASYNC，同时直接返回true.

###### take操作

LinkedTransferQueue提供了poll、take方法用于出列元素：

```java
public E take() throws InterruptedException {
	E e = xfer(null, false, SYNC, 0);
	if (e != null)
		return e;
	Thread.interrupted();
	throw new InterruptedException();
}

public E poll() {
	return xfer(null, false, NOW, 0);
}

public E poll(long timeout, TimeUnit unit) throws InterruptedException {
	E e = xfer(null, false, TIMED, unit.toNanos(timeout));
	if (e != null || !Thread.interrupted())
		return e;
	throw new InterruptedException();
}
```

这里和put操作有点不一样，take()方法传入的是SYNC，阻塞。poll()传入的是NOW，poll(long timeout, TimeUnit unit)则是传入TIMED。

###### tranfer操作

实现TransferQueue接口，就要实现它的方法：

```java
public boolean tryTransfer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {
    if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)
        return true;
    if (!Thread.interrupted())
        return false;
    throw new InterruptedException();
}

public void transfer(E e) throws InterruptedException {
    if (xfer(e, true, SYNC, 0) != null) {
        Thread.interrupted(); // failure possible only due to interrupt
        throw new InterruptedException();
    }
}

public boolean tryTransfer(E e) {
    return xfer(e, true, NOW, 0) == null;
}
```

###### xfer()

过上面几个核心方法的源码我们清楚可以看到，最终都是调用xfer()方法，该方法接受四个参数，item或者null的E，put操作为true、take操作为false的havaData，how（有四个值NOW, ASYNC, SYNC, or TIMED，分别表示不同的操作），超时nanos。

```java
private E xfer(E e, boolean haveData, int how, long nanos) {
	// havaData为true，但是e == null 抛出空指针
	if (haveData && (e == null))
		throw new NullPointerException();
	Node s = null;                        // the node to append, if needed
retry:
	for (;;) {
		// 从首节点开始匹配
		// p == null 队列为空
		for (Node h = head, p = h; p != null;) {
			// 模型，request or data
			boolean isData = p.isData;
			// item域
			Object item = p.item;
			// 找到一个没有匹配的节点
			// item != p 也就是自身，则表示没有匹配过
			// (item != null) == isData，表示模型符合
			if (item != p && (item != null) == isData) {
				// 节点类型和待处理类型一致，这样肯定是不能匹配的
				if (isData == haveData)   // can't match
					break;
				// 匹配，将E加入到item域中
				// 如果p 的item为data，那么e为null,如果p的item为null，那么e为data
				if (p.casItem(item, e)) { // match
					//
					for (Node q = p; q != h;) {
						Node n = q.next;  // update by 2 unless singleton
						if (head == h && casHead(h, n == null ? q : n)) {
							h.forgetNext();
							break;
						}                 // advance and retry
						if ((h = head)   == null || (q = h.next) == null || !q.isMatched())
							break;        // unless slack < 2
					}

					// 匹配后唤醒p的waiter线程;reservation则叫人收货，data则叫null收货
					LockSupport.unpark(p.waiter);
					return LinkedTransferQueue.<E>cast(item);
				}
			}
			// 如果已经匹配了则向前推进
			Node n = p.next;
			// 如果p的next指向p本身，说明p节点已经有其他线程处理过了，只能从head重新开始
			p = (p != n) ? n : (h = head); // Use head if p offlist
		}

		// 如果没有找到匹配的节点，则进行处理
		// NOW为untimed poll, tryTransfer，不需要入队
		if (how != NOW) {                 // No matches available
			// s == null，新建一个节点
			if (s == null)
				s = new Node(e, haveData);
			// 入队，返回前驱节点
			Node pred = tryAppend(s, haveData);
			// 返回的前驱节点为null，那就是有race，被其他的抢了，那就continue 整个for
			if (pred == null)
				continue retry;
			// ASYNC不需要阻塞等待
			if (how != ASYNC)
				return awaitMatch(s, pred, e, (how == TIMED), nanos);
		}
		return e;
	}
}
```

整个算法的核心就是寻找匹配节点找到了就返回，否则就入队（NOW直接返回）：

- matched。判断匹配条件（isData不一样，本身没有匹配），匹配后就casItem，然后unpark匹配节点的waiter线程，如果是reservation则叫人收货，data则叫null收货。
- unmatched。如果没有找到匹配节点，则根据传入的how来处理，NOW直接返回，其余三种先入对，入队后如果是ASYNC则返回，SYNC和TIMED则会阻塞等待匹配。

其实相当于SynchronousQueue来说，这个处理逻辑还是比较简单的。

如果没有找到匹配节点，且how != NOW会入队，入队则是调用tryAppend方法：

```java
 private Node tryAppend(Node s, boolean haveData) {
	// 从尾节点tail开始
	for (Node t = tail, p = t;;) {
		Node n, u;

		// 队列为空则将节点S设置为head
		if (p == null && (p = head) == null) {
			if (casHead(null, s))
				return s;
		}

		// 如果为data
		else if (p.cannotPrecede(haveData))
			return null;

		// 不是最后一个节点
		else if ((n = p.next) != null) 
            p = p != t && t != (u = tail) ? (t = u) : (p != n) ? n : null;
		// CAS失败，一般来说失败的原因在于p.next != null，可能有其他增加了tail，向前推荐
		else if (!p.casNext(null, s))
			p = p.next;                   // re-read on CAS failure
		else {
			if (p != t) {                 // update if slack now >= 2
				while ((tail != t || !casTail(t, s)) && 
                       (t = tail)   != null && 
                       (s = t.next) != null && // advance and retry
						(s = s.next) != null && s != t);
			}
			return p;
		}
	}
}
```

tryAppend方法是将S节点添加到tail上，然后返回其前驱节点。

加入队列后，如果how还不是ASYNC则调用awaitMatch()方法阻塞等待：

```java
private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {
	// 超时控制
	final long deadline = timed ? System.nanoTime() + nanos : 0L;

	// 当前线程
	Thread w = Thread.currentThread();

	// 自旋次数
	int spins = -1; // initialized after first item and cancel checks

	// 随机数
	ThreadLocalRandom randomYields = null; // bound if needed

	for (;;) {
		Object item = s.item;
		//匹配了，可能有其他线程匹配了线程
		if (item != e) {
			// 撤销该节点
			s.forgetContents();
			return LinkedTransferQueue.<E>cast(item);
		}

		// 线程中断或者超时了。则调用将s节点item设置为e，等待取消
		if ((w.isInterrupted() || (timed && nanos <= 0)) && s.casItem(e, s)) {        // cancel
			// 断开节点
			unsplice(pred, s);
			return e;
		}

		// 自旋
		if (spins < 0) {
			// 计算自旋次数
			if ((spins = spinsFor(pred, s.isData)) > 0)
				randomYields = ThreadLocalRandom.current();
		}

		// 自旋
		else if (spins > 0) {
			--spins;
			// 生成的随机数 == 0 ，停止线程？不是很明白....
			if (randomYields.nextInt(CHAINED_SPINS) == 0)
				Thread.yield();
		}

		// 将当前线程设置到节点的waiter域
		// 一开始s.waiter == null 肯定是会成立的，
		else if (s.waiter == null) {
			s.waiter = w;                 // request unpark then recheck
		}

		// 超时阻塞
		else if (timed) {
			nanos = deadline - System.nanoTime();
			if (nanos > 0L)
				LockSupport.parkNanos(this, nanos);
		}
		else {
			// 不是超时阻塞
			LockSupport.park(this);
		}
	}
}
```

整个awaitMatch过程和SynchronousQueue的awaitFulfill没有很大区别，不过在自旋过程会调用Thread.yield();这是干嘛？

在awaitMatch过程中，如果线程中断了，或者超时了则会调用unsplice()方法去除该节点：

```java
final void unsplice(Node pred, Node s) {
	s.forgetContents(); // forget unneeded fields
	if (pred != null && pred != s && pred.next == s) {
		Node n = s.next;
		if (n == null ||(n != s && pred.casNext(s, n) && pred.isMatched())) {
			for (;;) {               // check if at, or could be, head
				Node h = head;
				if (h == pred || h == s || h == null)
					return;          // at head or list empty
				if (!h.isMatched())
					break;
				Node hn = h.next;
				if (hn == null)
					return;          // now empty
				if (hn != h && casHead(h, hn))
					h.forgetNext();  // advance head
			}
			if (pred.next != pred && s.next != s) { // recheck if offlist
				for (;;) {           // sweep now if enough votes
					int v = sweepVotes;
					if (v < SWEEP_THRESHOLD) {
						if (casSweepVotes(v, v + 1))
							break;
					}
					else if (casSweepVotes(v, 0)) {
						sweep();
						break;
					}
				}
			}
		}
	}
}
```

主体流程已经完成，这里总结下：

1. 无论是入对、出对，还是交换，最终都会跑到xfer(E e, boolean haveData, int how, long nanos)方法中，只不过传入的how不同而已
2. 如果队列不为空，则尝试在队列中寻找是否存在与该节点相匹配的节点，如果找到则将匹配节点的item设置e，然后唤醒匹配节点的waiter线程。如果是reservation则叫人收货，data则叫null收货
3. 如果队列为空，或者没有找到匹配的节点且how ！= NOW，则调用tryAppend()方法将节点添加到队列的tail，然后返回其前驱节点
4. 如果节点的how != NOW && how != ASYNC，则调用awaitMatch()方法阻塞等待，在阻塞等待过程中和SynchronousQuque的awaitFulfill()逻辑差不多，都是先自旋，然后判断是否需要自旋，如果中断或者超时了则将该节点从队列中移出

##### PriorityBlockingQueue

PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。

PriorityBlockingQueue底层采用二叉堆来实现的。**(二叉堆详见 数据结构-堆-二叉堆)**

###### 源码

```java
public class PriorityBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>,Serializable{
    // 默认容量
    private static final int DEFAULT_INITIAL_CAPACITY = 11;

    // 最大容量
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    // 二叉堆数组
    private transient Object[] queue;

    // 队列元素的个数
    private transient int size;

    // 比较器，如果为空，则为自然顺序
    private transient Comparator<? super E> comparator;

    // 内部锁
    private final ReentrantLock lock;

    private final Condition notEmpty;

    //
    private transient volatile int allocationSpinLock;

    // 优先队列：主要用于序列化，这是为了兼容之前的版本。只有在序列化和反序列化才非空
    private PriorityQueue<E> q;
}
```

内部仍然采用可重入锁ReentrantLock来实现同步机制，但是这里只有一个notEmpty的Condition。（PriorityBlockingQueue是一个无界队列）。

###### 入列

PriorityBlockingQueue提供put()、add()、offer()方法向队列中加入元素。我们这里从put()入手：put(E e) ：将指定元素插入此优先级队列。

```java
public void put(E e){
    offer(e);	//never need to block
}
```

PriorityBlockingQueue是无界的，所以不可能会阻塞。内部调用offer(E e)：

```java
public boolean offer(E e) {
	// 不能为null
	if (e == null)
		throw new NullPointerException();
	// 获取锁
	final ReentrantLock lock = this.lock;
	lock.lock();
	int n, cap;
	Object[] array;
	// 扩容
	while ((n = size) >= (cap = (array = queue).length))
		tryGrow(array, cap);
	try {
		Comparator<? super E> cmp = comparator;
		// 根据比较器是否为null，做不同的处理
		if (cmp == null)
			siftUpComparable(n, e, array);
		else
			siftUpUsingComparator(n, e, array, cmp);
		size = n + 1;
		// 唤醒正在等待的消费者线程
		notEmpty.signal();
	} finally {
		lock.unlock();
	}
	return true;
}
```

**siftUpComparable**

当比较器comparator为null时，采用自然排序，调用siftUpComparable方法：

```java
private static <T> void siftUpComparable(int k, T x, Object[] array) {
	Comparable<? super T> key = (Comparable<? super T>) x;
	// “上冒”过程
	while (k > 0) {
		// 父级节点 （n - ） / 2
		int parent = (k - 1) >>> 1;
		Object e = array[parent];

		// key >= parent 完成（最大堆）
		if (key.compareTo((T) e) >= 0)
			break;
		// key < parant 替换
		array[k] = e;
		k = parent;
	}
	array[k] = key;
}
```

将元素X插入到数组中，然后进行调整以保持二叉堆的特性

**siftUpUsingComparator**

当比较器不为null时，采用所指定的比较器，调用siftUpUsingComparator方法

```java
private static <T> void siftUpUsingComparator(int k, T x, Object[] array,
                                       Comparator<? super T> cmp) {
	while (k > 0) {
		int parent = (k - 1) >>> 1;
		Object e = array[parent];
		if (cmp.compare(x, (T) e) >= 0)
			break;
		array[k] = e;
		k = parent;
	}
	array[k] = x;
}
```

**tryGrow**

```java
private void tryGrow(Object[] array, int oldCap) {
	lock.unlock();      // 扩容操作使用自旋，不需要锁主锁，释放
	Object[] newArray = null;
	// CAS 占用
	if (allocationSpinLock == 0 && UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) {
		try {
			// 新容量  最小翻倍
			int newCap = oldCap + ((oldCap < 64) ? (oldCap + 2) :  (oldCap >> 1));
			// 超过
			if (newCap - MAX_ARRAY_SIZE > 0) {    // possible overflow
				int minCap = oldCap + 1;
				if (minCap < 0 || minCap > MAX_ARRAY_SIZE)
					throw new OutOfMemoryError();
				newCap = MAX_ARRAY_SIZE;        // 最大容量
			}
			if (newCap > oldCap && queue == array)
				newArray = new Object[newCap];
		} finally {
			allocationSpinLock = 0;     // 扩容后allocationSpinLock = 0 代表释放了自旋锁
        }
	}
	// 到这里如果是本线程扩容newArray肯定是不为null，为null就是其他线程在处理扩容，那就让给别的线程处理
	if (newArray == null)
		Thread.yield();
	// 主锁获取锁
	lock.lock();
	// 数组复制
	if (newArray != null && queue == array) {
		queue = newArray;
		System.arraycopy(array, 0, newArray, 0, oldCap);
	}
}
```

整个添加元素的过程和上面二叉堆一模一样：先将元素添加到数组末尾，然后采用“上冒”的方式将该元素尽量往上冒。

###### 出列

PriorityBlockingQueue提供poll()、remove()方法来执行出对操作。出对的永远都是第一个元素：array[0]

```java
public E poll() {
	final ReentrantLock lock = this.lock;
	lock.lock();
	try {
		return dequeue();
	} finally {
		lock.unlock();
	}
}
```

先获取锁，然后调用dequeue()方法

```java
private E dequeue() {
	// 没有元素 返回null
	int n = size - 1;
	if (n < 0)
		return null;
	else {
		Object[] array = queue;
		// 出对元素
		E result = (E) array[0];
		// 最后一个元素（也就是插入到空穴中的元素）
		E x = (E) array[n];
		array[n] = null;
		// 根据比较器释放为null，来执行不同的处理
		Comparator<? super E> cmp = comparator;
		if (cmp == null)
			siftDownComparable(0, x, array, n);
		else
			siftDownUsingComparator(0, x, array, n, cmp);
		size = n;
		return result;
	}
}
```

**siftDownComparable**

如果比较器为null，则调用siftDownComparable来进行自然排序处理：

```java
private static <T> void siftDownComparable(int k, T x, Object[] array,int n) {
	if (n > 0) {
		Comparable<? super T> key = (Comparable<? super T>)x;
		// 最后一个叶子节点的父节点位置
		int half = n >>> 1;
		while (k < half) {
			int child = (k << 1) + 1;       // 待调整位置左节点位置
			Object c = array[child];        //左节点
			int right = child + 1;          //右节点

			//左右节点比较，取较小的
			if (right < n &&((Comparable<? super T>) c).compareTo((T) array[right]) > 0)
				c = array[child = right];

			//如果待调整key最小，那就退出，直接赋值
			if (key.compareTo((T) c) <= 0)
				break;
			//如果key不是最小，那就取左右节点小的那个放到调整位置，然后小的那个节点位置开始再继续调整
			array[k] = c;
			k = child;
		}
		array[k] = key;
	}
}
```

处理思路和二叉堆删除节点的逻辑一样：就第一个元素定义为空穴，然后把最后一个元素取出来，尝试插入到空穴位置，并与两个子节点值进行比较，如果不符合，则与其中较小的子节点进行替换，然后继续比较调整。

**siftDownUsingComparator**

如果指定了比较器，则采用比较器来进行调整

```java
private static <T> void siftDownUsingComparator(int k, T x, Object[] array,int n,Comparator<? super T> cmp) {
	if (n > 0) {
		int half = n >>> 1;
		while (k < half) {
			int child = (k << 1) + 1;
			Object c = array[child];
			int right = child + 1;
			if (right < n && cmp.compare((T) c, (T) array[right]) > 0)
				c = array[child = right];
			if (cmp.compare(x, (T) c) <= 0)
				break;
			array[k] = c;
			k = child;
		}
		array[k] = x;
	}
}
```

PriorityBlockingQueue采用二叉堆来维护，所以整个处理过程不是很复杂，添加操作则是不断“上冒”，而删除操作则是不断“下掉”。掌握二叉堆就掌握了PriorityBlockingQueue，无论怎么变还是。对于PriorityBlockingQueue需要注意的是他是一个无界队列，所以添加操作是不会失败的，除非资源耗尽。

##### DelayQueue

DelayQueue是一个支持延时获取元素的无界阻塞队列。里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说**只有在延迟期到时才能够从队列中取元素**。

###### 使用场景

- 缓存：清掉缓存中超时的缓存数据
- 任务超时处理

###### 实现关键点

1. 可重入锁 ReentrantLock
2. 用于阻塞和通知的 Condition 对象
3. 根据 Delay 时间排序的优先级队列：PriorityQueue
4. 用于优化阻塞通知的线程元素 leader

###### Delayed

Delayed接口是用来标记那些应该在给定延迟时间之后执行的对象，它定义了一个long getDelay(TimeUnit unit)方法，该方法返回与此对象相关的的剩余时间。同时实现该接口的对象必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。

```java
public interface Delayed extends Comparable<Delayed>{
    long getDelay(TimeUnit unit);
}
```

实现该接口的getDelay()方法，同时定义compareTo()方法即可。

###### 内部结构

DelayQueue的定义

```java
public class DelayQueue<E extends Delayed> extends AbstractQueue<E> implements BlockingQueue<E> {
	/** 可重入锁 */
	private final transient ReentrantLock lock = new ReentrantLock();
	/** 支持优先级的BlockingQueue */
	private final PriorityQueue<E> q = new PriorityQueue<E>();
	/** 用于优化阻塞 */
	private Thread leader = null;
	/** Condition */
	private final Condition available = lock.newCondition();
	/**
	* 省略很多代码
	*/
}
```

DelayQueue的元素都必须继承Delayed接口。同时也可以从这里初步理清楚DelayQueue内部实现的机制了：以支持优先级无界队列的PriorityQueue作为一个容器，容器里面的元素都应该实现Delayed接口，在每次往优先级队列中添加元素时以元素的过期时间作为排序条件，最先过期的元素放在优先级最高。

###### offer

```java
public boolean offer(E e) {
	final ReentrantLock lock = this.lock;
	lock.lock();
	try {
		// 向 PriorityQueue中插入元素
		q.offer(e);
		// 如果当前元素的对首元素（优先级最高），leader设置为空，唤醒所有等待线程
		if (q.peek() == e) {
			leader = null;
			available.signal();
		}
		// 无界队列，永远返回true
		return true;
	} finally {
		lock.unlock();
	}
}
```

offer(E e)就是往PriorityQueue中添加元素。整个过程还是比较简单，但是在判断当前元素是否为队首元素，如果是的话则设置leader=null，这是非常关键的一个步骤。

###### take

```java
public E take() throws InterruptedException {
	final ReentrantLock lock = this.lock;
	lock.lockInterruptibly();
	try {
		for (;;) {
		// 队首元素
		E first = q.peek();
		// 队首为空，阻塞，等待off()操作唤醒
		if (first == null)
			available.await();
		else {
			// 获取队首元素的超时时间
			long delay = first.getDelay(NANOSECONDS);
			// <=0 表示已过期，出队，return
			if (delay <= 0)
				return q.poll();
			first = null; // don't retain ref while waiting
			// leader != null 证明有其他线程在操作，阻塞
			if (leader != null)
				available.await();
			else {
				// 否则将leader 设置为当前线程，独占
				Thread thisThread = Thread.currentThread();
				leader = thisThread;
				try {
					// 超时阻塞
					available.awaitNanos(delay);
				} finally {
					// 释放leader
					if (leader == thisThread)
						leader = null;
					}
				}
			}
		}
	} finally {
		// 唤醒阻塞线程
		if (leader == null && q.peek() != null)
			available.signal();
		lock.unlock();
	}
}
```

首先是获取队首元素，如果队首元素的延时时间 delay <= 0 ，则可以出队了，直接return即可。否则设置first = null，这里设置为null的主要目的是为了避免内存泄漏。如果 leader != null 则表示当前有线程占用，则阻塞，否则设置leader为当前线程，然后调用awaitNanos()方法超时等待。

**first = null**

这里为什么如果不设置first = null，则会引起内存泄漏呢？线程A到达，列首元素没有到期，设置leader = 线程A，这是线程B来了因为leader != null，则会阻塞，线程C一样。假如线程阻塞完毕了，获取列首元素成功，出列。这个时候列首元素应该会被回收掉，但是问题是它还被线程B、线程C持有着，所以不会回收，这里只有两个线程，如果有线程D、线程E…呢？这样会无限期的不能回收，就会造成内存泄漏。

##### 总结。

| 队列                  | 场景                                                         | 优点                                                         | 缺点                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ConcurrentLinkedQueue | Queue的最佳线程安全版本，在不适用阻塞功能下几乎是最有效的    | 使用原子操作，效率最高，同时是一种无界的队列                 | 不能阻塞线程，同时无法直接获取队列大小，也不能控制队列的容量 |
| LinkedBlockingQueue   | 基于链表的Queue的可阻塞线程安全版本，在需要阻塞且无界的环境下，这是一种不错的选择 | 可阻塞，入出队列锁分离，效率高，支持容量限制，可以作为无界的队列实现 | 由于存在锁机制，同时链表需要遍历，遍历才能准确定位元素，因此效率有一点的影响 |
| ArrayBlockingQueue    | 基于数组的Queue的可阻塞线程版本，在容量固定的环境下是一种不错的阻塞实现 | 可阻塞，入出队列效率更高，同时能省内存                       | 容量固定，不能扩容，入出队列不能同时进行，遍历元素更快       |
| PriorityBlockingQueue | 按照自然排序实现的阻塞队列，在元素需要排序的情况下是唯一的选择 | 可阻塞，元素有序，能够自动扩容                               | 出入队列比较慢，效率比较低，基于数组实现，每次扩容需要数组复制，同时容量不能减小，入队列不能够被阻塞 |
| SynchronousQueue      | 一种直接交换元素的实现，这在快速处理任务队列是最有效的方式   | 可阻塞，快速交换队列                                         | 内部没有容量                                                 |
| DelayQueue            | 延时处理队列的是吸纳，队列中每个元素都有一个延时时间，当且仅当延时时间过期后才出队列 | 可阻塞，可延时                                               | 基于排序的Queue实现，效率很低，入队列不能够被阻塞            |

如果不需要阻塞队列，优先选择ConcurrentLinkedQueue；如果需要阻塞队列，队列大小固定优先选择ArrayBlockingQueue，队列大小不固定优先选择LinkedBlockingQueue；如果需要对队列进行排序，选择PriorityBlockingQueue；如果需要一个快速交换的队列，选择SynchronousQueue；如果需要对队列中的元素进行延时操作，则选择DelayQueue。

#### Deque

##### 类图

![](.\png\java-Deque-类图.png)

##### 特点

- 允许在队列头部和尾部进行入队、出队操作
- Daque 不仅具有 FIFO 的 Queue 实现，还有 FILO 的实现

##### 方法

![](.\png\java-Daque-方法.png)

##### 分类

###### ArrayDeque

结构比较简单，只需要一个存储数据的数组以及头尾两个索引即可，队列满了以后就将队列容量扩大一倍。

![](.\png\java-ArrayDaque.png)

###### LinkedList

![](.\png\java-LinkedList.png)

###### LinkedBlockingDeque

无非是独占锁对一个双向链表的普通操作。

```java
public class LinkedBlockingDeque<E>
    extends AbstractQueue<E>
    implements BlockingDeque<E>, java.io.Serializable {

    // 双向链表的表头
    transient Node<E> first;

    // 双向链表的表尾
    transient Node<E> last;

    // 大小，双向链表中当前节点个数
    private transient int count;

    // 容量，在创建LinkedBlockingDeque时指定的
    private final int capacity;

    final ReentrantLock lock = new ReentrantLock();

    private final Condition notEmpty = lock.newCondition();

    private final Condition notFull = lock.newCondition();

}
```

LinkedBlockingDeque底层实现机制与LinkedBlockingQueue一样，依然是通过互斥锁ReentrantLock 来实现，notEmpty 、notFull 两个Condition做协调生产者、消费者问题。

**内部类 Node**

```java
 static final class Node<E> {
	E item;
	Node<E> prev;
	Node<E> next;
	Node(E x) {
		item = x;
	}
}
```

**基础方法**

LinkedBlockingDeque 的add、put、offer、take、peek、poll系列方法都是通过调用XXXFirst，XXXLast方法。



putFirst

putFirst(E e) :将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。

```java
public void putFirst(E e) throws InterruptedException {
	// check null
	if (e == null) throw new NullPointerException();
	Node<E> node = new Node<E>(e);
	// 获取锁
	final ReentrantLock lock = this.lock;
	lock.lock();
	try {
		while (!linkFirst(node))
			// 在notFull条件上等待，直到被唤醒或中断
  		notFull.await();
	} finally {
		// 释放锁
		lock.unlock();
	}
}
```

先获取锁，然后调用linkFirst方法入列，最后释放锁。如果队列是满的则在notFull上面等待。linkFirst设置Node为对头：

```java
private boolean linkFirst(Node<E> node) {
	// 超出容量
	if (count >= capacity)
		return false;

	// 首节点
	Node<E> f = first;
	// 新节点的next指向原first
	node.next = f;
	// 设置node为新的first
	first = node;

 	// 没有尾节点，设置node为尾节点
 	if (last == null)
		last = node;
	// 有尾节点，那就将之前first的pre指向新增node
	else
		f.prev = node;
	++count;
	// 唤醒notEmpty
	notEmpty.signal();
	return true;
}
```

linkFirst主要是设置node节点队列的列头节点，成功返回true，如果队列满了返回false。整个过程还是比较简单的。

#### List/Set

##### CopyOnWriteArrayList

###### 基本思想

一旦对容器有修改，那么就“复制”一份新的集合，在新的集合上修改，然后将新的集合复制给旧的引用。当然这部分少不了要加锁。“读”操作不需要锁。

##### CopyOnWriteArraySet

CopyOnWriteArraySet 的内部结构使用的是 CopyOnWriteArrayList，区别是在调用 add 方法的时候做了是否重复的判断。

##### COW的优缺点

###### 优点

- 读取和查询操作效率很高
- 迭代效率很高
- 多个线程同时写不会有问题

###### 缺点

- 由于数组的复制而带来额外的开销
- 不能保证数据的实时性，只能保证最终一致性。（读的时候有线程正在写的话还是读到旧的数据）
- 迭代的时候不支持写操作（虽然实现了ListIterator接口）



### 工具集

#### Exchanger

##### 定义

可以在对中对元素进行配对和交换的线程的同步点。每个线程将条目上的某个方法呈现给 exchange 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象。Exchanger 可能被视为 SynchronousQueue 的双向形式。

具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。

##### 示例

用 Exchanger 来模拟生产-消费者问题：

```java
public class ExchangerTest{
    static class Producer implements Runnable{
        //生产者、消费者交换的数据结构
        private List<String> buffer;
        
        //生产者和消费者的交换对象
        private Exchanger<String> exchanger;
        
        Producer(List<String> buffer,Exchanger<List<String>> exchanger){
            this.buffer = buffer;
            this.exchanger = exchanger;
        }
        
        @Override
        public void run() {
            for(int i = 1 ; i < 5 ; i++){
                System.out.println("生产者第" + i + "次提供");
                for(int j = 1 ; j <= 3 ; j++){
                    System.out.println("生产者装入" + i  + "--" + j);
                    buffer.add("buffer：" + i + "--" + j);
                }

                System.out.println("生产者装满，等待与消费者交换...");
                try {
                    exchanger.exchange(buffer);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    static class Consumer implements Runnable {
        private List<String> buffer;

        private final Exchanger<List<String>> exchanger;

        public Consumer(List<String> buffer, Exchanger<List<String>> exchanger) {
            this.buffer = buffer;
            this.exchanger = exchanger;
        }

        @Override
        public void run() {
            for (int i = 1; i < 5; i++) {
                //调用exchange()与消费者进行数据交换
                try {
                    buffer = exchanger.exchange(buffer);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("消费者第" + i + "次提取");
                for (int j = 1; j <= 3 ; j++) {
                    System.out.println("消费者 : " + buffer.get(0));
                    buffer.remove(0);
                }
            }
        }
    }

    public static void main(String[] args){
        List<String> buffer1 = new ArrayList<String>();
        List<String> buffer2 = new ArrayList<String>();

        Exchanger<List<String>> exchanger = new Exchanger<List<String>>();

        Thread producerThread = new Thread(new Producer(buffer1,exchanger));
        Thread consumerThread = new Thread(new Consumer(buffer2,exchanger));

        producerThread.start();
        consumerThread.start();
    }
    
}
```

首先生产者Producer、消费者Consumer首先都创建一个缓冲列表，通过Exchanger来同步交换数据。消费中通过调用Exchanger与生产者进行同步来获取数据，而生产者则通过for循环向缓存队列存储数据并使用exchanger对象消费者同步。到消费者从exchanger哪里得到数据后，他的缓冲列表中有3个数据，而生产者得到的则是一个空的列表。上面的例子充分展示了消费者-生产者是如何利用Exchanger来完成数据交换的。

在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种：

1. 如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。
2. 如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。
3. 如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。

##### 原理

见 http://cmsblogs.com/?p=2269



### 常见的并发场景

#### 线程池

常见于 Web 容器的线程池

#### 任务队列

安全的任务队列能够有效的平衡机器的复杂，抵消由于峰值和波动带来的不稳定，有效提高服务的可靠性

#### 异步处理

某些不需要同步返回的操作使用异步处理后能够有效的提高吞吐量

#### 同步操作



#### 分布式锁

### 常见的并发陷阱

#### volatile

只能强调数据的可见性，并不能保证原子操作和线程安全。

##### 常见使用场景

- 循环检测机制

  ```JAVA
  volatile boolean done = false;
  .....
  while(!done){
      dosomething();
  }
  ```

- 单例模式（DCL）

  ```java
  public class DoubleLockSingleton {
  
      private static volatile DoubleLockSingleton instance = null;
  
      private DoubleLockSingleton() {
      }
  
      public static DoubleLockSingleton getInstance() {
          if (instance == null) {
              synchronized (DoubleLockSingleton.class) {
                  if (instance == null) {
                      instance = new DoubleLockSingleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

#### synchronized/Lock

synchronized的性能随着JDK版本的升级会越来越高。

复杂的逻辑，如果涉及到读写锁、条件变量、更高的吞吐量以及更灵活、动态的用法，那么就可以考虑使用Lock。

synchronized无法做到的尝试锁机制，或者说担心发生死锁无法自恢复，那么使用tryLock()是一个比较明智的选择的。

#### 锁的边界

一个流行的错误是这样的。

```java
ConcurrentMap<String,String> map = new ConcurrentHashMap<String,String>();

if(!map.containsKey(key)){
    map.put(key,value);
}
```

看起来很合理的，对于一个线程安全的Map实现，要存取一个不重复的结果，先检测是否存在然后加入。 其实我们知道两个原子操作和在一起的指令序列不代表就是线程安全的。 割裂的多个原子操作放在一起在多线程的情况下就有可能发生错误。

实际上ConcurrentMap提供了putIfAbsent(K, V)的“原子操作”机制，这等价于下面的逻辑：

```java
if(map.containsKey(key)){
    return map.get(key);
}else{
    return map.put(k,v);
}
```

除了putIfAbsent还有replace(K, V)以及replace(K, V, V)两种机制来完成组合的操作。

#### 构造函数启动线程

```java
public class Runner{
   int x,y;
   Thread thread;
   public Runner(){
      this.x=1;
      this.y=2;
      this.thread=new MyThread();
      this.thread.start();
   }
}
```

这里可能存在的陷阱是如果此类被继承，那么启动的线程可能无法正确读取子类的初始化操作。

因此一个简单的原则是，禁止在构造函数中启动线程，可以考虑但是提供一个方法来启动线程。如果非要这么做，最好将类设置为final，禁止继承。

#### 丢失通知的问题

对于wait/notify/notifyAll以及await/singal/singalAll，如果不确定到底是否能够正确的收到消息，担心丢失通知，简单一点就是总是通知所有。

如果担心只收到一次消息，使用循环一直监听是不错的选择。

#### 线程数

线程数多少没有一个固定的结论，受限于CPU的内核数，IO的性能以及依赖的服务等等。因此选择一个合适的线程数有助于提高吞吐量。

### 性能与伸缩性

#### 性能与伸缩性

性能的提升通常意味着可以用更少的资源做更多的事情。这里资源是包括我们常说的CPU周期、内存、网络带宽、磁盘IO、数据库、WEB服务等等。 引入多线程可以充分利用多核的优势，充分利用IO阻塞带来的延迟，也可以降低网络开销带来的影响，从而提高单位时间内的响应效率。

为了衡量系统的性能，有一些指标用于定性、定量的分析。例如服务时间、等待时间、吞吐量、效率、可伸缩性、生成量等等。服务时间、等待时间等用于衡量系统的效率，即到底有多快。吞吐量、生成量等用于衡量系统的容量，即能够处理多少数据。除此之外，有效服务时间、中断时间等用于能力系统的可靠性和稳定性等。

可伸缩性的意思是指增加计算资源，吞吐量和生产量相应得到的改进。 从算法的角度讲，通常用复杂度来衡量其对应的性能。例如时间复杂度、空间复杂度等。

#### Amdahl 定律

并行的任务增加资源显然能够提高性能，但是如果是串行的任务，增加资源并不一定能够得到合理的性能提升。 Amdahl定律描述的在一个系统中，增加处理器资源对系统行的提升比率。 假定在一个系统中，F是必须串行化执行的比重，N是处理器资源，那么随着N的增加最多增加的加速比：

![](.\png\amdahl.png)

理论上，当N趋近于无穷大时，加速比最大值无限趋近于1/F。 这意味着如果一个程序的串行化比重为50%，那么并行化后最大加速比为2倍。

加速比除了可以用于加速的比率外，也可以用于衡量CPU资源的利用率。如果每一个CPU的资源利用率为100%，那么CPU的资源每次翻倍时，加速比也应该翻倍。 事实上，在拥有10个处理器的系统中，程序如果有10%是串行化的，那么最多可以加速1/(0.1+(1-0.1)/10)=5.3倍，换句话说CPU的利用率只用5.3/10=53%。而如果处理器增加到100倍，那么加速比为9.2倍，也就是说CPU的利用率只有个9.3%。

#### 性能提升

##### 系统平台的资源利用率

资源利用率=有效繁忙时间/总耗费时间。

##### 延迟

延迟描述的是完成任务所耗费的时间。延迟有时候也成为响应时间。如果有多个并行的操作，那么延迟取决于耗费时间最大的任务。

##### 多处理

多处理是指在单一系统上同时执行多个进程或者多个程序的能力。多处理能力的好处是可以提高吞吐量。多处理可以有效利用多核CPU的资源。

##### 多线程

多线程描述的是同一个地址空间内同时执行多个线程的过程。这些线程都有不同的执行路径和不同的栈结构。我们说的并发性更多的是指针对线程。

##### 并发性

同时执行多个程序或者任务称之为并发。单程序内的多任务处理或者多程序间的多任务处理都认为是并发。

##### 吞吐量

吞吐量衡量系统在单位之间内可以完成的工作总量。对于硬件系统而言，吞吐量是物理介质的上限。在没有达到物理介质之前，提高系统的吞吐量也可以大幅度改进性能。同时吞吐量也是衡量性能的一个指标。

##### 瓶颈

程序运行过程中性能最差的地方。通常而言，串行的IO、磁盘IO、内存单元分配、网络IO等都可能造成瓶颈。某些使用太频繁的算法也有可能成为瓶颈。

##### 可扩展性

可扩展性主要是指程序或系统通过增加可使用的资源而增加性能的能力。

#### 线程开销

##### 切换上下文

如果可运行的线程数大于CPU的内核数，那么OS会根据一定的调度算法，强行切换正在运行的线程，从而使其它线程能够使用CPU周期。

切换线程会导致上下文切换。线程的调度会导致CPU需要在操作系统和进程间花费更多的时间片段，这样真正执行应用程序的时间就减少了。另外上下文切换也会导致缓存的频繁进出，对于一个刚被切换的线程来说，可能由于高速缓冲中没有数据而变得更慢，从而导致更多的IO开销。

##### 内存同步

不同线程间要进行数据同步，synchronized以及volatile提供的可见性都会导致缓存失效。线程栈之间的数据要和主存进行同步，这些同步有一些小小的开销。如果线程间同时要进行数据同步，那么这些同步的线程可能都会受阻。

##### 阻塞

当发生锁竞争时，失败的线程会导致阻塞。通常阻塞的线程可能在JVM内部进行自旋等待，或者被操作系统挂起。自旋等待可能会导致更多的CPU切片浪费，而操作系统挂起则会导致更多的上下文切换。



# 参考资料

《深入浅出 Java Concurrency》 http://www.blogjava.net/xylz/archive/2010/07/08/325587.html

《死磕Java并发》 http://cmsblogs.com/?p=2611

《并发编程网》 http://ifeve.com/