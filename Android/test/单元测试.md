# 单元测试

## 目的

- 列出想要测试覆盖的正常、异常情况，进行测试验证;
- 性能测试，例如某个算法的耗时等等。
- 模拟输入和输出。

## 分类

1. 本地测试(Local tests): 只在本地机器JVM上运行，以最小化执行时间，这种单元测试不依赖于Android框架，或者即使有依赖，也很方便使用模拟框架来模拟依赖，以达到隔离Android依赖的目的，模拟框架如google推荐的[**Mockito**]
2. 仪器化测试(Instrumented tests): 在真机或模拟器上运行的单元测试，由于需要跑到设备上，比较慢，这些测试可以访问仪器（Android系统）信息，比如被测应用程序的上下文，一般地，依赖不太方便通过模拟框架模拟时采用这种方式。

## 单元测试的范围

在Android项目中，单元测试的对象是组件状态、控件行为、界面元素和自定义函数。

并不推荐对每个函数进行一对一的测试。

在大型项目中，遇到需要改动基类中代码的需求时，往往不能准确快速地知道改动后的影响范围，紧急时多采用创建子类覆盖父类函数的办法，但这不是长久之计，在足够覆盖率的单元测试支持下，跑一下单元测试就知道某个函数改动后的影响，可以放心地修改基类。

## 单元测试的流程

![](.\png\单元测试执行流程.jpg)



## 单元测试框架

- Java单元测试框架

  JUnit、Mockito、Powermockito等

- Android单元测试框架

  Robolectric、AndroidJUnitRunner、Espresso等

### 官网

- JUnit

  https://junit.org/junit5/

- Mockito

  https://site.mockito.org/

- Robolectric

  http://robolectric.org/

- Android-testing-support-library

  

- 



### 区别

1. junit运行在**jvm**上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito**隔离依赖**（下面会谈及）。
2. **AndroidJUnitRunner**，Google官方的android单元测试框架之一，使用跟**Junit**是一样的，只不过需要运行在android真机或模拟器环境。**AndroidJUnitRunner不能使用mockito**。
3. **Robolectric**运行在**jvm**上，但是框架本身引入了android依赖库，所以可以做android单元测试，运行速度比运行在真机or模拟器快。但Robolectric也有局限性，例如不支持加载so，测试代码也有点别扭。当然，robolectric可以配合junit、mockito使用。
4. **Espresso**也是Google官方的android单元测试框架之一，强大就不用说了，测试代码非常简洁。Espresso本身运行在真机上，因此android任何代码都能运行，不像junit&mockito那样隔离依赖。缺点也是显而易见，由于运行在真机，不能避免**“慢”**。



## Java单元测试

### 目标函数

1. 有明确的返回值，只需调用这个函数，然后验证函数的返回值是否符合预期结果。
2. 这个函数只改变其对象内部的一些属性或者状态，函数本身没有返回值，就验证它所改变的属性和状态
3. 一些函数没有返回值，也没有直接改变哪个值的状态，这就需要验证其行为，比如点击事件。

### JUnit

#### 添加依赖

```groovy
dependencies{
    testCompile 'junit:junit:4.1.2'
}
```

#### Assert类中主要方法如下：

| 方法名            | 方法描述                               |
| ----------------- | -------------------------------------- |
| assertEquals      | 断言传入的预期值与实际值是相等的       |
| assertNotEquals   | 断言传入的预期值与实际值是不相等的     |
| assertArrayEquals | 断言传入的预期数组与实际数组是相等的   |
| assertNull        | 断言传入的对象是为空                   |
| assertNotNull     | 断言传入的对象是不为空                 |
| assertTrue        | 断言条件为真                           |
| assertFalse       | 断言条件为假                           |
| assertSame        | 断言两个对象引用同一个对象，相当于“==” |
| assertNotSame     | 断言两个对象引用不同的对象，相当于“!=” |
| assertThat        | 断言实际值是否满足指定的条件           |

##### 注意

上面的每一个方法，都有对应的重载方法，可以在前面加一个String类型的参数，表示如果断言失败时的提示。

#### JUnit注解

| Annotation                                                   | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| @Test<br>public void method()                                | 定义所在方法为单元测试方法                                   |
| @Test(expected = Exception.class)<br>public void method()    | 测试方法若没有抛出Annotation中的Exception类型(子类也可以)->失败 |
| @Test(timeout=100) <br>public void method()                  | 性能测试，如果方法耗时超过100毫秒->失败                      |
| @Before<br>public void method()                              | 这个方法在每个测试之前执行，用于准备测试环境(如: 初始化类，读输入流等)，在一个测试类中，每个@Test方法的执行都会触发一次调用。 |
| @After<br>public void method()                               | 这个方法在每个测试之后执行，用于清理测试环境数据，在一个测试类中，每个@Test方法的执行都会触发一次调用 |
| @BeforeClass<br>public static void method()                  | 这个方法在所有测试开始之前执行一次，用于做一些耗时的初始化工作(如: 连接数据库)，方法必须是static |
| @AfterClass<br>public static void method()                   | 这个方法在所有测试结束之后执行一次，用于清理数据(如: 断开数据连接)，方法必须是static |
| @Ignore或者@Ignore("太耗时") <br>public void method()        | 忽略当前测试方法，一般用于测试方法还没有准备好，或者太耗时之类的 |
| @FixMethodOrder(MethodSorters.NAME_ASCENDING) <br>public class TestClass{} | 使得该测试类中的所有测试方法都按照方法名的字母顺序执行，可以指定3个值，分别是DEFAULT、JVM、NAME_ASCENDING |
| @Rule                                                        | 重新制定测试类中方法的行为                                   |

##### 执行顺序

@BeforeClass –> @Before –> @Test –> @After –> @AfterClass

#### JUnit Rule



#### 示例

##### 示例一

![](.\png\java单元测试.png)



##### 示例二 测试抛异常

```java
public class DateUtilTest{
    
    @After
    public void tearDown() throws Exception{
        System.out.println("测试结束");
    }
    
    @Test(expected = ParseException.class)
    public void dataToStampTest() throws Exception{
        DataUtil.dataToStamp("201710-15");
    }
}
```

**抛出了对应的异常则测试成功，反之则测试失败。**

##### 参数化测试

每次测试一个方法都要去设置对应的值，就不能连续用不不同的值去测试一个方法，省的我们不断地修改。这时就用到了@RunWith与@Parameters。

首先在测试类上添加注解@RunWith(Parameterized.class)，在创建一个由 **@Parameters 注解的public static方法**，让返回一个对应的测试数据集合。**最后创建构造方法，方法的参数顺序和类型与测试数据集合一一对应**。

```java
@RunWith(Parameterized.class)
public class DateFormatTest{
    private String time;
    
    public DateFormatTest(String time){
        this.time = time;
    }
    
    @Parameterized.Parameters
    public static Collection primeNumbers(){
        return Array.asList(new String[]{
            "2019-09-12",
            "2019-09-30 16:00:02",
            "2019年07月15日 16时00分02秒"
        });
    }
    
    @Test(expected = ParseException.class)
    public void dateToStampTest1() throws Exception{
        DateUtil.dataToStamp(time);
    }
}
```

##### assertThat用法

```java
assertThat(T actual, Matcher<? super T> matcher);
assertThat(String reason, T actual, Matcher<? super T> matcher);
```

其中`reason`为断言失败时的输出信息，`actual`为断言的值，`matcher`为断言的匹配器。

###### 常用的匹配器

| 匹配器                                                       | 说明                               | 例子                                              |
| ------------------------------------------------------------ | ---------------------------------- | ------------------------------------------------- |
| is                                                           | 断言参数等于后面给出的匹配表达式   | assertThat(5, is (5));                            |
| not                                                          | 断言参数不等于后面给出的匹配表达式 | assertThat(5, not(6));                            |
| equalTo                                                      | 断言参数相等                       | assertThat(30, equalTo(30));                      |
| equalToIgnoringCase                                          | 断言字符串相等忽略大小写           | assertThat(“Ab”, equalToIgnoringCase(“ab”));      |
| containsString                                               | 断言字符串包含某字符串             | assertThat(“abc”, containsString(“bc”));          |
| startsWith                                                   | 断言字符串以某字符串开始           | assertThat(“abc”, startsWith(“a”));               |
| endsWith                                                     | 断言字符串以某字符串结束           | assertThat(“abc”, endsWith(“c”));                 |
| nullValue                                                    | 断言参数的值为null                 | assertThat(null, nullValue());                    |
| notNullValue                                                 | 断言参数的值不为null               | assertThat(“abc”, notNullValue());                |
| greaterThan                                                  | 断言参数大于                       | assertThat(4, greaterThan(3));                    |
| lessThan                                                     | 断言参数小于                       | assertThat(4, lessThan(6));                       |
| greaterThanOrEqualTo                                         | 断言参数大于等于                   | assertThat(4, greaterThanOrEqualTo(3));           |
| lessThanOrEqualTo                                            | 断言参数小于等于                   | assertThat(4, lessThanOrEqualTo(6));              |
| closeTo                                                      | 断言浮点型数在某一范围内           | assertThat(4.0, closeTo(2.6, 4.3));               |
| allOf                                                        | 断言符合所有条件，相当于&&         | assertThat(4,allOf(greaterThan(3), lessThan(6))); |
| anyOf                                                        | 断言符合某一条件，相当于或         | assertThat(4,anyOf(greaterThan(9), lessThan(6))); |
| hasKey                                                       | 断言Map集合含有此键                | assertThat(map, hasKey(“key”));                   |
| hasValue                                                     | 断言Map集合含有此值                | assertThat(map, hasValue(value));                 |
| hasItem断言迭代对象含有此元素assertThat(list, hasItem(element)); |                                    |                                                   |

###### 自定义匹配器

继承 BaseMatcher 抽象类，实现 matches 与 describeTo 方法。代码如下：

```java
public class IsMobilePhoneMatcher extends BaseMatcher<String> {

    /**
     * 进行断言判定，返回true则断言成功，否则断言失败
     */

    @Override
    public boolean matches(Object item) {
        if (item == null) {
            return false;
        }

        Pattern pattern = Pattern.compile("(1|861)(3|5|7|8)\\d{9}$*");
        Matcher matcher = pattern.matcher((String) item);

        return matcher.find();
    }

    /**
     * 给期待断言成功的对象增加描述
     */
    @Override
    public void describeTo(Description description) {
        description.appendText("预计此字符串是手机号码！");
    }

    /**
     * 给断言失败的对象增加描述
     */
    @Override
    public void describeMismatch(Object item, Description description) {
        description.appendText(item.toString() + "不是手机号码！");
    }
}
```

##### @Rule 用法

还记得一开始我们在@Before与@After注解的方法中加入”测试开始”的提示信息吗？假如我们**一直需要这样的提示**，那是不是需要每次在测试类中去实现它。这样就会比较麻烦。这时你就可以使用@Rule来解决这个问题，它甚至比@Before与@After还要强大。

自定义@Rule很简单，就是实现TestRule 接口，实现apply方法。代码如下：

```java
public class MyRule implements TestRule {

    @Override
    public Statement apply(final Statement base, final Description description) {

        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                // evaluate前执行方法相当于@Before
                String methodName = description.getMethodName(); // 获取测试方法的名字
                System.out.println(methodName + "测试开始！");

                base.evaluate();  // 运行的测试方法

                // evaluate后执行方法相当于@After
                System.out.println(methodName + "测试结束！");
            }
        };
    }

}
```

其中apply方法中的base参数代表单元测试的语句，他身上的方法：

```java
base.evaluate();	//执行单元测试操作
```

而description则可以获取改单元测试方法的名称、注解、类名等等的描述。

#### Verify

**作用：**验证函数是否被调用（以及调用了多少次）

```java
public class CalculaterTest{
    @Test
    public void testAdd2(){
        calculater = mock(Calculater.class);
        calculater.add(1,2);
        
        verify(calculater).add(1,2);	//验证calculater.add(a, b)是否被调用过
    }
}
```

#### 批量测试和生成报告

假设你只有一个类或者只有几个类需要测试的话，那可以直接使用上文说的方法来测试，但是假设你有很多的类和方法需要测试的话上面的操作就显得是十分笨拙。Android Studio的Gradle插件为我们生成了三个任务：

- testDebugUnitTest
- testReleaseUnitTest
- test

 其中前两个任务是分别执行为Debug和Release模式下的所有单元测试，第三个任务就是执行前面两个任务。

可以在Terminal里面使用

```shell
gradlew testDebugUnitTest
```

来执行命令，由于是Wrapper可能需要额外的下载配置时间，也可以直接在面板中选择Task执行（使用本地的Gradle）：

![](.\png\gradle_task_test.jpg)

等待执行完成就可以看到`build/reports/tests/`目录下对应的Html报告：

![](.\png\test_html.jpg)

使用浏览器打开可以看到详细测试报告。

### Mockito

Mockito本质上就是在代理对象调用方法前，用stub的方式设置其返回值，然后在真实调用时，用代理对象返回起预设的返回值。

```java
public interface IMathUtils {
    public int abs(int num); // 求绝对值
}
```



```java
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class MockTest {

    public static void main(String[] args) {
        IMathUtils mathUtils = mock(IMathUtils.class); // 生成mock对象

        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1

        int abs = mathUtils.abs(-1); // 输出结果 1
        
        Assert.assertEquals(abs, 1);// 测试通过
    }
}
```

可以发现`IMathUtils`是一个接口，根本就没有实现，用**Mockito**框架`mock`之后，`IMathUtils.abs(-1)`就有`返回值1`了。这就是Mockito神奇的地方！Mockito代理了`IMathUtils.abs(num)`的行为，只要调用时符合**指定参数**（代码中指定参数`-1`），就可以得到**映射的返回值**。



## Android单元测试

在Android中，单元测试的本质依旧是验证函数的功能，测试框架也是JUnit。在Android中，编写代码需要面对的是组件、控件、生命周期、异步任务、消息传递等，虽然本质是SDK主动执行了一些实例的函数，但创建一个Activity并不能让它执行到resume的状态，因此需要JUnit之外的框架支持。

当前主流的单元测试框架**AndroidTest**和**Robolectric**，前者需要运行在Android环境上，后者可以直接运行在JVM上，速度也更快，可以直接由Jenkins周期性执行，无需准备Android环境。



### 本地测试

根据单元有没有外部依赖（如Android依赖、其他单元的依赖），将本地测试分为两类。

#### 没有依赖

本地JVM虚拟机就能提供足够的运行环境。

##### 1. 添加依赖，google官方推荐

```groovy
dependencies{
    //Required -- JUnit 4 framework
    testImplementation 'junit:junit:4.12'
    //Optional -- Mokito framework(可选，用于模拟一些依赖对象，以达到隔离依赖的效果)
    testImplementation 'org.mockito:mockito-core:2.19.0'
}
```

##### 2. 单元测试代码存储位置

app/src/test/java （本地单元测试）

##### 3. 创建测试类

可以自己手动在相应目录创建测试类，AS也提供了一种快捷方式：选择对应的类->将光标停留在类名上->按下ALT + ENTER->在弹出的弹窗中选择Create Test

###### 说明

勾选`setUp/@Before`会生成一个带`@Before`注解的`setUp()`空方法，`tearDown/@After`则会生成一个`带@After`的空方法。

##### 4. 运行测试用例

1. 运行单个测试方法：选中@Test注解或者方法名，右键选择**Run**；
2. 运行一个测试类中的所有测试方法：打开类文件，在类的范围内右键选择 Run，或者直接选择类文件直接右键Run
3. 运行一个目录下的所有测试类：选择这个目录，右键 Run

也可以通过命令 gradle test 来运行所有的测试用例，这种方法可以添加如下配置，输出单元测试过程中各类测试信息：

```groovy
android{
    ...
    testOptions.unitTests.all{
        testLogging{
            events 'passed','skipped','failed','standardOut','standardError'
            outputs.upTpDateWhen{false}
            showStandardStreams = true
        }
    }
}
```

```shell
gradlew test
```

#### 存在依赖

如果要测试的单元依赖了Android框架，比如用到了Android中的Context类的一些方法，本地JVM将无法提供这样的环境，这时候模拟框架 **Mockito** 就派上用场了。

##### 示例

一个Context#getString(int) 的测试用例

```java
@RunWith(MockitoJUnitRunner.class)
public class MockUnitTest{
    private static final String FAKE_STRING ="AndroidUnitTest";
    
    @Mock
    Context mMockContext;
    
    @Test
    public void readStringFromContext_LocalizedString(){
        //模拟方法调用的返回值，隔离对Android系统的依赖
        when(mMockContext.getString(R.string.app_name)).thenReturn(FAKE_STRING);
        assertThat(mMockContext.getString(R.string.app_name),is(FAKE_STRING));
        
        when(mMockContext.getPackageName()).thenReturn("com.jdqm.androidunittest");
        System.out.println(mMockContext.getPackageName());
    }
}
```

通过模拟框架 **Mockito** ，指定调用 context.getString(int) 方法的返回值，达到了隔离依赖的目的，其中 Mockito 使用的是 **cglib** 动态代理技术。 

### 仪器化测试

在某些情况下，虽然可以通过模拟的手段来隔离Android系统的依赖，但代价很大，这种情况下可以考虑仪器化的单元测试，有助于减少编写和维护模拟代码所需的工作量。

仪器化测试是在真机或模拟器上运行的测试，它们可以利用Android framework APIs 和 supporting APIs。如果测试用例需要访问仪器(instrumentation)信息(如应用程序的Context)，或者需要Android框架组件的真正实现(如Parcelable或SharedPreferences对象)，那么应该创建仪器化单元测试，由于要跑到真机或模拟器上，所以会慢一些。

#### 配置

```groovy
dependencies{
	androidTestImplementation 'com.android.support-annotations:27.1.1'
	androidTestImplementation 'com.android.support.test:runner:1.0.2'
	androidTestImplementation 'com.android.support.test:rules:1.0.2'
}
```

```groovy
android{
    
    defalutConfig{
        
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
}
```

#### 示例

操作 SharedPreferences 的例子。

##### 操作SharedPreference 的实现

```java
public class SharedPreferenceDao{
    private SharedPreferences sp;
    
    public SharedPreferenceDao(SharedPreferences sp){
        this.sp = sp;
    }
    
    public SharedPreferenceDao(Context context){
        this(context.getSharedPreferences("config",Context.MODE_PRIVATE));
    }
    
    public void put(String key,String value){
        SharedPreferences.Editor editor = sp.edit();
        editor.putString(key,value);
        editor.apply();
    }
    
    public String get(String key){
        return sp.getString(key,null);
    }
}
```

##### 创建仪器化测试类 (app/src/androidTest/java)

```java
// @RunWith 只在混合使用 JUnit3 和JUnit4 需要，若只使用 JUnit4，可省略
@RunWith(AndroidJUnit4.class)
public class SharedPreferenceDaoTest{
    public static final String TEST_KEY ="instrumentedTest";
    public static final String TEST_STRING ="ttt";
    
    SharedPreferenceDao spDao;
    
    @Before
    public void setUp(){
        spDao = new  SharedPreferenceDao(App.getContext());
    }
    
    @Test
    public void sharedPreferenceDaoWriteRead(){
        spDao.put(TEST_KEY,TEST_STRING);
        Assert.assertEquals(TEST_STRING,spDao.get(TEST_KEY));
    }
}
```

##### 命令行运行

###### 1.  安装apk

```shell
//安装 apk 
//-t：允许安装测试 APK
//-r：重新安装现有应用，保留其数据，类似于替换安装
adb shell pm install -t -r filePath
```

###### 2. 运行 instrumented 测试用例

```shell
am instrument [flags] <test_package>/<runner_class>
```

**flags**

- -w: 强制 am instrument 命令等待仪器化测试结束才结束自己(wait)，保证命令行窗口在测试期间不关闭，方便查看测试过程的log

- -r: 以原始格式输出结果(raw format) 

- -e: 以键值对的形式提供测试选项，例如 -e debug false

## 常用单元测试开源库

- JUnit：Java 编程语言的单元测试框架，主要用于断言
- Mockito：Java界使用最广泛的一个 mock 框架，mock表示在测试环境中创建一个类的虚假对象方便用于验证。Mockito 不支持 mock 匿名类、final类、静态方法和 private 方法。
- PowerMock：扩展了 Mockito，支持 Mock 静态、final、私有方法等。

### Mocktio

https://github.com/mockito/mockito

Mock对象，模拟控制其方法返回值，监控其方法的调用等。

> mock对象就是在调试期间用来作为真实对象的替代品。
>
> mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。

#### 原理

Mockito本质上就是在代理对象调用方法前，用stub的方式设置其返回值，然后在真实调用时，用代理对象返回起预设的返回值。

#### 依赖隔离

一个单元的代码，通常会有各种依赖。写单元测试时，应该把这些依赖隔离，让每个单元保持独立。举个例子：

```java
public class Calculater {

    public double divide(int a, int b) {
        // 检测被除数是否为0
        if (MathUtils.checkZero(b)) {
            throw new RuntimeException("dividend is zero");
        }

        return (double) a / b;
    }
}
```



```java
public class MathUtils {
    public static boolean checkZero(int num) {
        return num == 0;
    }
}
```

`divide(a,b)`计算`a除以b`，但`被除数b`不应该为0，所以用`MathUtils.checkZero(b)`验证`b==0`。咋看这里好像没什么问题，但是，如果`MathUtils.checkZero`里面的判断逻辑写错呢？例如：

```java
public static boolean checkZero(int num) {
    return  num != 0; // bug
}
```

如果不是`num==0`那么简单，而是更复杂的算法呢？

因为`Calculater`引用的任何依赖，都可能出错。**更糟糕的是**，如果用**junit**做单元测试，依赖里面可能是**Android库**或者**jni native**方法，依赖方法一执行就会报错。以上的各种原因，都会**影响单元测试的结果**。所以，我们对代码做如下改进：

```java
public class Calculater {

    IMathUtils mathUtils;
    
    public double divide(int a, int b) {
        if (mathUtils.checkZero(b)) {
            throw ...
        }
        return (double) a / b;
    }
}
```



```java
public interface IMathUtils {
    public boolean checkZero(int num);
}
```

我们可以在`Calculater`构造方法传入`IMathUtils`派生类，又或者用`setter`。在项目执行代码中，传`MathUtils`，而单元测试时，可以写一个`MathUtilsTest`继承`IMathUtils`，传给`Calculater`。只要保证`MathUtilsTest.checkZero()`正确就行。经过这么重构，`Calculater`就不依赖原来的`MathUtils`，单元测试时可以替换专门的实现，达到了**依赖隔离的目的**。

有同学会问，这样岂不是每个依赖都要写一个专门给单元测试的类吗？这就等于拷贝多一份代码，并且写各种接口，而且不能保证单元测试的类一定正确。

说得很有道理。笔者为了尽量简单地演示代码，举了一个非常简单的例子。我们如何让单元测试更简洁，并且让它阅读起来更有意义呢？



#### Mock

为了更好地解决上述问题，我们引入**Mock**概念。**Mock**，翻译为模拟，在单元测试**mock**可以**模拟返回数据，也可以模拟接口/方法的行为**。使用模拟对象替换我们原先依赖的真实对象，这样就可以避免外部的影响，只测试本类，得到更准确的结果。

什么是**模拟行为**？例如刚才`mathUtils.checkZero(b)`，意义为：“当`mathUtils`调用`checkZero(num)`”时，判断 `num==0`；又或者：“当调用`checkZero(0)`时返回`true`，`num`为其他值时返回`false`”。`checkZero()`是一个**行为**，返回的`true、false`就是数据。单元测试时，我们经常要**让方法/接口模拟某些行为，并得到模拟数据**。

例如，需要测试`a=2,b=1`和`a=2,b=0`调用`divide(a,b)`两者结果分别是`2，抛出错误`，使用**mockito**框架**让mathUtils.checkZero()模拟行为**，代码如下：

```java
public static void main(String[] args) {
    // 生成IMathUtils模拟对象
    IMathUtils mathUtils = mock(IMathUtils.class);

    when(mathUtils.checkZero(1)).thenReturn(false); // 当num==1时，checkZero(num)返回false
    when(mathUtils.checkZero(0)).thenReturn(true); // 当num==0时，checkZero(num)返回true

    Calculater calculater = new Calculater(mathUtils);

    assertEquals(calculater.divide(2,1), 2); // 验证 divide(2,1) 结果是2

    try {
        calculater.divide(2, 0); // 预期抛出错误
        throw new RuntimeException("no expectant exception"); // 如果divide没抛错，则此处抛错
    } catch (Exception e) {
        Assert.assertEquals(e.getMessage(), "dividend is zero"); // 验证错误信息
    }
}
```

##### 目的

1. 验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等
2. 指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作

#### 添加依赖

```groovy
testImplementation 'org.mockito:mockito-core:2.19.0'
```

#### 四种mock 的方法

##### 1. 普通方法

```java
public class MockitoTest{
    @Test
    public void testIsNotNull(){
        Person mPerson = mock(Person.class);	//使用 mock 方法
        assertNotNull(mPerson);
    }
}
```

##### 2. 注解方法

一旦使用 @Mock 注解，一定要在测试方法调用之前调用（比如 @Before 注解的 setUp 方法）

```java
public class MockitoAnnotationsTest {

    @Mock //<--使用@Mock注解
    Person mPerson;

    @Before
    public void setup(){
        MockitoAnnotations.initMocks(this); //<--初始化
    }

    @Test
    public void testIsNotNull(){
        assertNotNull(mPerson);
    }

}
```

##### 3. 运行器方法

```java
@RunWith(MockitoJUnitRunner.class) //<--使用MockitoJUnitRunner
public class MockitoJUnitRunnerTest {

    @Mock //<--使用@Mock注解
    Person mPerson;

    @Test
    public void testIsNotNull(){
        assertNotNull(mPerson);
    }

}
```

##### 4. MockitoRule方法

```java
public class MockitoRuleTest {

    @Mock //<--使用@Mock注解
    Person mPerson;

    @Rule //<--使用@Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Test
    public void testIsNotNull(){
        assertNotNull(mPerson);
    }
}
```

其中后两种方法是结合JUnit框架去实现的。

#### 常用打桩方法（指定返回值）

因为`Mock`出的对象中非void方法都将返回默认值，比如`int`方法将返回0，对象方法将返回`null`等，而void方法将什么都不做。“打桩”顾名思义就是将我们`Mock`出的对象进行操作，比如提供模拟的返回值等，给`Mock`打基础。

| 方法名                           | 方法描述                 |
| -------------------------------- | ------------------------ |
| thenReturn(T value)              | 设置要返回的值           |
| thenThrow(Throwable… throwables) | 设置要抛出的异常         |
| thenAnswer(`Answer<?> answer`)   | 对结果进行拦截           |
| doReturn(Object toBeReturned)    | 提前设置要返回的值       |
| doThrow(Throwable… toBeThrown)   | 提前设置要抛出的异常     |
| doAnswer(Answer answer)          | 提前对结果进行拦截       |
| doCallRealMethod()               | 调用某一个方法的真实实现 |
| doNothing()                      | 设置void方法什么也不做   |

##### thenReturn 和 thenThrow

代码语义很明确，**当**执行什么方法时，**然后就**返回什么结果。当然如果我们不打桩，打印结果就是`null`和`0`了。

```java
@Test
public void testPersonReturn(){
    when(mPerson.getName()).thenReturn("小明");
    when(mPerson.getSex()).thenThrow(new NullPointerException("滑稽，性别不明"));
    
    //输出“小明”
    System.out.println(mPerson.getName());
    
    //抛出异常
    System.out.println(mPerson.getSex());
}
```

##### doReturn 

**以**什么结果返回，**当**执行什么方法时。这类方法主要是为了应对无法使用`thenReturn`等方法的场景（比如方法为void），**可读性来说thenReturn这类更好。**

```java
doReturn("小小").when(mPerson).getName();
// 输出"小小"
System.out.println(mPerson.getName());
```

##### thenAnswer

用`thenAnswer`拿到了吃进去的东西，将返回结果重新进行处理。

```java
@Test
public void testPersonAnswer(){
    when(mPerson.eat(anyString())).thenAnswer(new Answer<String>(){
        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable{
            Object[] args = invocation.getArguments();
            return args[0].toString()+"真好吃";
        }
    });
    
    //输出，饺子真好吃
    System.out.println(mPerson.eat("饺子"));
}
```

#### 常用验证方法（验证调度）

> 前面所说的都是状态测试，但是如果不关心返回结果，而是关心方法有否被正确的参数调用过，这时候就应该使用验证方法了。从概念上讲，就是和状态测试所不同的“行为测试”了。

verify(T mock) 验证发生的某些行为。verify(objectToVerify).methodToVerify(arguments);

| 方法名                               | 方法描述                             |
| ------------------------------------ | ------------------------------------ |
| after(long millis)                   | 在给定的时间后进行验证               |
| timeout(long millis)                 | 验证方法执行是否超时                 |
| atLeast(int minNumberOfInvocations)  | 至少进行n次验证                      |
| atMost(int maxNumberOfInvocations)   | 至多进行n次验证                      |
| description(String description)      | 验证失败时输出的内容                 |
| times(int wantedNumberOfInvocations) | 验证调用方法的次数                   |
| never()                              | 验证交互没有发生,相当于times(0)      |
| only()                               | 验证方法只被调用一次，相当于times(1) |

##### 使用

```java
@Test
public void testPersonVerifyAfter(){
    when(mPerson.getAge()).thenReturn(18);
    //延时1s验证
    System.out.println(mPerson.getAge());
    System.out.println(System.currentTimeMillis());
    verify(mPerson, after(1000)).getAge();
    System.out.println(System.currentTimeMillis());
    
    verify(mPerson, atLeast(2)).getAge();
}

@Test
public void testPersonVerifyAtLeast(){
    mPerson.getAge();
    mPerson.getAge();
    //至少验证2次
    verify(mPerson, atLeast(2)).getAge();
}

@Test
public void testPersonVerifyAtMost(){
    mPerson.getAge();
    //至多验证2次
    verify(mPerson, atMost(2)).getAge();
}

@Test
public void testPersonVerifyTimes(){
    mPerson.getAge();
    mPerson.getAge();
    //验证方法调用2次
    verify(mPerson, times(2)).getAge();
}

@Test
public void testPersonVerifyTimes(){
    mPerson.getAge();
    mPerson.getAge();
    //验证方法在100ms超时前调用2次
    verify(mPerson, timeout(100).times(2)).getAge();
}
```

#### 常见参数匹配器

| 方法名                                 | 方法描述                      |
| -------------------------------------- | ----------------------------- |
| anyObject()                            | 匹配任何对象                  |
| `any(Class<T> type)`                   | 与anyObject()一样             |
| any()                                  | 与anyObject()一样             |
| anyBoolean()                           | 匹配任何boolean和非空Boolean  |
| anyByte()                              | 匹配任何byte和非空Byte        |
| anyCollection()                        | 匹配任何非空Collection        |
| anyDouble()                            | 匹配任何double和非空Double    |
| anyFloat()                             | 匹配任何float和非空Float      |
| anyInt()                               | 匹配任何int和非空Integer      |
| anyList()                              | 匹配任何非空List              |
| anyLong()                              | 匹配任何long和非空Long        |
| anyMap()                               | 匹配任何非空Map               |
| anyString()                            | 匹配任何非空String            |
| contains(String substring)             | 参数包含给定的substring字符串 |
| argThat(`ArgumentMatcher <T> matcher`) | 创建自定义的参数匹配模式      |

##### 示例

```java
@Test
public void testPersonAny(){
    when(mPerson.eat(any(String.class))).thenReturn("米饭");
    //或
    //when(mPerson.eat(anyString())).thenReturn("米饭");
    
    //输出米饭
    System.out.println(mPerson.eat("面条"));
}

@Test
public void testPersonContains(){
    when(mPerson.eat(contains("面"))).thenReturn("面条");
    //输出面条
    System.out.println(mPerson.eat("面"));
}

@Test
public void testPersonArgThat(){
    //自定义输入字符长度为偶数时，输出面条。
    when(mPerson.eat(argThat(new ArgumentMatcher<String>() {
        @Override
        public boolean matches(String argument) {
            return argument.length() % 2 == 0;
        }
    }))).thenReturn("面条");
    //输出面条
    System.out.println(mPerson.eat("1234"));
}
```

#### 其他方法

| 方法名                     | 方法描述                         |
| -------------------------- | -------------------------------- |
| reset(T … mocks)           | 重置Mock                         |
| spy(`Class<T> classToSpy`) | 实现调用真实对象的实现           |
| inOrder(Object… mocks)     | 验证执行顺序                     |
| @InjectMocks注解           | 自动将模拟对象注入到被测试对象中 |

##### Spy

Spy ：监控真实对象

Spy的创建与mock一样。需要用到对真实对象的测试操作，spy绝对是一个很不错的选择。

```java
public class MockitoSpyTest {

    @Spy
    Person mPerson;

    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Test
    public void testIsNotNull(){
        assertNotNull(mPerson);
    }

    @Test
    public void testPersonSpy(){
        //输出11
        System.out.print(mPerson.getAge());
    }

}
```

###### spy 与 mock 的区别

```java
/**
  * 监控真实对象
  */
@Test
public void spyTest() throws Exception {
    List list = new ArrayList();
    List spyList = spy(list);
    
    //当spyList调用size()方法时，return100
    when(spyList.size()).thenReturn(100);
    
    spyList.add("one");
    spyList.add("two");
    
    System.out.println("spyList第一个元素" + spyList.get(0));
    System.out.println("spyList.size = " + spyList.size());
    
    verify(spyList).add("one");
    verify(spyList).add("two");
    
    //请注意！下面这行代码会报错！ java.lang.IndexOutOfBoundsException: Index: 10, Size: 2
    //不可能 : 因为当调用spy.get(0)时会调用真实对象的get(0)函数,此时会发生异常，因为真实List对象是空的
    //when(spyList.get(10)).thenReturn("ten");
    //应该这么使用
    
    doReturn("ten").when(spyList).get(10);
    doReturn("eleven").when(spyList).get(11);
    
    System.out.println("spyList第10个元素" + spyList.get(10));
    System.out.println("spyList第11个元素" + spyList.get(11));
    
    //Mockito并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互
    //不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。
    
    //因此结论就是 : 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。
}
```

spy 对象的方法默认调用真实的逻辑，mock对象的方法默认什么都不做，或直接返回默认值。

##### inOrder

```java
@Test
public void testPersonInOrder(){
    
    mPerson.setName("小明");
    mPerson.setSex(1);
    
    mPerson1.setName("小红");
    mPerson1.setSex(0);
    
    InOrder mInOrder = inOrder(mPerson,mPerson1);
    //执行顺序正确
    mInOrder.verify(mPerson).setName("小明");
    mInOrder.verify(mPerson).setSex(1);
    
    //执行顺序错误
    mInOrder.verify(mPerson1).setSex(0);
    mInOrder.verify(mPerson1).setName("小红");
}
```

##### @InjectMocks

创建一个实例，这个实例需要的参数用@Mock（或@Spy）注解创建的注入到该实例中。

```java
public class Home {

    private Person mPerson;

    public Home(Person person) {
        mPerson = person;
    }

    public String getMaster(){
        return mPerson.getName();
    }
}
```



```java
public class MockitoSpyTest{
    @Spy
    Person mPerson;
    
    @InjectMocks
    Home mHome;
    
    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();
    
    @Test
    public void testIsNotNull(){
        assertNotNull(mPerson);
    }
    
    @Test
    public void testHomeInjectMocks(){
        when(mPerson.getName()).thenReturn("weilu");
        System.out.print(mHome.getMaster());
    }
}
```

#### 误区

- Mockito.mock()并不是mock一整个类，而是根据传进去的一个类，mock出属于这个类的一个对象，并且返回这个mock对象；而传进去的这个类本身并没有改变，用这个类new出来的对象也没有受到任何改变！

- mock出来的对象并不会自动替换掉正式代码里面的对象，你必须要有某种方式把mock对象应用到正式代码里面（**构造函数传参进去**）

  ```
  Calculater calculater = new Calculater(mathUtils);
  ```

  

#### 特别说明

Mockito 框架不支持 mock 匿名类、final 类、static方法、private 方法。而PowerMock框架解决了这些问题。

##### 静态方法包装成非静态方法

```java
public class LogTest{

    class StaticWrapper {//包裹静态方法为非静态方法
        void i(String tag, String msg) {
            Log.i(tag, msg);
        }
    }

    @Test
    public void test() {
        StaticWrapper mockedLog = Mockito.mock(StaticWrapper.class);
        mockedLog.i("test", "test");
        Mockito.verify(mockedLog).i("test", "test");
    }
}
```

##### 确保mock对象从未进行交互

```java
@Test
public void noInteractedTest7() throws Exception {
    List firstMock = mock(List.class);
    List secondMock = mock(List.class);
    List thirdMock = mock(List.class);

    firstMock.add("one");

    verify(firstMock).add("one");

    verify(firstMock, never()).add("two");

    firstMock.add(thirdMock);
    // 确保交互(interaction)操作不会执行在mock对象上
	//verifyZeroInteractions(firstMock); 
    //test failed,因为firstMock和其他mock对象有交互
    verifyZeroInteractions(secondMock, thirdMock);   //test pass
}
```

##### 方法连续调用测试

```java
/**
  * 方法连续调用的测试
  */
@Test
public void continueMethodTest9() throws Exception {
    when(mockedUser.getName())
            .thenReturn("qingmei2")
            .thenThrow(new RuntimeException("方法调用第二次抛出异常"))
            .thenReturn("qingemi2 第三次调用");

    //另外一种方式
    when(mockedUser.getName()).thenReturn("qingmei2 1", "qingmei2 2", "qingmei2 3");

    String name1 = mockedUser.getName();

    try {
        String name2 = mockedUser.getName();
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }

    String name3 = mockedUser.getName();

    System.out.println(name1);
    System.out.println(name3);
}
```

##### 为回调方法做测试

```java
/**
  * 为回调方法做测试
  */
@Test
public void callBackTest() throws Exception {

    when(mockList.add(anyString())).thenAnswer(new Answer<Boolean>() {

        @Override
        public Boolean answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            Object mock = invocation.getMock();
            return false;
        }
    });
    
    System.out.println(mockList.add("第1次返回false"));
    
    //lambda表达式
    when(mockList.add(anyString())).then(invocation -> true);
    System.out.println(mockList.add("第2次返回true"));

    when(mockList.add(anyString())).thenReturn(false);
    System.out.println(mockList.add("第3次返回false"));
}
```

###### 登录回调例子

```java
public void loginCallbackVersion(String username,String password){
    if(username == null || username.length() == 0){
        return;
    }
    //login 的结果将通过 callback 传递回来。
    mUserManager.performLogin(username,paassword,new NetworkCallback(){
        @Override
        public void onSuccess(Object data){
            //update view with data
        }
        
        @Override
        public void onFailure(int code,String msg){
            //show error msg
        }
    });
}
```



```java
Mockito.doAnswer(new Answer(){
    @Override
    public Object answer(InvocationOnMock invocation) throws Throwable{
        //这里可以获得传给 performLogin 的参数
        Object[] arguments = invocation.getArguments();
        
        //callback 是第三个参数
        NetworkCallback callback = (NetworkCallback) arguments[2];
        
        callback.onFailure(500,"Server error");
        return 500;
    }
}).when(mockUserManager).performLogin(anyString(),anyString(),any(NetworkCallback.class));
```

当调用`mockUserManager`的`performLogin`方法时，会执行answer里面的代码，我们上面的例子是直接调用传入的`callback`的`onFailure`方法，同时传给`onFailure`方法500和”Server error”。



##### 捕获参数

```java
/**
 * 为接下来的断言捕获参数(API1.8+)
 */
@Test
public void captorTest() throws Exception {
    Student student = new Student();
    student.setName("qingmei2");

    ArgumentCaptor<Student> captor = ArgumentCaptor.forClass(Student.class);
    mockList.add(student);
    verify(mockList).add(captor.capture());

    Student value = captor.getValue();

    Assert.assertEquals(value.getName(),"qingmei2");
}

@Data
private class Student {
    private String name;
}
```

将定义好的ArgumentCaptor参数捕获器放到我们需要去监控捕获的地方，如果真的执行了该方法，我们就能通过captor.getValue()中取到参数对象，如果没有执行该方法，那么取到的只能是null或者基本类型的默认值。

### powermock

PowerMock使用一个自定义类加载器和字节码操作来模拟静态方法，构造函数，final类和方法，私有方法，去除静态初始化器等等。通过使用自定义的类加载器，简化采用的IDE或持续集成服务器不需要做任何改变。

PowerMock 是使用 CGLib 来操纵字节码而实现的 mock。



https://github.com/powermock/powermock

对于静态方法的 mock

#### 依赖

由于 PowerMock 对 Mockito 有较强依赖，因此需要按照以下表格采用对应的版本

| Mockito                  | PowerMock       |
| ------------------------ | --------------- |
| 2.0.0-beta - 2.0.42-beta | 1.6.5+          |
| 1.10.8 - 1.10.x          | 1.6.2+          |
| 1.9.5-rc1 - 1.9.5        | 1.5.0 - 1.5.6   |
| 1.9.0-rc1 & 1.9.0        | 1.4.10 - 1.4.12 |
| 1.8.5                    | 1.3.9 - 1.4.9   |
| 1.8.4                    | 1.3.7 & 1.3.8   |
| 1.8.3                    | 1.3.6           |
| 1.8.1 & 1.8.2            | 1.3.5           |
| 1.8                      | 1.3             |
| 1.7                      | 1.2.5           |

##### 示例

```groovy
testCompile 'junit:junit:4.11'
// required if you want to use Mockito for unit tests
testCompile 'org.mockito:mockito-core:1.9.5'
// required if you want to use Powermock for unit tests
testCompile 'org.powermock:powermock-module-junit4:1.5.6'
testCompile 'org.powermock:powermock-module-junit4-rule:1.5.6'
testCompile 'org.powermock:powermock-api-mockito:1.5.6'
```

###### 说明

如果使用了Mockito，需要这两者使用兼容的版本，具体参考 https://github.com/powermock/powermock/wiki/Mockito#supported-versions

#### 语法

PowerMock 有三个重要的注解：

```java
@RunWith(PowerMockRunner.class)
@PrepareForTest(YourClassWithEgStaticMethod.class)	//声明需要进行 mock 的静态类
@PowerMockIgnore("javax.management.*")	//表示不使用 PowerMockito 来加载所声明的 package 路径的类
```

#### 特别说明

PowerMock似乎很强大，但PowerMock使用的越多，表示被测试的代码抽象层次越低，代码质量和结构也越差。

#### mock 基本使用

##### mock静态方法

使用`PowerMock`必须加注解`@PrepareForTest`和`@RunWith(PowerMockRunner.class)`。注解`@PrepareForTest`里写的是静态方法所在的类。

###### 示例

```java
abstract class Fruit {

    private String fruit = "水果";

    public String getFruit() {
        return fruit;
    }
}
```



```java
public class Banana extends Fruit{

    private static String COLOR = "黄色的";

    public Banana() {}

    public static String getColor() {
        return COLOR;
    }

    public String getBananaInfo() {
        return flavor() + getColor();
    }

    private String flavor() {
        return "甜甜的";
    }

    public final boolean isLike() {
        return true;
    }
}
```

```
@RunWith(PowerMockRunner.class)
public class PowerMockitoStaticMethodTest {

    @Test
    @PrepareForTest({Banana.class})
    public void testStaticMethod() { 
        PowerMockito.mockStatic(Banana.class); //<-- mock静态类
        Mockito.when(Banana.getColor()).thenReturn("绿色");
        Assert.assertEquals("绿色", Banana.getColor());
    }
}
```

###### 更改类的私有static常量

```java
@Test
@PrepareForTest({Banana.class})
public void testChangeColor() { 
    Whitebox.setInternalState(Banana.class, "COLOR", "红色的");
    Assert.assertEquals("红色的", Banana.getColor());
}
```

当需要 mock 私有变量的时候，不需要加注解 @PrepareForTest 和 @RunWith，而是使用 Whitebox 来 mock 私有变量，并注入预设的变量值。

Powermock提供了一个Whitebox的class，可以方便的绕开权限限制，可以get/set private属性，实现注入。也可以调用private方法。也可以处理static的属性/方法，根据不同需求选择不同参数的方法即可。

##### mock私有方法

```java
@RunWith(PowerMockRunner.class)
public class PowerMockitoPrivateMethodTest {

    @Test
    @PrepareForTest({Banana.class})
    public void testPrivateMethod() throws Exception {
        Banana mBanana = PowerMockito.mock(Banana.class);
        PowerMockito.when(mBanana.getBananaInfo()).thenCallRealMethod();
        PowerMockito.when(mBanana, "flavor").thenReturn("苦苦的");
        Assert.assertEquals("苦苦的黄色的", mBanana.getBananaInfo());
        //验证flavor是否调用了一次
        PowerMockito.verifyPrivate(mBanana).invoke("flavor"); 
    }
}
```

###### 跳过私有方法

```java
@Test
@PrepareForTest({Banana.class})
public void skipPrivateMethod() {
    Banana mBanana = new Banana();
    //跳过flavor方法
    PowerMockito.suppress(PowerMockito.method(Banana.class, "flavor"));
    Assert.assertEquals("null黄色的", mBanana.getBananaInfo());
}
```

###### 更改父类私有变量

```java
@Test
@PrepareForTest({Banana.class})
public void testChangeParentPrivate() throws Exception {
    Banana mBanana = new Banana();
    MemberModifier.field(Banana.class, "fruit").set(mBanana, "蔬菜");
    Assert.assertEquals("蔬菜", mBanana.getFruit());
}
```

##### mock final 方法

```java
@RunWith(PowerMockRunner.class)
public class PowerMockitoFinalMethodTest {

    @Test
    @PrepareForTest({Banana.class})
    public void testFinalMethod() throws Exception {
        Banana mBanana = PowerMockito.mock(Banana.class);
        PowerMockito.when(mBanana.isLike()).thenReturn(false);
        Assert.assertFalse(mBanana.isLike());
    }
}
```

###### mock系统类的静态和 final 方法

```java
public class CommonExample {

    public String callSystemStaticMethod(String str) {
        return System.getProperty(str);
    }

}
```

###### 测试用例代码

```java
public class CommonExampleTest extends BasePowerMockTestCase {

    @Test
    @PrepareForTest(CommonExample.class)
    public void callSystemStaticMethod() {
        CommonExample commonExample = new CommonExample();
        PowerMockito.mockStatic(System.class);
        PowerMockito.when(System.getProperty("aaa")).thenReturn("bbb");
        Assert.assertEquals("bbb", commonExample.callSystemStaticMethod("aaa"));
    }

}
```

##### mock 构造方法

`whenNew` 方法的意思是之后 new 这个对象时，返回某个被 Mock 的对象而不是让真的 new 新的对象。如果构造方法有参数，可以在`withNoArguments`方法中传入。

```java
@Test
@PrepareForTest({Banana.class})
public void testNewClass() throws Exception {
    Banana mBanana = PowerMockito.mock(Banana.class);
    PowerMockito.when(mBanana.getBananaInfo()).thenReturn("大香蕉");
    //如果new新对象，则返回这个上面设置的这个对象
    PowerMockito.whenNew(Banana.class).withNoArguments().thenReturn(mBanana);
    //new新的对象
    Banana newBanana = new Banana();
    Assert.assertEquals("大香蕉", newBanana.getBananaInfo());
}
```

##### 其他

###### @Rule

使用`PowerMock`就必须加`@RunWith(PowerMockRunner.class)`，但是我们毕竟有时会使用多个测试框架，可能`@RunWith`会占用。这时我们可以使用`@Rule`。代码如下：

```java
@Rule
public PowerMockRule rule = new PowerMockRule();
```

###### @PowerMockIgnore

`@PowerMockIgnore`用于忽略mock的类，常见的写法是：

```java
@PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*" })
```

忽略`android`的相关类，因为我们使用`Robolectric`处理了。
忽略`Mockito`和`Robolectric`的相关类，因为我们不应该mock它们自己。

#### 原理

PowerMockito 有两个重要的依赖：javassist 和 objenesis ，javassist 是一个修改 java字节码的工具包，objenesis 是一个绕过构造方法来实例化一个对象的工具包。由此看来，PowerMock的本质是通过修改字节码来实现对静态和final等方法的mock的。

##### 具体如下

1. 被注解@PrepareForTest(CommonExample.class)标注以后，在运行时，会创建一个org.powermock.core.classloader.MockClassLoader对象来加载该测试用例使用到的类（系统类除外）。
2. PowerMockito会根据你的mock要求，去修改写在注解@PrepareForTest里的class文件（当前测试类会自动加入注解中），以满足特殊的mock需求。例如：去除final方法的final标识，在静态方法的最前面加入自己的虚拟实现等。
3. 如果mock的是系统类的final方法和静态方法，PowerMockito不会直接修改系统类的class文件，而是修改调用系统类的class文件，以满足mock需求

#### 示例

##### 自定义测试代码位置

有些项目是由 Eclipse 构建迁移到由 Gradle 构建，需要自定义测试代码位置。假设 androidTest 和 test 目录都在项目的根文件夹下。需要进行如下配置：

```groovy
android{
    sourceSets{
        test{
            java.srcDir 'test'
        }
        androidTest{
            java.srcDir 'androidTest'
        }
    }
}
```



##### 

#### 常见问题

- 提示 classloader 错误

  加入注解：@PowerMockIgnore(YourPackagePath.*)来解决由于MockClassLoader造成的class加载错误，通过这个注解可以让报错的类使用系统的ClassLoader来加载报错类。如：

  ```java
  @PowerMockIgnore({"sun.security.*", "javax.net.*"})
  ```

- PowerMockito 和 Mockito mock出来的对象不能相互使用

- "Method ... not mocked."的问题

  添加如下设置：

  ```groovy
  android{
      //...
      testOptions{
          unitTests.returnDefaultValues = true
      }
  }
  ```

  

- 

### Robolectric

http://robolectric.org

主要是解决仪器化测试中耗时的缺陷，仪器化测试需要安装以及跑在Android系统上，也就是需要在Android虚拟机或真机上面，所以十分的耗时，基本上每次来来回回都需要几分钟时间。针对这类问题，业界其实已经有了一个现成的解决方案: Pivotal实验室推出的Robolectric，通过使用Robolectrict模拟Android系统核心库的Shadow Classes的方式，我们可以像写本地测试一样写这类测试，并且直接运行在工作环境的JVM上，十分方便。

#### 特点

- 模拟了 android sdk中的 jar 包，可以直接在 jvm 中运行测试用例。
- Robolectric 可以处理控件展示、资源加载和很多使用 native C实现的真机上的其他功能

#### 优缺点

##### 优点

支持大部分 Android 平台依赖类底层的引用与模拟。

##### 缺点

异步测试有些问题，需要结合一些框架来配合完成更多功能。

#### 添加配置

```groovy
testCompile "org.robolectric:robolectric:3.5.1"
testCompile 'org.robolectric:shadows-support-v4:3.4-rc2'

android {
  ...
  testOptions {
    unitTests {
      includeAndroidResources = true
    }
  }
}
```

#### 特别注意

使用Robolectric要注意它的版本以及其支持的SDK版本，如果不支持千万不要用高版本SDK编译，或者升级Gradle插件和编译器版本，否则运行时会出现各种问题。如果版本太高，例如我尝试使用Gradle Wrapper版本4.0配合Gradle插件3.0.0版本时发现是无法成功测试的。

本文采用最新的**Robolectric 3.x**（目前是3.4-rc2），测试的SDK API版本为**25**，Gradle Wrapper为**3.3**，Gradle插件为**2.3.0**。另外我用的Android Studio版本也是3.0版本，如果低于2.0的版本的建议升级，否则可能会遇到其他问题

#### Robolectric 使用

```java
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class, sdk = 23)
public class MainActivityTest {

}
```

@RunWith 指定测试运行器为 RobolectricTestRunner 

@Config 指定 constants = BuildConfig.class ，默认配置以我们项目中的为准。

##### Robolectric支持单元测试范围

- Activity的跳转、Activity展示View（包括菜单）和Fragment到View的点击触摸以及事件响应，Toast和Dialog的测试。

- 对于需要网络请求数据的测试，Robolectric可以模拟网络请求的response。

- 对于一些Robolectric不能测试的对象，比如ConcurrentTask，可以通过自定义Shadow的方式实现测试。

##### Activity View的点击

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final TextView tvResult = findViewById(R.id.tvResult);
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                tvResult.setText("Robolectric Rocks!");
            }
        });
    }
}
```

```java
@RunWith(RobolectricTestRunner.class)
public class MyActivityTest {
    
    @Test
    public void clickingButton_shouldChangeResultsViewText() throws Exception {
        MainActivity activity = Robolectric.setupActivity(MainActivity.class);
        Button button =  activity.findViewById(R.id.button);
        TextView results = activity.findViewById(R.id.tvResult);
        //模拟点击按钮，调用OnClickListener#onClick
        button.performClick();
        Assert.assertEquals("Robolectric Rocks!", results.getText().toString());
    }
}
```

##### Activity 展示

```java
@Test
public void testSampleActivity(){
    SampleActivity sampleActivity＝Robolectric.buildActivity(SampleActivity.class).
                create().resume().get();
    assertNotNull(sampleActivity);
    assertEquals("Activity的标题", sampleActivity.getTitle());
}
```

Robolectric.buildActivity()用于构造Activity，create()函数执行后，该Activity会运行到onCreate周期，resume()则对应onResume周期。assertNotNull和assertEquals是JUnit中的断言，Robolectric只提供运行环境，逻辑判断还是需要依赖JUnit中的断言。

##### Activity跳转

###### 示例1

```java
@Test
public void testActivityTurn(ActionBarActivity firstActivity, Class secondActivity) {
    //获取跳转的意图
    Intent actual = ShadowApplication.getInstancee().getNextStartedActivity();
    //期望意图
    Intent intent = new Intent(firstActivity.getApplicationContext(), secondActivity);
    //假设一致
    assertEquals(intent, actual);
}
```

###### 示例2

```java
@Test
public void testJump() throws Exception {
    
    // 获取对应的Shadow类
    ShadowActivity shadowActivity = Shadows.shadowOf(mainActivity);
    // 借助Shadow类获取启动下一Activity的Intent
    Intent nextIntent = shadowActivity.getNextStartedActivity();
    // 校验Intent的正确性
    assertEquals(nextIntent.getComponent().getClassName(),LoginActivity.class.getName());
    }
```

##### Activity生命周期

利用ActivityController我们可以让Activity执行相应的生命周期方法，如：

```java
	public String getLifecycleState(){
        return lifecycle;
    }

    @Override
    protected void onStart() {
        super.onStart();
        lifecycle = "onStart";
    }

    @Override
    protected void onResume() {
        super.onResume();
        lifecycle = "onResume";
    }

    @Override
    protected void onPause() {
        super.onPause();
        lifecycle = "onPause";
    }

    @Override
    protected void onStop() {
        super.onStop();
        lifecycle = "onStop";
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        lifecycle = "onRestart";
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        lifecycle = "onDestroy";
    }
```

###### 测试代码

```java
    @Test
    public void testLifecycle() throws Exception {
        // 创建Activity控制器
        ActivityController<MainActivity> controller = Robolectric.buildActivity(MainActivity.class);
        MainActivity activity = controller.get();
        assertNull(activity.getLifecycleState());

        // 调用Activity的performCreate方法
        controller.create();
        assertEquals("onCreate", activity.getLifecycleState());

        // 调用Activity的performStart方法
        controller.start();
        assertEquals("onStart", activity.getLifecycleState());

        // 调用Activity的performResume方法
        controller.resume();
        assertEquals("onResume", activity.getLifecycleState());

        // 调用Activity的performPause方法
        controller.pause();
        assertEquals("onPause", activity.getLifecycleState());

        // 调用Activity的performStop方法
        controller.stop();
        assertEquals("onStop", activity.getLifecycleState());

        // 调用Activity的performRestart方法
        controller.restart();
        // 注意此处应该是onStart，因为performRestart不仅会调用restart，还会调用onStart
        assertEquals("onStart", activity.getLifecycleState());

        // 调用Activity的performDestroy方法
        controller.destroy();
        assertEquals("onDestroy", activity.getLifecycleState());
    }
```



##### Fragment展示与切换

需要注意Fragment出现的时机，如果目标Activity中的Fragment的添加是执行在onResume阶段，在Activity被Robolectric执行resume()阶段前，该Activity中并不会出现该Fragment。

```java
@Test
public void addfragment(Activity activity, int fragmentContent){
    FragmentTestUtil.startFragment(activity.getSupportFragmentManager().findFragmentById(fragmentContent));
    Fragment fragment = activity.getSupportFragmentManager().findFragmentById(fragmentContent);
    assertNotNull(fragment);
}
```

startFragment()函数的主体便是常用的添加fragment的代码。切换一个Fragment往往由Activity中的代码逻辑完成，需要Activity的引用。

##### 控件的点击以及可视验证

```java
@Test
public void testButtonClick(int buttonID){
    Button submitButton = (Button) activity.findViewById(buttonID);
    assertTrue(submitButton.isEnabled());
    submitButton.performClick();
    //验证控件的行为
}
```

ListView这类涉及到Adapter的控件的点击验证，写法如下：

```java
//listView被展示之后
listView.performItemClick(listView.getAdapter().getView(position, null, null), 0, 0);
```

##### Toast

###### 功能代码

```java
public void showToast(View view){
    Toast.makeText(this,"Hello UT!",Toast.LENGTH_LONG).show();
}
```

###### 测试代码

```java
@Test
public void testToast() throws Exception {
    Toast toast = ShadowToast.getLatestToast();
    // 判断Toast尚未弹出
    assertNull(toast);
    
    mToastBtn.performClick();
    toast = ShadowToast.getLatestToast();
    // 判断Toast已经弹出
    assertNotNull(toast);
    // 获取Shadow类进行验证
    ShadowToast shadowToast = Shadows.shadowOf(toast);
    assertEquals(Toast.LENGTH_LONG, shadowToast.getDuration());
    assertEquals("Hello UT!", ShadowToast.getTextOfLatestToast());
}
```

##### Dialog

###### 功能代码

```java
public void showDialog(View view){
    AlertDialog alertDialog = new AlertDialog.Builder(this)
        .setMessage("Hello UT！")
        .setTitle("提示")
        .create();
    alertDialog.show();
}
```



###### 测试代码

```java
@Test
public void testDialog() throws Exception {
    AlertDialog dialog = ShadowAlertDialog.getLatestAlertDialog();
    // 判断Dialog尚未弹出
    assertNull(dialog);
    
    mDialogBtn.performClick();
    dialog = ShadowAlertDialog.getLatestAlertDialog();
    // 判断Dialog已经弹出
    assertNotNull(dialog);
    // 获取Shadow类进行验证
    ShadowAlertDialog shadowDialog = Shadows.shadowOf(dialog);
    assertEquals("Hello UT！", shadowDialog.getMessage());
}
```

##### 访问资源文件

使用`RuntimeEnvironment.application`可以获取到`Application`，方便我们使用。比如访问资源文件。

```java
@Test
public void testResources() {
    Application application = RuntimeEnvironment.application;
    String appName = application.getString(R.string.app_name);
    assertEquals("AndroidUT", appName);
}
```

##### 验证 BroadcastReceiver

###### 功能代码

```java
public class MyReceiver extends BroadcastReceiver {

    public static final String NAME = "name";

    @Override
    public void onReceive(Context context, Intent intent) {
        SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();
        String name = intent.getStringExtra(NAME);
        editor.putString(NAME, name);
        editor.apply();
    }
}
```

```xml
     <receiver
          android:name=".broadcast.MyReceiver"
          android:enabled="true"
          android:exported="false">
          <intent-filter>
              <action android:name="com.zl.weilu.androidut" />
          </intent-filter>
     </receiver>
```

###### 测试代码

```java
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class, sdk = 23)
public class MyReceiverTest{

    private final String action = "com.zl.weilu.androidut";

    @Test
    public void testRegister() throws Exception {
        ShadowApplication shadowApplication = ShadowApplication.getInstance();
        Intent intent = new Intent(action);
        // 验证是否注册了相应的Receiver
        assertTrue(shadowApplication.hasReceiverForIntent(intent));
    }

    @Test
    public void testReceive() throws Exception {
        //发送广播
        Intent intent = new Intent(action);
        intent.putExtra(MyReceiver.NAME, "AndroidUT");
        MyReceiver myReceiver = new MyReceiver();
        myReceiver.onReceive(RuntimeEnvironment.application, intent);
        //验证广播的处理逻辑是否正确
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(RuntimeEnvironment.application);
        assertEquals( "AndroidUT", preferences.getString(MyReceiver.NAME, ""));
    }
}
```

##### Service验证

```java
public class MyService extends Service {

    private final String TAG = "MyService";

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "onBind");
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate");
    }

    @Override
    public boolean onUnbind(Intent intent) {
        Log.d(TAG, "onUnbind");
        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }
}
```

###### 测试代码

```java
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class, sdk = 23)
public class MyServiceTest {

    private ServiceController<MyService> controller;
    private MyService mService;

    @Before
    public void setUp() throws Exception {
        ShadowLog.stream = System.out;
        controller = Robolectric.buildService(MyService.class);
        mService = controller.get();
    }

    /**
     * 控制Service生命周期进行验证
     * @throws Exception
     */
    @Test
    public void testServiceLifecycle() throws Exception {
        controller.create();
        controller.startCommand(0, 0);
        controller.bind();
        controller.unbind();
        controller.destroy();
    }
}
```



##### Application

在实际的项目中，Application可能创建时可能会初始化一些其他的依赖库，不太方便单元测试，这里额外创建一个Application类，不需要在清单文件注册，直接写在本地测试目录即可。

```java
public class RoboApp extends Application{}
```

在编写测试类的时候需要通过@Config(application = RoboApp.class)来配置Application，当需要传入Context的时候调用RuntimeEnvironment.application来获取：

app/src/test/java/

```java
@RunWith(RobolectricTestRunner.class)
@Config(application = RoboApp.class)
public class SharedPreferenceDaoTest {

    public static final String TEST_KEY = "instrumentedTest";
    public static final String TEST_STRING = "玉刚说";

    SharedPreferenceDao spDao;

    @Before
    public void setUp() {
        //这里的Context采用RuntimeEnvironment.application来替代应用的Context
        spDao = new SharedPreferenceDao(RuntimeEnvironment.application);
    }

    @Test
    public void sharedPreferenceDaoWriteRead() {
        spDao.put(TEST_KEY, TEST_STRING);
        Assert.assertEquals(TEST_STRING, spDao.get(TEST_KEY));
    }

}
```

像本地一样把它跑起来即可。

#### Shadow的使用

`Robolectric`通过实现一套JVM能运行的Android代码，从而做到脱离Android运行环境进行测试。实际上使用的就是`Shadow`，比如之前例子中的`ShadowActivity`、`ShadowLog`、`ShadowAlertDialog`等。

对于一些Robolectirc暂不支持的组件，可以采用自定义Shadow的方式扩展Robolectric的功能。

##### 获取Shadow对象

假设有一个对象，想获取它的 Shadow对象，可以使用 Shadows.shadowOf。例如：

```java
ShadowApplication shadowApplication = Shadows.shadowOf(RuntimeEnvironment.application);
```

如果是自定义的 Shadow 对象则使用 Shadow.extract 方法。

##### 自定义Shadow

###### 原始Person

```java
public class Person {

    private String name;
    private int sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getSex() {
        return sex;
    }

    public void setSex(int sex) {
        this.sex = sex;
    }

    public int getAge(){
        return 11;
    }

    public String eat(String food){
        return food;
    }
}
```

###### 创建 Shadow对象

创建`Person`的`Shadow`对象`ShadowPerson`，实现与原始类方法名一致的方法，`Shadow`方法需用`@Implementation`进行注解。

```java
@Implements(Person.class)
public class ShadowPerson {

    @Implementation
    public String getName() {
        return "AndroidUT";
    }

    @Implementation
    public int getSex() {
        return 0;
    }

    @Implementation
    public int getAge(){
        return 18;
    }
}
```

###### Config指定Shadow

在`Config`注解中添加`shadows`参数，指定对应的`Shadow`

```java
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class,
        sdk = 23,
        shadows = {ShadowPerson.class})
public class ShadowTest {

    @Before
    public void setUp() {
        ShadowLog.stream = System.out;
    }

    @Test
    public void testShadowShadow(){
        Person person = new Person();
        //实际上调用的是ShadowPerson的方法
        Log.d("test", person.getName());
        Log.d("test", String.valueOf(person.getAge()));
        Log.d("test", String.valueOf(person.getSex()));

        //获取Person对象对应的Shadow对象
        ShadowPerson shadowPerson = extract(person);
        assertEquals("AndroidUT", shadowPerson.getName());
        assertEquals(18, shadowPerson.getAge());
        assertEquals(0, person.getSex());
    }
}
```

@Implements是声明Shadow的对象，Shadow还可以修改一些函数的功能，只需要在重载该函数的时候添加@Implementation，这种方式可以有效扩展Robolectric的功能。

Shadow是通过对真实的Android对象进行函数重载、初始化等方式对Android对象进行扩展，Shadow出来的对象的功能接近Android对象，可以看成是对Android对象一种修复。自定义的Shadow需要在config中声明，声明写法是@Config(shadows=ShadowPoint.class)。

#### 问题

##### Application和ShadowApplication的区别

分析源码看看ShadowApplication.getInstance()的源码如下：

```java
RuntimeEnvironment.application == null ? null : shadowOf(RuntimeEnvironment.application)
```

其中shadowOf是把真实模拟的Application变成Shadow对象，可以提供一些原本没有的方法。例如RuntimeEnvironment.application可以使用getString去获取字符串信息，而ShadowApplication.getInstance()不行，但他可以使用getNextStartedActivity获取下一个启动的Activity等方法。

##### AndroidManifest问题

很可能运行时就提示:`No such manifest file: build\intermediates\bundles\debug\AndroidManifest.xml`，无法找到AndroidManifest.xml。分析源码可知是路径出现了问题。解决示例：

```java
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class,
       buildDir = "app/build")
public class ExampleUtilsTest{
    //....
}
```

注意相对和绝对路径问题

##### AppCompatActivity问题

使用的Activity是继承自AppCompatActivity，运行的时候会出现`java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.`问题，遇到这个问题只需要把继承AppCompatActivity的主题改为Theme.Appcompat主题或者他的子主题，比如：

```xml
<activity 
    android:name=".MainActivity"
    android:theme="@style/Theme.AppCompat.Light">
    //....
</activity>
```

##### MultiDexApplication问题

你的Application继承自MultiDexApplication就有可能会出现：`java.lang.RuntimeException: Multi dex installation failed.`，那是因为你没有添加shadows-multidex依赖库

```groovy
testCompile "org.robolectric:shadows-multidex:3.+"
```



### 实践

##### 1. 代码中用到了 TextUtils.isEmpty()的如何测试

```java
public static boolean isValidEmail(CharSequence email) {
    if (TextUtils.isEmpty(email)) {
        return false;
    }
    return EMAIL_PATTERN.matcher(email).matches();
}
```

当你尝试本地测试这样的代码，就会收到一下的异常：

```shell
java.lang.RuntimeException: Method isEmpty in android.text.TextUtils not mocked.
```

这种情况，直接在本地测试目录(app/src/test/java)下添加TextUtils类的实现，但必须保证包名相同。

```java
package android.text;

public class TextUtils {
    public static boolean isEmpty(CharSequence str) {
        return str == null || str.length() == 0;
    }
}
```

原理很简单，jvm运行时会找android.text.TextUtils类，然后找isEmpty方法执行。学过java反射的同学都知道，只要知道包名类名，就可以拿到Class，知道该类某方法名，就可以获取Method并执行。jvm也是类似的机制，只要我们给一个包名类名与android sdk相同的类，写上方法名&参数&返回值相同的方法，jvm就能编译并执行。

##### 2. 隔离 native 方法

```java
public class Model {
    public native boolean nativeMethod();
}
```



```java
public class ModelTest {
    Model model;

    @Before
    public void setUp() throws Exception {
        model = mock(Model.class);
    }

    @Test
    public void testNativeMethod() throws Exception {
        when(model.nativeMethod()).thenReturn(true);
        Assert.assertTrue(model.nativeMethod());
    }
}
```

这里稍微讲讲java查找native方法的过程：

1).Model.java全名是com.test.unit.Model.java;

2).调用native方法nativeMethod()后， jvm会去找C++层com_test_unit_Model.cpp，再找com_test_unit_Model_nativeMethod()方法，并调用。

在APP运行过程，我们会把cpp编译成so文件，然后让APP加载到dalvik虚拟机。但在单元测试中，没有加载对应的so文件，也没有编译cpp呀!大牛们可能会尝试单元测试时加载so文件，但完全没有必要，也不符合单元测试的原则。

所以，我们可以直接用Mockito框架mock native方法就行啦。实际上，不仅仅是native方法需要mock，很多依赖的方法、类都要mock，下面会讲到更常用的场景。

##### 3. 在内部 new，不方便 Mock

```java
public class Presenter {

    Model model;
    public Presenter() {
        model = new Model();
    }
    public boolean getBoolean() {
        return model.getBoolean());
    }
}
```

错误的单元测试：

```java
public class PresenterTest{
    Presenter presenter;
    
    @Before
    public void setUp() throws Exception{
        presenter = new Presenter();
    }
    
    @Test
    public void testGetBoolean() throws Exception{
        Assert.assertTrue(presenter.getBoolean());
    }
}
```

依赖隔离。我们隔离Model依赖，即mock Model对象，而不是new Model()。

找找以上PresenterTest的问题吧：PresenterTest完全不知道Model的存在，意思是无法mock Model。那么，我们就想办法把mock Model传给Presenter——在Presenter构造函数传参!

改进 Presenter，传参给构造函数：

```java
public class Presenter {
    Model model;
    public Presenter(Model model) {
        this.model = model;
    }
    public boolean getBoolean() {
        return model.getBoolean();
    }
}
```

这样做方便Mock Model对象。

```java
public class PresenterTest {
    Model     model;
    Presenter presenter;
    
    @Before
    public void setUp() throws Exception {
        // mock Model对象
        model = mock(Model.class);
        presenter = new Presenter(model);
    }

    @Test
    public void testGetBoolean() throws Exception {
        when(model.getBoolean()).thenReturn(true);

        Assert.assertTrue(presenter.getBoolean());
    }
}
```

从这个例子可以看出，代码的框架是否对单元测试友好，也是推进单元测试的一个因素。

##### 4. 本地单元测试-文件操作

在一些涉及到文件读写的App，通常都会在运行时调用Environment.getExternalStorageDirectory()得到机器的外存路径，通常的做法是跑到真机或者模拟器上进行调试，耗时比较长，可以通过模拟的方式，在本地JVM完成文件操作。

```java
//注意包名保持一致
package android.os;
public class Environment {
    public static File getExternalStorageDirectory() {
        return new File("本地文件系统目录");
    }
}
```

直接在本地单元测试进行调试，不再需要跑到真机，再把文件pull出来查看。

```java
public class FileDaoTest {

    public static final String TEST_STRING = "Hello Android Unit Test.";
    
    FileDao fileDao;

    @Before
    public void setUp() throws Exception {
        fileDao = new FileDao();
    }

    @Test
    public void testWrite() throws Exception {
        String name = "readme.md";
        fileDao.write(name, TEST_STRING);
        String content = fileDao.read(name);
        Assert.assertEquals(TEST_STRING, content);
    }
}
```

##### 5. 静态方法

```java
public class Presenter{
    
    public String getSignParams(int uid,String name,String token){
        return SignatureUtils.sign(uid,name,token);
    }
}
```

解决方法：

1. 把 sign(...) 改成非静态方法
2. 把 SignatureUtils 作为成员变量
3. 构造方法传入 SignatureUtils
4. 单元测试时，把 mock SignatureUtils 传给 Presenter

改进后 Presenter：

```java
public class Presenter{
    SignatureUtils mSignUtils;
    
    public Presenter(SignatureUtils signatureUtils){
        this.mSignUtils = signatureUtils;
    }
    
    public String getSignParams(int uid,String name,String token){
        return mSignUtils.sign(uid,name,token);
    }
}
```



### 说明

最小断言数是业务逻辑上的判断，并不是代码的边界条件，真实的case需要考虑代码的边界条件，比如数组为空等条件，因此，最终的断言数量会大于等于最小断言数。在需求业务上，最小断言数也是该需求的业务条件。

单元测试并不是QA的黑盒测试，需要保证对代码逻辑的覆盖。



单元测试并不是一个能直接产生回报的工程，它的运行以及覆盖率也不能直接提升代码质量，但其带来的代码控制力能够大幅度降低大规模协同开发的风险。

在代码存在一定业务耦合度的时候，修改代码就有一定风险，可能会影响之前比较隐蔽的业务逻辑，或者是丢失曾经的补丁，如果有高覆盖率的单元测试工程，就能很快定位到新增代码对现有项目的影响，与QA验收不同，这种影响是代码级的。

单元测试的case和具体页面的具体业务流程以及该业务的代码逻辑紧密联系，单元测试如同技术文档一般，能够体现出一个业务逻辑运行了多少函数，需要注意什么样的条件。这是一种新人了解业务流程、对业务进行代码级别融入的好办法，看一下以前的单元测试case，就能知道与该case对应的那个页面上的那个业务逻辑会执行多少函数，以及这些函数可能出现的结果。

## JaCoCo生成单元测试及覆盖率报告

Jacoco的全称为Java Code Coverage（Java代码覆盖率）是一个开源的覆盖率工具(官网地址：http://www.eclemma.org/JaCoCo/)，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。，可以生成java的单元测试代码覆盖率报告。

很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。

### JaCoCo 包含的覆盖计数器

- 指令级覆盖(Instructions,C0coverage)

  计数单元是单个java二进制代码指令，指令覆盖率提供了代码是否被执行的信息，度量完全 独立源码格式。

- 分支（Branches,C1coverage）

  度量 if 和 switch 语句的分支覆盖情况，计算一个方法里面的总分支数，确定执行和不执行的 分支数量。

- 圈复杂度(CyclomaticComplexity)

  在（线性）组合中，计算在一个方法里面所有可能路径的最小数目，缺失的复杂度同样表示测 试案例没有完全覆盖到这个模块。

- 行覆盖(Lines)

  度量被测程序的每行代码是否被执行，判断标准行中是否至少有一个指令被执行。

- 方法覆盖(non-abstract methods)

  度量被测程序的方法执行情况，是否执行取决于方法中是否有至少一个指令被执行。

- 类覆盖(classes)

  度量计算class类文件是否被执行。

#### 覆盖率报告示例

![](.\png\JaCoCo测试覆盖率.png)

- 绿色：表示行覆盖充分
- 红色：表示未覆盖的行
- 黄色菱形：表示分支覆盖不全
- 绿色菱形：表示分支覆盖完全

### 原理

JaCoCo主要通过代码注入来修改和生成java字节码的方式来实现上面覆盖率的功能。JaCoCo支持的注入方式如下图

![](.\png\JaCoCo支持的注入方式.png)

1. JaCoCo在Byte Code时使用的ASM技术修改字节码方法，可以修改Jar文件、class文件字节码文件。
2. JaCoCo同时支持on-the-fly和offline的两种插桩模式。

#### 插桩模式

##### Offline

在生成最终的目标文件之前，对Class文件进行插桩，生成最终的目标文件，执行目标文件以后得到覆盖执行结果，最终生成覆盖率报告。

##### On-The-Fly

JVM通过-javaagent指定特定的Jar来启动Instrumentation代理程序，代理程序在ClassLoader装载一个class前先判断是否需要对class进行注入，对于需要注入的class进行统计注入。覆盖率结果可以在JVM执行代码的过程中完成。

##### Offline 与 On-The-Fly的比较

On-the-fly模式更方便简单进行代码覆盖分析，无需提前进行字节码插桩，无需考虑classpath 的设置。

存在如下情况不适合on-the-fly，需要采用offline提前对字节码插桩：

(1) 运行环境不支持java agent。

(2) 部署环境不允许设置JVM参数。

(3) 字节码需要被转换成其他的虚拟机如Android Dalvik VM。

(4) 动态修改字节码过程中和其他agent冲突。

(5) 无法自定义用户加载类。

#### 具体实现

JaCoCo是字节码注入方式，它是通过一个Probe探针的方式来注入的。探针是字节指令集插入到java方法中，程序执行后可以被记录，它不会改变原有代码的行为。

##### 添加额外的指令

| Type                | Before                                          | After                                          | Remarks                                                      |
| ------------------- | ----------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| SEQUENCE            | ![](.\png\jacoco_sequence_before.png)           | ![](.\png\jacoco_sequence_after.png)           | 在一个简单的序列的情况下，探针插入两者之间的指令             |
| JUMP(unconditional) | ![](.\png\jacoco_jump_unconditional_before.png) | ![](.\png\jacoco_JUMP_unconditional_after.png) | 作为一个无条件跳转是在任何情况下执行，也可以在GOTO指令插入探针 |
| JUMP(conditional)   | ![](.\png\jacoco_jump_conditional_before.png)   | ![](.\png\jacoco_jump_conditional_after.png)   | 添加一个有条件跳转的探针，有点更棘手。反转操作码的语义和右后的条件跳转加探针。在随后的 GOTO 指令跳到原来的目标 |
| EXIT                | ![](.\png\jacoco_exit_before.png)               | ![](.\png\jacoco_exit_after.png)               | RETURN and THROW，在这些语句之前添加的探针                   |

一个 instrumented class  可以用以下代码检索其探针数组实例：

```java
Object access = ...;		//Retrieve instance

Object[] args = new Object[3];

args[0] = Long.valueOf(8060044182221863588);	//class id

args[1] = "com/example/MyClass";	//class name

args[2] = Integer.valueOf(24);		//probe count

access.equals(args);

boolean[] probes = (boolean[])args[0];
```

JaCoCo 是用一个布尔数组来实现探针，每个探针对应于该数组中的项。当以下四个字节码指令触发时探针进行输入设置为 true:

```java
ALOAD 	probearray
xPUSH 	probeid
ICONST_1
BASTORE
```

JaCoCo对行探针是这样处理的，添加两行指令之间的一个额外的探针时，后续行至少包含一个方法调用。

以上是JaCoCo插桩原理，如果想深入了解，可以去看看它的源码实现。

### JaCoCo 使用方式

## 续~~~

美团技术团队

https://tech.meituan.com/2017/06/16/android-jacoco-practace.html

JaCoCo 原理篇

https://mp.weixin.qq.com/s?__biz=MzIxNzEyMzIzOA==&mid=2652314564&idx=1&sn=a93e6154c92acaef9204b8440e66a852&scene=21#wechat_redirect

## 测试心得

- 考虑可读性

  对于方法名使用表达能力强的方法名，方法名可以采用一种格式，如: [测试的方法]*[测试的条件]*[符合预期的结果]。

- 不要使用逻辑流关键字

  比如(If/else、for、do/while、switch/case)，在一个测试方法中，如果需要有这些，拆分到单独的每个测试方法里。

- 测试真正需要测试的内容

  需要覆盖的情况，一般情况只考虑验证输出（如某操作后，显示什么，值是什么）。

- 不需要考虑测试 private 的方法

  将private方法当做黑盒内部组件，测试对其引用的public方法即可；不考虑测试琐碎的代码，如getter或者setter。

- 每个单元测试方法，应没有先后顺序

  尽可能的解耦对于不同的测试方法，不应该存在Test A与Test B存在时序性的情况。

